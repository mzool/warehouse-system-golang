// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: units_and_categories.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkUnitReferences = `-- name: CheckUnitReferences :one
SELECT COUNT(*) AS count
FROM measure_units
WHERE convert_to = $1
`

func (q *Queries) CheckUnitReferences(ctx context.Context, convertTo pgtype.Int4) (int64, error) {
	row := q.db.QueryRow(ctx, checkUnitReferences, convertTo)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const checkUnitUsedByMaterials = `-- name: CheckUnitUsedByMaterials :one
SELECT COUNT(*) AS count
FROM materials
WHERE measure_unit_id = $1
`

func (q *Queries) CheckUnitUsedByMaterials(ctx context.Context, measureUnitID pgtype.Int4) (int64, error) {
	row := q.db.QueryRow(ctx, checkUnitUsedByMaterials, measureUnitID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countCategories = `-- name: CountCategories :one
SELECT COUNT(*) AS count
FROM material_categories
`

func (q *Queries) CountCategories(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countCategories)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUnits = `-- name: CountUnits :one
SELECT COUNT(*) AS count
FROM measure_units
`

func (q *Queries) CountUnits(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countUnits)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCategory = `-- name: CreateCategory :one
INSERT INTO material_categories (name, description, meta)
VALUES ($1, $2, $3)
RETURNING id, name, description, meta, created_at, updated_at
`

type CreateCategoryParams struct {
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	Meta        []byte      `json:"meta"`
}

func (q *Queries) CreateCategory(ctx context.Context, arg CreateCategoryParams) (MaterialCategory, error) {
	row := q.db.QueryRow(ctx, createCategory, arg.Name, arg.Description, arg.Meta)
	var i MaterialCategory
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Meta,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUnit = `-- name: CreateUnit :one
INSERT INTO measure_units (name, abbreviation, convertion_factor, convert_to)
VALUES ($1, $2, $3, $4)
RETURNING id, name, abbreviation, convertion_factor, convert_to, created_at, updated_at
`

type CreateUnitParams struct {
	Name             string         `json:"name"`
	Abbreviation     string         `json:"abbreviation"`
	ConvertionFactor pgtype.Numeric `json:"convertion_factor"`
	ConvertTo        pgtype.Int4    `json:"convert_to"`
}

func (q *Queries) CreateUnit(ctx context.Context, arg CreateUnitParams) (MeasureUnit, error) {
	row := q.db.QueryRow(ctx, createUnit,
		arg.Name,
		arg.Abbreviation,
		arg.ConvertionFactor,
		arg.ConvertTo,
	)
	var i MeasureUnit
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Abbreviation,
		&i.ConvertionFactor,
		&i.ConvertTo,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteCategory = `-- name: DeleteCategory :exec
DELETE FROM material_categories
WHERE id = $1
`

func (q *Queries) DeleteCategory(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteCategory, id)
	return err
}

const deleteUnit = `-- name: DeleteUnit :exec
DELETE FROM measure_units
WHERE id = $1
`

func (q *Queries) DeleteUnit(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteUnit, id)
	return err
}

const getCategoryByID = `-- name: GetCategoryByID :one
SELECT id, name, description, meta, created_at, updated_at
FROM material_categories
WHERE id = $1
`

func (q *Queries) GetCategoryByID(ctx context.Context, id int32) (MaterialCategory, error) {
	row := q.db.QueryRow(ctx, getCategoryByID, id)
	var i MaterialCategory
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Meta,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCategoryByName = `-- name: GetCategoryByName :one
SELECT id, name, description, meta, created_at, updated_at
FROM material_categories
WHERE name = $1
`

func (q *Queries) GetCategoryByName(ctx context.Context, name string) (MaterialCategory, error) {
	row := q.db.QueryRow(ctx, getCategoryByName, name)
	var i MaterialCategory
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Meta,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUnitByAbbreviation = `-- name: GetUnitByAbbreviation :one
SELECT id, name, abbreviation, convertion_factor, convert_to, created_at, updated_at
FROM measure_units
WHERE abbreviation = $1
`

func (q *Queries) GetUnitByAbbreviation(ctx context.Context, abbreviation string) (MeasureUnit, error) {
	row := q.db.QueryRow(ctx, getUnitByAbbreviation, abbreviation)
	var i MeasureUnit
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Abbreviation,
		&i.ConvertionFactor,
		&i.ConvertTo,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUnitByID = `-- name: GetUnitByID :one
SELECT id, name, abbreviation, convertion_factor, convert_to, created_at, updated_at
FROM measure_units
WHERE id = $1
`

func (q *Queries) GetUnitByID(ctx context.Context, id int32) (MeasureUnit, error) {
	row := q.db.QueryRow(ctx, getUnitByID, id)
	var i MeasureUnit
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Abbreviation,
		&i.ConvertionFactor,
		&i.ConvertTo,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUnitByName = `-- name: GetUnitByName :one
SELECT id, name, abbreviation, convertion_factor, convert_to, created_at, updated_at
FROM measure_units
WHERE name = $1
`

func (q *Queries) GetUnitByName(ctx context.Context, name string) (MeasureUnit, error) {
	row := q.db.QueryRow(ctx, getUnitByName, name)
	var i MeasureUnit
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Abbreviation,
		&i.ConvertionFactor,
		&i.ConvertTo,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listCategories = `-- name: ListCategories :many
SELECT id, name, description, meta, created_at, updated_at
FROM material_categories
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListCategoriesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListCategories(ctx context.Context, arg ListCategoriesParams) ([]MaterialCategory, error) {
	rows, err := q.db.Query(ctx, listCategories, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MaterialCategory{}
	for rows.Next() {
		var i MaterialCategory
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Meta,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnits = `-- name: ListUnits :many
SELECT u.id, u.name, u.abbreviation, u.convertion_factor, u.convert_to, un.name as convert_to_name, u.created_at, u.updated_at
FROM measure_units u LEFT JOIN measure_units un ON u.convert_to = un.id
ORDER BY u.created_at DESC
LIMIT $1 OFFSET $2
`

type ListUnitsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListUnitsRow struct {
	ID               int32              `json:"id"`
	Name             string             `json:"name"`
	Abbreviation     string             `json:"abbreviation"`
	ConvertionFactor pgtype.Numeric     `json:"convertion_factor"`
	ConvertTo        pgtype.Int4        `json:"convert_to"`
	ConvertToName    pgtype.Text        `json:"convert_to_name"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) ListUnits(ctx context.Context, arg ListUnitsParams) ([]ListUnitsRow, error) {
	rows, err := q.db.Query(ctx, listUnits, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUnitsRow{}
	for rows.Next() {
		var i ListUnitsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Abbreviation,
			&i.ConvertionFactor,
			&i.ConvertTo,
			&i.ConvertToName,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCategory = `-- name: UpdateCategory :one
UPDATE material_categories
SET name = COALESCE($2, name),
    description = COALESCE($3, description),
    meta = COALESCE($4, meta),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, name, description, meta, created_at, updated_at
`

type UpdateCategoryParams struct {
	ID          int32       `json:"id"`
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	Meta        []byte      `json:"meta"`
}

func (q *Queries) UpdateCategory(ctx context.Context, arg UpdateCategoryParams) (MaterialCategory, error) {
	row := q.db.QueryRow(ctx, updateCategory,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Meta,
	)
	var i MaterialCategory
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Meta,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUnit = `-- name: UpdateUnit :one
UPDATE measure_units
SET name = COALESCE($2, name),
    abbreviation = COALESCE($3, abbreviation),
    convertion_factor = $4,
    convert_to = $5,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, name, abbreviation, convertion_factor, convert_to, created_at, updated_at
`

type UpdateUnitParams struct {
	ID               int32          `json:"id"`
	Name             string         `json:"name"`
	Abbreviation     string         `json:"abbreviation"`
	ConvertionFactor pgtype.Numeric `json:"convertion_factor"`
	ConvertTo        pgtype.Int4    `json:"convert_to"`
}

func (q *Queries) UpdateUnit(ctx context.Context, arg UpdateUnitParams) (MeasureUnit, error) {
	row := q.db.QueryRow(ctx, updateUnit,
		arg.ID,
		arg.Name,
		arg.Abbreviation,
		arg.ConvertionFactor,
		arg.ConvertTo,
	)
	var i MeasureUnit
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Abbreviation,
		&i.ConvertionFactor,
		&i.ConvertTo,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
