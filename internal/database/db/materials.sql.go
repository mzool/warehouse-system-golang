// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: materials.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const archiveMaterial = `-- name: ArchiveMaterial :exec
UPDATE materials
SET archived = TRUE, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

func (q *Queries) ArchiveMaterial(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, archiveMaterial, id)
	return err
}

type BatchCreateMaterialsParams struct {
	Name          string         `json:"name"`
	Description   pgtype.Text    `json:"description"`
	Type          MaterialType   `json:"type"`
	Saleable      pgtype.Bool    `json:"saleable"`
	UnitPrice     pgtype.Numeric `json:"unit_price"`
	SalePrice     pgtype.Numeric `json:"sale_price"`
	Category      pgtype.Int4    `json:"category"`
	Code          string         `json:"code"`
	Sku           string         `json:"sku"`
	Barcode       pgtype.Text    `json:"barcode"`
	MeasureUnitID pgtype.Int4    `json:"measure_unit_id"`
	Weight        pgtype.Numeric `json:"weight"`
	IsToxic       pgtype.Bool    `json:"is_toxic"`
	IsFlammable   pgtype.Bool    `json:"is_flammable"`
	IsFragile     pgtype.Bool    `json:"is_fragile"`
	TaxRate       pgtype.Numeric `json:"tax_rate"`
	IsActive      pgtype.Bool    `json:"is_active"`
}

const checkDuplicateCode = `-- name: CheckDuplicateCode :one
SELECT EXISTS(
    SELECT 1 FROM materials 
    WHERE code = $1 AND archived = FALSE AND id != COALESCE($2, 0)
) AS exists
`

type CheckDuplicateCodeParams struct {
	Code string `json:"code"`
	ID   int32  `json:"id"`
}

func (q *Queries) CheckDuplicateCode(ctx context.Context, arg CheckDuplicateCodeParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkDuplicateCode, arg.Code, arg.ID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkDuplicateSKU = `-- name: CheckDuplicateSKU :one
SELECT EXISTS(
    SELECT 1 FROM materials 
    WHERE sku = $1 AND archived = FALSE AND id != COALESCE($2, 0)
) AS exists
`

type CheckDuplicateSKUParams struct {
	Sku string `json:"sku"`
	ID  int32  `json:"id"`
}

func (q *Queries) CheckDuplicateSKU(ctx context.Context, arg CheckDuplicateSKUParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkDuplicateSKU, arg.Sku, arg.ID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkMaterialSaleable = `-- name: CheckMaterialSaleable :one
SELECT saleable FROM materials WHERE id = $1 AND archived = FALSE
`

func (q *Queries) CheckMaterialSaleable(ctx context.Context, id int32) (pgtype.Bool, error) {
	row := q.db.QueryRow(ctx, checkMaterialSaleable, id)
	var saleable pgtype.Bool
	err := row.Scan(&saleable)
	return saleable, err
}

const countMaterials = `-- name: CountMaterials :one
SELECT COUNT(*) AS count
FROM materials m
WHERE 
    ($1::BOOLEAN IS NULL OR m.archived = $1)
    AND ($2::TEXT IS NULL OR m.name ILIKE '%' || $2 || '%' OR m.description ILIKE '%' || $2 || '%' OR m.code ILIKE '%' || $2 || '%' OR m.sku ILIKE '%' || $2 || '%')
    AND ($3::material_type IS NULL OR m.type = $3)
    AND ($4::INT IS NULL OR m.category = $4)
    AND ($5::BOOLEAN IS NULL OR m.is_active = $5)
    AND ($6::BOOLEAN IS NULL OR m.saleable = $6)
`

type CountMaterialsParams struct {
	Archived   pgtype.Bool      `json:"archived"`
	Query      pgtype.Text      `json:"query"`
	TypeFilter NullMaterialType `json:"type_filter"`
	Category   pgtype.Int4      `json:"category"`
	IsActive   pgtype.Bool      `json:"is_active"`
	Saleable   pgtype.Bool      `json:"saleable"`
}

func (q *Queries) CountMaterials(ctx context.Context, arg CountMaterialsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countMaterials,
		arg.Archived,
		arg.Query,
		arg.TypeFilter,
		arg.Category,
		arg.IsActive,
		arg.Saleable,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createMaterial = `-- name: CreateMaterial :one
INSERT INTO materials (
    name, description, valuation, type, saleable,
    unit_price, sale_price, category, code, sku, barcode,
    measure_unit_id, weight, volume, density,
    is_toxic, is_flammable, is_fragile,
    image_url, document_url,
    tax_rate, discount_rate,
    is_active, meta
) VALUES (
    $1, $2, $3, $4, $5,
    $6, $7, $8, $9, $10, $11,
    $12, $13, $14, $15,
    $16, $17, $18,
    $19, $20,
    $21, $22,
    $23, $24
)
RETURNING id, name, description, valuation, type, saleable,
    unit_price, sale_price, category, code, sku, barcode,
    measure_unit_id, weight, volume, density,
    is_toxic, is_flammable, is_fragile,
    image_url, document_url,
    tax_rate, discount_rate,
    is_active, archived, meta, created_at, updated_at
`

type CreateMaterialParams struct {
	Name          string              `json:"name"`
	Description   pgtype.Text         `json:"description"`
	Valuation     NullValuationMethod `json:"valuation"`
	Type          MaterialType        `json:"type"`
	Saleable      pgtype.Bool         `json:"saleable"`
	UnitPrice     pgtype.Numeric      `json:"unit_price"`
	SalePrice     pgtype.Numeric      `json:"sale_price"`
	Category      pgtype.Int4         `json:"category"`
	Code          string              `json:"code"`
	Sku           string              `json:"sku"`
	Barcode       pgtype.Text         `json:"barcode"`
	MeasureUnitID pgtype.Int4         `json:"measure_unit_id"`
	Weight        pgtype.Numeric      `json:"weight"`
	Volume        pgtype.Numeric      `json:"volume"`
	Density       pgtype.Numeric      `json:"density"`
	IsToxic       pgtype.Bool         `json:"is_toxic"`
	IsFlammable   pgtype.Bool         `json:"is_flammable"`
	IsFragile     pgtype.Bool         `json:"is_fragile"`
	ImageUrl      pgtype.Text         `json:"image_url"`
	DocumentUrl   pgtype.Text         `json:"document_url"`
	TaxRate       pgtype.Numeric      `json:"tax_rate"`
	DiscountRate  pgtype.Numeric      `json:"discount_rate"`
	IsActive      pgtype.Bool         `json:"is_active"`
	Meta          []byte              `json:"meta"`
}

func (q *Queries) CreateMaterial(ctx context.Context, arg CreateMaterialParams) (Material, error) {
	row := q.db.QueryRow(ctx, createMaterial,
		arg.Name,
		arg.Description,
		arg.Valuation,
		arg.Type,
		arg.Saleable,
		arg.UnitPrice,
		arg.SalePrice,
		arg.Category,
		arg.Code,
		arg.Sku,
		arg.Barcode,
		arg.MeasureUnitID,
		arg.Weight,
		arg.Volume,
		arg.Density,
		arg.IsToxic,
		arg.IsFlammable,
		arg.IsFragile,
		arg.ImageUrl,
		arg.DocumentUrl,
		arg.TaxRate,
		arg.DiscountRate,
		arg.IsActive,
		arg.Meta,
	)
	var i Material
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Valuation,
		&i.Type,
		&i.Saleable,
		&i.UnitPrice,
		&i.SalePrice,
		&i.Category,
		&i.Code,
		&i.Sku,
		&i.Barcode,
		&i.MeasureUnitID,
		&i.Weight,
		&i.Volume,
		&i.Density,
		&i.IsToxic,
		&i.IsFlammable,
		&i.IsFragile,
		&i.ImageUrl,
		&i.DocumentUrl,
		&i.TaxRate,
		&i.DiscountRate,
		&i.IsActive,
		&i.Archived,
		&i.Meta,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteMaterial = `-- name: DeleteMaterial :exec
DELETE FROM materials
WHERE id = $1
`

func (q *Queries) DeleteMaterial(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteMaterial, id)
	return err
}

const exportAllMaterials = `-- name: ExportAllMaterials :many
SELECT 
    m.id, m.name, m.description, m.valuation, m.type, m.saleable,
    m.unit_price, m.sale_price, m.category, 
    mc.name as category_name,
    m.code, m.sku, m.barcode,
    m.measure_unit_id, 
    mu.name as unit_name,
    mu.abbreviation as unit_abbreviation,
    m.weight, m.volume, m.density,
    m.is_toxic, m.is_flammable, m.is_fragile,
    m.image_url, m.document_url,
    m.tax_rate, m.discount_rate,
    m.is_active, m.archived, m.meta,
    m.created_at, m.updated_at
FROM materials m
LEFT JOIN material_categories mc ON m.category = mc.id
LEFT JOIN measure_units mu ON m.measure_unit_id = mu.id
ORDER BY m.created_at DESC
`

type ExportAllMaterialsRow struct {
	ID               int32               `json:"id"`
	Name             string              `json:"name"`
	Description      pgtype.Text         `json:"description"`
	Valuation        NullValuationMethod `json:"valuation"`
	Type             MaterialType        `json:"type"`
	Saleable         pgtype.Bool         `json:"saleable"`
	UnitPrice        pgtype.Numeric      `json:"unit_price"`
	SalePrice        pgtype.Numeric      `json:"sale_price"`
	Category         pgtype.Int4         `json:"category"`
	CategoryName     pgtype.Text         `json:"category_name"`
	Code             string              `json:"code"`
	Sku              string              `json:"sku"`
	Barcode          pgtype.Text         `json:"barcode"`
	MeasureUnitID    pgtype.Int4         `json:"measure_unit_id"`
	UnitName         pgtype.Text         `json:"unit_name"`
	UnitAbbreviation pgtype.Text         `json:"unit_abbreviation"`
	Weight           pgtype.Numeric      `json:"weight"`
	Volume           pgtype.Numeric      `json:"volume"`
	Density          pgtype.Numeric      `json:"density"`
	IsToxic          pgtype.Bool         `json:"is_toxic"`
	IsFlammable      pgtype.Bool         `json:"is_flammable"`
	IsFragile        pgtype.Bool         `json:"is_fragile"`
	ImageUrl         pgtype.Text         `json:"image_url"`
	DocumentUrl      pgtype.Text         `json:"document_url"`
	TaxRate          pgtype.Numeric      `json:"tax_rate"`
	DiscountRate     pgtype.Numeric      `json:"discount_rate"`
	IsActive         pgtype.Bool         `json:"is_active"`
	Archived         pgtype.Bool         `json:"archived"`
	Meta             []byte              `json:"meta"`
	CreatedAt        pgtype.Timestamptz  `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz  `json:"updated_at"`
}

func (q *Queries) ExportAllMaterials(ctx context.Context) ([]ExportAllMaterialsRow, error) {
	rows, err := q.db.Query(ctx, exportAllMaterials)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ExportAllMaterialsRow{}
	for rows.Next() {
		var i ExportAllMaterialsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Valuation,
			&i.Type,
			&i.Saleable,
			&i.UnitPrice,
			&i.SalePrice,
			&i.Category,
			&i.CategoryName,
			&i.Code,
			&i.Sku,
			&i.Barcode,
			&i.MeasureUnitID,
			&i.UnitName,
			&i.UnitAbbreviation,
			&i.Weight,
			&i.Volume,
			&i.Density,
			&i.IsToxic,
			&i.IsFlammable,
			&i.IsFragile,
			&i.ImageUrl,
			&i.DocumentUrl,
			&i.TaxRate,
			&i.DiscountRate,
			&i.IsActive,
			&i.Archived,
			&i.Meta,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMaterialByCode = `-- name: GetMaterialByCode :one
SELECT 
    m.id, m.name, m.description, m.type, m.saleable,
    m.unit_price, m.sale_price, m.code, m.sku,
    m.measure_unit_id, m.category,
    m.is_active, m.created_at, m.updated_at
FROM materials m
WHERE m.code = $1 AND m.archived = FALSE
`

type GetMaterialByCodeRow struct {
	ID            int32              `json:"id"`
	Name          string             `json:"name"`
	Description   pgtype.Text        `json:"description"`
	Type          MaterialType       `json:"type"`
	Saleable      pgtype.Bool        `json:"saleable"`
	UnitPrice     pgtype.Numeric     `json:"unit_price"`
	SalePrice     pgtype.Numeric     `json:"sale_price"`
	Code          string             `json:"code"`
	Sku           string             `json:"sku"`
	MeasureUnitID pgtype.Int4        `json:"measure_unit_id"`
	Category      pgtype.Int4        `json:"category"`
	IsActive      pgtype.Bool        `json:"is_active"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetMaterialByCode(ctx context.Context, code string) (GetMaterialByCodeRow, error) {
	row := q.db.QueryRow(ctx, getMaterialByCode, code)
	var i GetMaterialByCodeRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Type,
		&i.Saleable,
		&i.UnitPrice,
		&i.SalePrice,
		&i.Code,
		&i.Sku,
		&i.MeasureUnitID,
		&i.Category,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMaterialByID = `-- name: GetMaterialByID :one
SELECT 
    m.id, m.name, m.description, m.valuation, m.type, m.saleable,
    m.unit_price, m.sale_price, m.category, 
    mc.name as category_name,
    m.code, m.sku, m.barcode,
    m.measure_unit_id, 
    mu.name as unit_name,
    mu.abbreviation as unit_abbreviation,
    m.weight, m.volume, m.density,
    m.is_toxic, m.is_flammable, m.is_fragile,
    m.image_url, m.document_url,
    m.tax_rate, m.discount_rate,
    m.is_active, m.archived, m.meta,
    m.created_at, m.updated_at
FROM materials m
LEFT JOIN material_categories mc ON m.category = mc.id
LEFT JOIN measure_units mu ON m.measure_unit_id = mu.id
WHERE m.id = $1 AND m.archived = FALSE
`

type GetMaterialByIDRow struct {
	ID               int32               `json:"id"`
	Name             string              `json:"name"`
	Description      pgtype.Text         `json:"description"`
	Valuation        NullValuationMethod `json:"valuation"`
	Type             MaterialType        `json:"type"`
	Saleable         pgtype.Bool         `json:"saleable"`
	UnitPrice        pgtype.Numeric      `json:"unit_price"`
	SalePrice        pgtype.Numeric      `json:"sale_price"`
	Category         pgtype.Int4         `json:"category"`
	CategoryName     pgtype.Text         `json:"category_name"`
	Code             string              `json:"code"`
	Sku              string              `json:"sku"`
	Barcode          pgtype.Text         `json:"barcode"`
	MeasureUnitID    pgtype.Int4         `json:"measure_unit_id"`
	UnitName         pgtype.Text         `json:"unit_name"`
	UnitAbbreviation pgtype.Text         `json:"unit_abbreviation"`
	Weight           pgtype.Numeric      `json:"weight"`
	Volume           pgtype.Numeric      `json:"volume"`
	Density          pgtype.Numeric      `json:"density"`
	IsToxic          pgtype.Bool         `json:"is_toxic"`
	IsFlammable      pgtype.Bool         `json:"is_flammable"`
	IsFragile        pgtype.Bool         `json:"is_fragile"`
	ImageUrl         pgtype.Text         `json:"image_url"`
	DocumentUrl      pgtype.Text         `json:"document_url"`
	TaxRate          pgtype.Numeric      `json:"tax_rate"`
	DiscountRate     pgtype.Numeric      `json:"discount_rate"`
	IsActive         pgtype.Bool         `json:"is_active"`
	Archived         pgtype.Bool         `json:"archived"`
	Meta             []byte              `json:"meta"`
	CreatedAt        pgtype.Timestamptz  `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz  `json:"updated_at"`
}

func (q *Queries) GetMaterialByID(ctx context.Context, id int32) (GetMaterialByIDRow, error) {
	row := q.db.QueryRow(ctx, getMaterialByID, id)
	var i GetMaterialByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Valuation,
		&i.Type,
		&i.Saleable,
		&i.UnitPrice,
		&i.SalePrice,
		&i.Category,
		&i.CategoryName,
		&i.Code,
		&i.Sku,
		&i.Barcode,
		&i.MeasureUnitID,
		&i.UnitName,
		&i.UnitAbbreviation,
		&i.Weight,
		&i.Volume,
		&i.Density,
		&i.IsToxic,
		&i.IsFlammable,
		&i.IsFragile,
		&i.ImageUrl,
		&i.DocumentUrl,
		&i.TaxRate,
		&i.DiscountRate,
		&i.IsActive,
		&i.Archived,
		&i.Meta,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMaterialBySKU = `-- name: GetMaterialBySKU :one
SELECT 
    m.id, m.name, m.description, m.type, m.saleable,
    m.unit_price, m.sale_price, m.code, m.sku,
    m.measure_unit_id, m.category,
    m.is_active, m.created_at, m.updated_at
FROM materials m
WHERE m.sku = $1 AND m.archived = FALSE
`

type GetMaterialBySKURow struct {
	ID            int32              `json:"id"`
	Name          string             `json:"name"`
	Description   pgtype.Text        `json:"description"`
	Type          MaterialType       `json:"type"`
	Saleable      pgtype.Bool        `json:"saleable"`
	UnitPrice     pgtype.Numeric     `json:"unit_price"`
	SalePrice     pgtype.Numeric     `json:"sale_price"`
	Code          string             `json:"code"`
	Sku           string             `json:"sku"`
	MeasureUnitID pgtype.Int4        `json:"measure_unit_id"`
	Category      pgtype.Int4        `json:"category"`
	IsActive      pgtype.Bool        `json:"is_active"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
}

// ============================================================================
// GET MATERIAL BY SKU
// ============================================================================
func (q *Queries) GetMaterialBySKU(ctx context.Context, sku string) (GetMaterialBySKURow, error) {
	row := q.db.QueryRow(ctx, getMaterialBySKU, sku)
	var i GetMaterialBySKURow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Type,
		&i.Saleable,
		&i.UnitPrice,
		&i.SalePrice,
		&i.Code,
		&i.Sku,
		&i.MeasureUnitID,
		&i.Category,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listActiveMaterials = `-- name: ListActiveMaterials :many
SELECT 
    m.id, m.name, m.code, m.sku, m.type,
    m.unit_price, m.sale_price,
    m.measure_unit_id,
    mu.abbreviation as unit_abbreviation
FROM materials m
LEFT JOIN measure_units mu ON m.measure_unit_id = mu.id
WHERE m.is_active = TRUE AND m.archived = FALSE
ORDER BY m.name ASC
LIMIT $1 OFFSET $2
`

type ListActiveMaterialsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListActiveMaterialsRow struct {
	ID               int32          `json:"id"`
	Name             string         `json:"name"`
	Code             string         `json:"code"`
	Sku              string         `json:"sku"`
	Type             MaterialType   `json:"type"`
	UnitPrice        pgtype.Numeric `json:"unit_price"`
	SalePrice        pgtype.Numeric `json:"sale_price"`
	MeasureUnitID    pgtype.Int4    `json:"measure_unit_id"`
	UnitAbbreviation pgtype.Text    `json:"unit_abbreviation"`
}

func (q *Queries) ListActiveMaterials(ctx context.Context, arg ListActiveMaterialsParams) ([]ListActiveMaterialsRow, error) {
	rows, err := q.db.Query(ctx, listActiveMaterials, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListActiveMaterialsRow{}
	for rows.Next() {
		var i ListActiveMaterialsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Code,
			&i.Sku,
			&i.Type,
			&i.UnitPrice,
			&i.SalePrice,
			&i.MeasureUnitID,
			&i.UnitAbbreviation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const restoreMaterial = `-- name: RestoreMaterial :exec
UPDATE materials
SET archived = FALSE, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

func (q *Queries) RestoreMaterial(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, restoreMaterial, id)
	return err
}

const searchMaterials = `-- name: SearchMaterials :many
SELECT 
    m.id, m.name, m.description, m.valuation, m.type, m.saleable,
    m.unit_price, m.sale_price, m.category,
    mc.name as category_name,
    m.code, m.sku, m.barcode,
    m.measure_unit_id,
    mu.name as unit_name,
    mu.abbreviation as unit_abbreviation,
    m.weight, m.volume, m.density,
    m.is_toxic, m.is_flammable, m.is_fragile,
    m.image_url, m.document_url,
    m.tax_rate, m.discount_rate,
    m.is_active, m.archived, m.meta,
    m.created_at, m.updated_at
FROM materials m
LEFT JOIN material_categories mc ON m.category = mc.id
LEFT JOIN measure_units mu ON m.measure_unit_id = mu.id
WHERE 
    ($3::BOOLEAN IS NULL OR m.archived = $3)
    AND ($4::TEXT IS NULL OR m.name ILIKE '%' || $4 || '%' OR m.description ILIKE '%' || $4 || '%' OR m.code ILIKE '%' || $4 || '%' OR m.sku ILIKE '%' || $4 || '%')
    AND ($5::material_type IS NULL OR m.type = $5)
    AND ($6::INT IS NULL OR m.category = $6)
    AND ($7::BOOLEAN IS NULL OR m.is_active = $7)
    AND ($8::BOOLEAN IS NULL OR m.saleable = $8)
ORDER BY m.created_at DESC
LIMIT $1 OFFSET $2
`

type SearchMaterialsParams struct {
	Limit      int32            `json:"limit"`
	Offset     int32            `json:"offset"`
	Archived   pgtype.Bool      `json:"archived"`
	Query      pgtype.Text      `json:"query"`
	TypeFilter NullMaterialType `json:"type_filter"`
	Category   pgtype.Int4      `json:"category"`
	IsActive   pgtype.Bool      `json:"is_active"`
	Saleable   pgtype.Bool      `json:"saleable"`
}

type SearchMaterialsRow struct {
	ID               int32               `json:"id"`
	Name             string              `json:"name"`
	Description      pgtype.Text         `json:"description"`
	Valuation        NullValuationMethod `json:"valuation"`
	Type             MaterialType        `json:"type"`
	Saleable         pgtype.Bool         `json:"saleable"`
	UnitPrice        pgtype.Numeric      `json:"unit_price"`
	SalePrice        pgtype.Numeric      `json:"sale_price"`
	Category         pgtype.Int4         `json:"category"`
	CategoryName     pgtype.Text         `json:"category_name"`
	Code             string              `json:"code"`
	Sku              string              `json:"sku"`
	Barcode          pgtype.Text         `json:"barcode"`
	MeasureUnitID    pgtype.Int4         `json:"measure_unit_id"`
	UnitName         pgtype.Text         `json:"unit_name"`
	UnitAbbreviation pgtype.Text         `json:"unit_abbreviation"`
	Weight           pgtype.Numeric      `json:"weight"`
	Volume           pgtype.Numeric      `json:"volume"`
	Density          pgtype.Numeric      `json:"density"`
	IsToxic          pgtype.Bool         `json:"is_toxic"`
	IsFlammable      pgtype.Bool         `json:"is_flammable"`
	IsFragile        pgtype.Bool         `json:"is_fragile"`
	ImageUrl         pgtype.Text         `json:"image_url"`
	DocumentUrl      pgtype.Text         `json:"document_url"`
	TaxRate          pgtype.Numeric      `json:"tax_rate"`
	DiscountRate     pgtype.Numeric      `json:"discount_rate"`
	IsActive         pgtype.Bool         `json:"is_active"`
	Archived         pgtype.Bool         `json:"archived"`
	Meta             []byte              `json:"meta"`
	CreatedAt        pgtype.Timestamptz  `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz  `json:"updated_at"`
}

// ============================================================================
// SEARCH MATERIALS (with filters and pagination)
// ============================================================================
func (q *Queries) SearchMaterials(ctx context.Context, arg SearchMaterialsParams) ([]SearchMaterialsRow, error) {
	rows, err := q.db.Query(ctx, searchMaterials,
		arg.Limit,
		arg.Offset,
		arg.Archived,
		arg.Query,
		arg.TypeFilter,
		arg.Category,
		arg.IsActive,
		arg.Saleable,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchMaterialsRow{}
	for rows.Next() {
		var i SearchMaterialsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Valuation,
			&i.Type,
			&i.Saleable,
			&i.UnitPrice,
			&i.SalePrice,
			&i.Category,
			&i.CategoryName,
			&i.Code,
			&i.Sku,
			&i.Barcode,
			&i.MeasureUnitID,
			&i.UnitName,
			&i.UnitAbbreviation,
			&i.Weight,
			&i.Volume,
			&i.Density,
			&i.IsToxic,
			&i.IsFlammable,
			&i.IsFragile,
			&i.ImageUrl,
			&i.DocumentUrl,
			&i.TaxRate,
			&i.DiscountRate,
			&i.IsActive,
			&i.Archived,
			&i.Meta,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMaterial = `-- name: UpdateMaterial :one
UPDATE materials
SET 
    name = COALESCE(NULLIF($2, ''), name),
    description = COALESCE($3, description),
    valuation = COALESCE($4, valuation),
    type = COALESCE($5, type),
    saleable = COALESCE($6, saleable),
    unit_price = COALESCE($7, unit_price),
    sale_price = COALESCE($8, sale_price),
    category = COALESCE($9, category),
    code = COALESCE(NULLIF($10, ''), code),
    sku = COALESCE(NULLIF($11, ''), sku),
    barcode = $12,
    measure_unit_id = COALESCE($13, measure_unit_id),
    weight = COALESCE($14, weight),
    volume = COALESCE($15, volume),
    density = COALESCE($16, density),
    is_toxic = COALESCE($17, is_toxic),
    is_flammable = COALESCE($18, is_flammable),
    is_fragile = COALESCE($19, is_fragile),
    image_url = $20,
    document_url = $21,
    tax_rate = COALESCE($22, tax_rate),
    discount_rate = COALESCE($23, discount_rate),
    is_active = COALESCE($24, is_active),
    meta = COALESCE($25, meta),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND archived = FALSE
RETURNING id, name, description, valuation, type, saleable,
    unit_price, sale_price, category, code, sku, barcode,
    measure_unit_id, weight, volume, density,
    is_toxic, is_flammable, is_fragile,
    image_url, document_url,
    tax_rate, discount_rate,
    is_active, archived, meta, created_at, updated_at
`

type UpdateMaterialParams struct {
	ID            int32               `json:"id"`
	Column2       interface{}         `json:"column_2"`
	Description   pgtype.Text         `json:"description"`
	Valuation     NullValuationMethod `json:"valuation"`
	Type          MaterialType        `json:"type"`
	Saleable      pgtype.Bool         `json:"saleable"`
	UnitPrice     pgtype.Numeric      `json:"unit_price"`
	SalePrice     pgtype.Numeric      `json:"sale_price"`
	Category      pgtype.Int4         `json:"category"`
	Column10      interface{}         `json:"column_10"`
	Column11      interface{}         `json:"column_11"`
	Barcode       pgtype.Text         `json:"barcode"`
	MeasureUnitID pgtype.Int4         `json:"measure_unit_id"`
	Weight        pgtype.Numeric      `json:"weight"`
	Volume        pgtype.Numeric      `json:"volume"`
	Density       pgtype.Numeric      `json:"density"`
	IsToxic       pgtype.Bool         `json:"is_toxic"`
	IsFlammable   pgtype.Bool         `json:"is_flammable"`
	IsFragile     pgtype.Bool         `json:"is_fragile"`
	ImageUrl      pgtype.Text         `json:"image_url"`
	DocumentUrl   pgtype.Text         `json:"document_url"`
	TaxRate       pgtype.Numeric      `json:"tax_rate"`
	DiscountRate  pgtype.Numeric      `json:"discount_rate"`
	IsActive      pgtype.Bool         `json:"is_active"`
	Meta          []byte              `json:"meta"`
}

// ============================================================================
// UPDATE MATERIAL
// ============================================================================
func (q *Queries) UpdateMaterial(ctx context.Context, arg UpdateMaterialParams) (Material, error) {
	row := q.db.QueryRow(ctx, updateMaterial,
		arg.ID,
		arg.Column2,
		arg.Description,
		arg.Valuation,
		arg.Type,
		arg.Saleable,
		arg.UnitPrice,
		arg.SalePrice,
		arg.Category,
		arg.Column10,
		arg.Column11,
		arg.Barcode,
		arg.MeasureUnitID,
		arg.Weight,
		arg.Volume,
		arg.Density,
		arg.IsToxic,
		arg.IsFlammable,
		arg.IsFragile,
		arg.ImageUrl,
		arg.DocumentUrl,
		arg.TaxRate,
		arg.DiscountRate,
		arg.IsActive,
		arg.Meta,
	)
	var i Material
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Valuation,
		&i.Type,
		&i.Saleable,
		&i.UnitPrice,
		&i.SalePrice,
		&i.Category,
		&i.Code,
		&i.Sku,
		&i.Barcode,
		&i.MeasureUnitID,
		&i.Weight,
		&i.Volume,
		&i.Density,
		&i.IsToxic,
		&i.IsFlammable,
		&i.IsFragile,
		&i.ImageUrl,
		&i.DocumentUrl,
		&i.TaxRate,
		&i.DiscountRate,
		&i.IsActive,
		&i.Archived,
		&i.Meta,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
