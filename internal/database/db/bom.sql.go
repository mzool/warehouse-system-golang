// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: bom.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const archiveBOM = `-- name: ArchiveBOM :one
UPDATE bills_of_materials
SET archived = TRUE, archived_by = $2, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING 
    id, finished_material_id, component_material_id, quantity, unit_measure_id, meta, 
    scrap_percentage, fixed_quantity, is_optional, priority, reference_designator, 
    notes, effective_date, expiry_date, version, operation_sequence, 
    estimated_cost, actual_cost, lead_time_days, supplier_id, alternate_component_id, 
    is_active, archived, archived_at, archived_by, created_at, updated_at
`

type ArchiveBOMParams struct {
	ID         int32       `json:"id"`
	ArchivedBy pgtype.Int4 `json:"archived_by"`
}

type ArchiveBOMRow struct {
	ID                   int32              `json:"id"`
	FinishedMaterialID   pgtype.Int4        `json:"finished_material_id"`
	ComponentMaterialID  pgtype.Int4        `json:"component_material_id"`
	Quantity             pgtype.Numeric     `json:"quantity"`
	UnitMeasureID        pgtype.Int4        `json:"unit_measure_id"`
	Meta                 []byte             `json:"meta"`
	ScrapPercentage      pgtype.Numeric     `json:"scrap_percentage"`
	FixedQuantity        pgtype.Bool        `json:"fixed_quantity"`
	IsOptional           pgtype.Bool        `json:"is_optional"`
	Priority             pgtype.Int4        `json:"priority"`
	ReferenceDesignator  pgtype.Text        `json:"reference_designator"`
	Notes                pgtype.Text        `json:"notes"`
	EffectiveDate        pgtype.Date        `json:"effective_date"`
	ExpiryDate           pgtype.Date        `json:"expiry_date"`
	Version              pgtype.Text        `json:"version"`
	OperationSequence    pgtype.Int4        `json:"operation_sequence"`
	EstimatedCost        pgtype.Numeric     `json:"estimated_cost"`
	ActualCost           pgtype.Numeric     `json:"actual_cost"`
	LeadTimeDays         pgtype.Int4        `json:"lead_time_days"`
	SupplierID           pgtype.Int4        `json:"supplier_id"`
	AlternateComponentID pgtype.Int4        `json:"alternate_component_id"`
	IsActive             pgtype.Bool        `json:"is_active"`
	Archived             pgtype.Bool        `json:"archived"`
	ArchivedAt           pgtype.Timestamptz `json:"archived_at"`
	ArchivedBy           pgtype.Int4        `json:"archived_by"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) ArchiveBOM(ctx context.Context, arg ArchiveBOMParams) (ArchiveBOMRow, error) {
	row := q.db.QueryRow(ctx, archiveBOM, arg.ID, arg.ArchivedBy)
	var i ArchiveBOMRow
	err := row.Scan(
		&i.ID,
		&i.FinishedMaterialID,
		&i.ComponentMaterialID,
		&i.Quantity,
		&i.UnitMeasureID,
		&i.Meta,
		&i.ScrapPercentage,
		&i.FixedQuantity,
		&i.IsOptional,
		&i.Priority,
		&i.ReferenceDesignator,
		&i.Notes,
		&i.EffectiveDate,
		&i.ExpiryDate,
		&i.Version,
		&i.OperationSequence,
		&i.EstimatedCost,
		&i.ActualCost,
		&i.LeadTimeDays,
		&i.SupplierID,
		&i.AlternateComponentID,
		&i.IsActive,
		&i.Archived,
		&i.ArchivedAt,
		&i.ArchivedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const bulkUpdateBOMPriority = `-- name: BulkUpdateBOMPriority :exec
UPDATE bills_of_materials
SET priority = $2, updated_at = CURRENT_TIMESTAMP
WHERE id = ANY($1::INT[])
`

type BulkUpdateBOMPriorityParams struct {
	Column1  []int32     `json:"column_1"`
	Priority pgtype.Int4 `json:"priority"`
}

func (q *Queries) BulkUpdateBOMPriority(ctx context.Context, arg BulkUpdateBOMPriorityParams) error {
	_, err := q.db.Exec(ctx, bulkUpdateBOMPriority, arg.Column1, arg.Priority)
	return err
}

const checkBOMExists = `-- name: CheckBOMExists :one
SELECT EXISTS(
    SELECT 1 FROM bills_of_materials 
    WHERE finished_material_id = $1 
        AND component_material_id = $2 
        AND version = $3
        AND archived = FALSE
) AS exists
`

type CheckBOMExistsParams struct {
	FinishedMaterialID  pgtype.Int4 `json:"finished_material_id"`
	ComponentMaterialID pgtype.Int4 `json:"component_material_id"`
	Version             pgtype.Text `json:"version"`
}

func (q *Queries) CheckBOMExists(ctx context.Context, arg CheckBOMExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkBOMExists, arg.FinishedMaterialID, arg.ComponentMaterialID, arg.Version)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const cloneBOMVersion = `-- name: CloneBOMVersion :exec
INSERT INTO bills_of_materials (
    finished_material_id, component_material_id, quantity, unit_measure_id, meta,
    scrap_percentage, fixed_quantity, is_optional, priority, reference_designator, 
    notes, effective_date, expiry_date, version, operation_sequence, 
    estimated_cost, lead_time_days, supplier_id, alternate_component_id, is_active
)
SELECT 
    b.finished_material_id, b.component_material_id, b.quantity, b.unit_measure_id, b.meta,
    b.scrap_percentage, b.fixed_quantity, b.is_optional, b.priority, b.reference_designator, 
    b.notes, $2::DATE as effective_date, NULL as expiry_date, $3 as version, b.operation_sequence, 
    b.estimated_cost, b.lead_time_days, b.supplier_id, b.alternate_component_id, TRUE as is_active
FROM bills_of_materials b
WHERE b.finished_material_id = $1 AND b.version = $4 AND b.archived = FALSE
`

type CloneBOMVersionParams struct {
	FinishedMaterialID pgtype.Int4 `json:"finished_material_id"`
	Column2            pgtype.Date `json:"column_2"`
	Version            pgtype.Text `json:"version"`
	Version_2          pgtype.Text `json:"version_2"`
}

func (q *Queries) CloneBOMVersion(ctx context.Context, arg CloneBOMVersionParams) error {
	_, err := q.db.Exec(ctx, cloneBOMVersion,
		arg.FinishedMaterialID,
		arg.Column2,
		arg.Version,
		arg.Version_2,
	)
	return err
}

const countBillsOfMaterials = `-- name: CountBillsOfMaterials :one
SELECT COUNT(*) AS count
FROM bills_of_materials
WHERE archived = FALSE
`

func (q *Queries) CountBillsOfMaterials(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countBillsOfMaterials)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSearchBillsOfMaterials = `-- name: CountSearchBillsOfMaterials :one
SELECT COUNT(*) AS count
FROM bills_of_materials b
LEFT JOIN materials fm ON b.finished_material_id = fm.id
LEFT JOIN materials cm ON b.component_material_id = cm.id
WHERE b.archived = FALSE
    AND ($1::TEXT IS NULL OR 
     fm.name ILIKE '%' || $1 || '%' OR 
     fm.code ILIKE '%' || $1 || '%' OR
     cm.name ILIKE '%' || $1 || '%' OR
     cm.code ILIKE '%' || $1 || '%' OR
     b.version ILIKE '%' || $1 || '%')
`

func (q *Queries) CountSearchBillsOfMaterials(ctx context.Context, query pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, countSearchBillsOfMaterials, query)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createBillOfMaterial = `-- name: CreateBillOfMaterial :one
INSERT INTO bills_of_materials (
    finished_material_id, component_material_id, quantity, unit_measure_id, meta,
    scrap_percentage, fixed_quantity, is_optional, priority, reference_designator, 
    notes, effective_date, expiry_date, version, operation_sequence, 
    estimated_cost, lead_time_days, supplier_id, alternate_component_id, is_active
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20)
RETURNING 
    id, finished_material_id, component_material_id, quantity, unit_measure_id, meta, 
    scrap_percentage, fixed_quantity, is_optional, priority, reference_designator, 
    notes, effective_date, expiry_date, version, operation_sequence, 
    estimated_cost, actual_cost, lead_time_days, supplier_id, alternate_component_id, 
    is_active, archived, archived_at, archived_by, created_at, updated_at
`

type CreateBillOfMaterialParams struct {
	FinishedMaterialID   pgtype.Int4    `json:"finished_material_id"`
	ComponentMaterialID  pgtype.Int4    `json:"component_material_id"`
	Quantity             pgtype.Numeric `json:"quantity"`
	UnitMeasureID        pgtype.Int4    `json:"unit_measure_id"`
	Meta                 []byte         `json:"meta"`
	ScrapPercentage      pgtype.Numeric `json:"scrap_percentage"`
	FixedQuantity        pgtype.Bool    `json:"fixed_quantity"`
	IsOptional           pgtype.Bool    `json:"is_optional"`
	Priority             pgtype.Int4    `json:"priority"`
	ReferenceDesignator  pgtype.Text    `json:"reference_designator"`
	Notes                pgtype.Text    `json:"notes"`
	EffectiveDate        pgtype.Date    `json:"effective_date"`
	ExpiryDate           pgtype.Date    `json:"expiry_date"`
	Version              pgtype.Text    `json:"version"`
	OperationSequence    pgtype.Int4    `json:"operation_sequence"`
	EstimatedCost        pgtype.Numeric `json:"estimated_cost"`
	LeadTimeDays         pgtype.Int4    `json:"lead_time_days"`
	SupplierID           pgtype.Int4    `json:"supplier_id"`
	AlternateComponentID pgtype.Int4    `json:"alternate_component_id"`
	IsActive             pgtype.Bool    `json:"is_active"`
}

type CreateBillOfMaterialRow struct {
	ID                   int32              `json:"id"`
	FinishedMaterialID   pgtype.Int4        `json:"finished_material_id"`
	ComponentMaterialID  pgtype.Int4        `json:"component_material_id"`
	Quantity             pgtype.Numeric     `json:"quantity"`
	UnitMeasureID        pgtype.Int4        `json:"unit_measure_id"`
	Meta                 []byte             `json:"meta"`
	ScrapPercentage      pgtype.Numeric     `json:"scrap_percentage"`
	FixedQuantity        pgtype.Bool        `json:"fixed_quantity"`
	IsOptional           pgtype.Bool        `json:"is_optional"`
	Priority             pgtype.Int4        `json:"priority"`
	ReferenceDesignator  pgtype.Text        `json:"reference_designator"`
	Notes                pgtype.Text        `json:"notes"`
	EffectiveDate        pgtype.Date        `json:"effective_date"`
	ExpiryDate           pgtype.Date        `json:"expiry_date"`
	Version              pgtype.Text        `json:"version"`
	OperationSequence    pgtype.Int4        `json:"operation_sequence"`
	EstimatedCost        pgtype.Numeric     `json:"estimated_cost"`
	ActualCost           pgtype.Numeric     `json:"actual_cost"`
	LeadTimeDays         pgtype.Int4        `json:"lead_time_days"`
	SupplierID           pgtype.Int4        `json:"supplier_id"`
	AlternateComponentID pgtype.Int4        `json:"alternate_component_id"`
	IsActive             pgtype.Bool        `json:"is_active"`
	Archived             pgtype.Bool        `json:"archived"`
	ArchivedAt           pgtype.Timestamptz `json:"archived_at"`
	ArchivedBy           pgtype.Int4        `json:"archived_by"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreateBillOfMaterial(ctx context.Context, arg CreateBillOfMaterialParams) (CreateBillOfMaterialRow, error) {
	row := q.db.QueryRow(ctx, createBillOfMaterial,
		arg.FinishedMaterialID,
		arg.ComponentMaterialID,
		arg.Quantity,
		arg.UnitMeasureID,
		arg.Meta,
		arg.ScrapPercentage,
		arg.FixedQuantity,
		arg.IsOptional,
		arg.Priority,
		arg.ReferenceDesignator,
		arg.Notes,
		arg.EffectiveDate,
		arg.ExpiryDate,
		arg.Version,
		arg.OperationSequence,
		arg.EstimatedCost,
		arg.LeadTimeDays,
		arg.SupplierID,
		arg.AlternateComponentID,
		arg.IsActive,
	)
	var i CreateBillOfMaterialRow
	err := row.Scan(
		&i.ID,
		&i.FinishedMaterialID,
		&i.ComponentMaterialID,
		&i.Quantity,
		&i.UnitMeasureID,
		&i.Meta,
		&i.ScrapPercentage,
		&i.FixedQuantity,
		&i.IsOptional,
		&i.Priority,
		&i.ReferenceDesignator,
		&i.Notes,
		&i.EffectiveDate,
		&i.ExpiryDate,
		&i.Version,
		&i.OperationSequence,
		&i.EstimatedCost,
		&i.ActualCost,
		&i.LeadTimeDays,
		&i.SupplierID,
		&i.AlternateComponentID,
		&i.IsActive,
		&i.Archived,
		&i.ArchivedAt,
		&i.ArchivedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteBillOfMaterial = `-- name: DeleteBillOfMaterial :exec
DELETE FROM bills_of_materials
WHERE id = $1
`

func (q *Queries) DeleteBillOfMaterial(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteBillOfMaterial, id)
	return err
}

const deleteBillOfMaterialsByComponent = `-- name: DeleteBillOfMaterialsByComponent :exec
DELETE FROM bills_of_materials
WHERE component_material_id = $1
`

func (q *Queries) DeleteBillOfMaterialsByComponent(ctx context.Context, componentMaterialID pgtype.Int4) error {
	_, err := q.db.Exec(ctx, deleteBillOfMaterialsByComponent, componentMaterialID)
	return err
}

const deleteBillOfMaterialsByFinishedMaterial = `-- name: DeleteBillOfMaterialsByFinishedMaterial :exec
DELETE FROM bills_of_materials
WHERE finished_material_id = $1
`

func (q *Queries) DeleteBillOfMaterialsByFinishedMaterial(ctx context.Context, finishedMaterialID pgtype.Int4) error {
	_, err := q.db.Exec(ctx, deleteBillOfMaterialsByFinishedMaterial, finishedMaterialID)
	return err
}

const getActiveBOMsByFinishedMaterial = `-- name: GetActiveBOMsByFinishedMaterial :many
SELECT 
    b.id, b.finished_material_id, b.component_material_id, b.quantity, b.unit_measure_id, b.meta, 
    b.scrap_percentage, b.fixed_quantity, b.is_optional, b.priority, b.reference_designator,
    b.notes, b.effective_date, b.expiry_date, b.version, b.operation_sequence,
    b.estimated_cost, b.actual_cost, b.lead_time_days, b.supplier_id, b.alternate_component_id,
    b.is_active, b.archived, b.created_at, b.updated_at,
    cm.name as component_material_name,
    cm.code as component_material_code,
    cm.unit_price as component_unit_price,
    mu.name as unit_name,
    mu.abbreviation as unit_abbreviation,
    s.name as supplier_name,
    alt.name as alternate_component_name,
    (b.quantity * (1 + (b.scrap_percentage / 100))) as adjusted_quantity,
    COALESCE(b.estimated_cost, b.quantity * (1 + (b.scrap_percentage / 100)) * COALESCE(cm.unit_price, 0)) as calculated_cost
FROM bills_of_materials b
LEFT JOIN materials cm ON b.component_material_id = cm.id
LEFT JOIN measure_units mu ON b.unit_measure_id = mu.id
LEFT JOIN suppliers s ON b.supplier_id = s.id
LEFT JOIN materials alt ON b.alternate_component_id = alt.id
WHERE b.finished_material_id = $1 
    AND b.is_active = TRUE 
    AND b.archived = FALSE
    AND (b.effective_date IS NULL OR b.effective_date <= CURRENT_DATE)
    AND (b.expiry_date IS NULL OR b.expiry_date > CURRENT_DATE)
ORDER BY b.priority, b.operation_sequence NULLS LAST
`

type GetActiveBOMsByFinishedMaterialRow struct {
	ID                     int32              `json:"id"`
	FinishedMaterialID     pgtype.Int4        `json:"finished_material_id"`
	ComponentMaterialID    pgtype.Int4        `json:"component_material_id"`
	Quantity               pgtype.Numeric     `json:"quantity"`
	UnitMeasureID          pgtype.Int4        `json:"unit_measure_id"`
	Meta                   []byte             `json:"meta"`
	ScrapPercentage        pgtype.Numeric     `json:"scrap_percentage"`
	FixedQuantity          pgtype.Bool        `json:"fixed_quantity"`
	IsOptional             pgtype.Bool        `json:"is_optional"`
	Priority               pgtype.Int4        `json:"priority"`
	ReferenceDesignator    pgtype.Text        `json:"reference_designator"`
	Notes                  pgtype.Text        `json:"notes"`
	EffectiveDate          pgtype.Date        `json:"effective_date"`
	ExpiryDate             pgtype.Date        `json:"expiry_date"`
	Version                pgtype.Text        `json:"version"`
	OperationSequence      pgtype.Int4        `json:"operation_sequence"`
	EstimatedCost          pgtype.Numeric     `json:"estimated_cost"`
	ActualCost             pgtype.Numeric     `json:"actual_cost"`
	LeadTimeDays           pgtype.Int4        `json:"lead_time_days"`
	SupplierID             pgtype.Int4        `json:"supplier_id"`
	AlternateComponentID   pgtype.Int4        `json:"alternate_component_id"`
	IsActive               pgtype.Bool        `json:"is_active"`
	Archived               pgtype.Bool        `json:"archived"`
	CreatedAt              pgtype.Timestamptz `json:"created_at"`
	UpdatedAt              pgtype.Timestamptz `json:"updated_at"`
	ComponentMaterialName  pgtype.Text        `json:"component_material_name"`
	ComponentMaterialCode  pgtype.Text        `json:"component_material_code"`
	ComponentUnitPrice     pgtype.Numeric     `json:"component_unit_price"`
	UnitName               pgtype.Text        `json:"unit_name"`
	UnitAbbreviation       pgtype.Text        `json:"unit_abbreviation"`
	SupplierName           pgtype.Text        `json:"supplier_name"`
	AlternateComponentName pgtype.Text        `json:"alternate_component_name"`
	AdjustedQuantity       int32              `json:"adjusted_quantity"`
	CalculatedCost         pgtype.Numeric     `json:"calculated_cost"`
}

func (q *Queries) GetActiveBOMsByFinishedMaterial(ctx context.Context, finishedMaterialID pgtype.Int4) ([]GetActiveBOMsByFinishedMaterialRow, error) {
	rows, err := q.db.Query(ctx, getActiveBOMsByFinishedMaterial, finishedMaterialID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetActiveBOMsByFinishedMaterialRow{}
	for rows.Next() {
		var i GetActiveBOMsByFinishedMaterialRow
		if err := rows.Scan(
			&i.ID,
			&i.FinishedMaterialID,
			&i.ComponentMaterialID,
			&i.Quantity,
			&i.UnitMeasureID,
			&i.Meta,
			&i.ScrapPercentage,
			&i.FixedQuantity,
			&i.IsOptional,
			&i.Priority,
			&i.ReferenceDesignator,
			&i.Notes,
			&i.EffectiveDate,
			&i.ExpiryDate,
			&i.Version,
			&i.OperationSequence,
			&i.EstimatedCost,
			&i.ActualCost,
			&i.LeadTimeDays,
			&i.SupplierID,
			&i.AlternateComponentID,
			&i.IsActive,
			&i.Archived,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ComponentMaterialName,
			&i.ComponentMaterialCode,
			&i.ComponentUnitPrice,
			&i.UnitName,
			&i.UnitAbbreviation,
			&i.SupplierName,
			&i.AlternateComponentName,
			&i.AdjustedQuantity,
			&i.CalculatedCost,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBOMCostBreakdown = `-- name: GetBOMCostBreakdown :many
SELECT 
    b.component_material_id,
    cm.name as component_name,
    cm.code as component_code,
    b.quantity,
    b.scrap_percentage,
    (b.quantity * (1 + (b.scrap_percentage / 100))) as adjusted_quantity,
    cm.unit_price as unit_price,
    COALESCE(b.estimated_cost, b.quantity * (1 + (b.scrap_percentage / 100)) * COALESCE(cm.unit_price, 0)) as total_cost,
    mu.abbreviation as unit,
    b.is_optional,
    b.fixed_quantity
FROM bills_of_materials b
LEFT JOIN materials cm ON b.component_material_id = cm.id
LEFT JOIN measure_units mu ON b.unit_measure_id = mu.id
WHERE b.finished_material_id = $1 
    AND b.is_active = TRUE 
    AND b.archived = FALSE
ORDER BY total_cost DESC
`

type GetBOMCostBreakdownRow struct {
	ComponentMaterialID pgtype.Int4    `json:"component_material_id"`
	ComponentName       pgtype.Text    `json:"component_name"`
	ComponentCode       pgtype.Text    `json:"component_code"`
	Quantity            pgtype.Numeric `json:"quantity"`
	ScrapPercentage     pgtype.Numeric `json:"scrap_percentage"`
	AdjustedQuantity    int32          `json:"adjusted_quantity"`
	UnitPrice           pgtype.Numeric `json:"unit_price"`
	TotalCost           pgtype.Numeric `json:"total_cost"`
	Unit                pgtype.Text    `json:"unit"`
	IsOptional          pgtype.Bool    `json:"is_optional"`
	FixedQuantity       pgtype.Bool    `json:"fixed_quantity"`
}

func (q *Queries) GetBOMCostBreakdown(ctx context.Context, finishedMaterialID pgtype.Int4) ([]GetBOMCostBreakdownRow, error) {
	rows, err := q.db.Query(ctx, getBOMCostBreakdown, finishedMaterialID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetBOMCostBreakdownRow{}
	for rows.Next() {
		var i GetBOMCostBreakdownRow
		if err := rows.Scan(
			&i.ComponentMaterialID,
			&i.ComponentName,
			&i.ComponentCode,
			&i.Quantity,
			&i.ScrapPercentage,
			&i.AdjustedQuantity,
			&i.UnitPrice,
			&i.TotalCost,
			&i.Unit,
			&i.IsOptional,
			&i.FixedQuantity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBOMTotalCost = `-- name: GetBOMTotalCost :one
SELECT 
    COALESCE(SUM(
        CASE 
            WHEN b.estimated_cost IS NOT NULL THEN b.estimated_cost
            ELSE (b.quantity * (1 + (b.scrap_percentage / 100)) * COALESCE(m.unit_price, 0))
        END
    ), 0) as total_cost
FROM bills_of_materials b
LEFT JOIN materials m ON b.component_material_id = m.id
WHERE b.finished_material_id = $1 
    AND b.is_active = TRUE 
    AND b.archived = FALSE
`

func (q *Queries) GetBOMTotalCost(ctx context.Context, finishedMaterialID pgtype.Int4) (interface{}, error) {
	row := q.db.QueryRow(ctx, getBOMTotalCost, finishedMaterialID)
	var total_cost interface{}
	err := row.Scan(&total_cost)
	return total_cost, err
}

const getBOMVersions = `-- name: GetBOMVersions :many
SELECT DISTINCT version, 
    COUNT(*) as component_count,
    MIN(effective_date) as effective_date,
    MAX(expiry_date) as expiry_date,
    BOOL_AND(is_active) as all_active
FROM bills_of_materials
WHERE finished_material_id = $1
GROUP BY version
ORDER BY version DESC
`

type GetBOMVersionsRow struct {
	Version        pgtype.Text `json:"version"`
	ComponentCount int64       `json:"component_count"`
	EffectiveDate  interface{} `json:"effective_date"`
	ExpiryDate     interface{} `json:"expiry_date"`
	AllActive      bool        `json:"all_active"`
}

func (q *Queries) GetBOMVersions(ctx context.Context, finishedMaterialID pgtype.Int4) ([]GetBOMVersionsRow, error) {
	rows, err := q.db.Query(ctx, getBOMVersions, finishedMaterialID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetBOMVersionsRow{}
	for rows.Next() {
		var i GetBOMVersionsRow
		if err := rows.Scan(
			&i.Version,
			&i.ComponentCount,
			&i.EffectiveDate,
			&i.ExpiryDate,
			&i.AllActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBOMsBySupplier = `-- name: GetBOMsBySupplier :many
SELECT 
    b.id, b.finished_material_id, b.component_material_id, b.quantity, 
    b.lead_time_days, b.estimated_cost,
    fm.name as finished_material_name,
    fm.code as finished_material_code,
    cm.name as component_material_name,
    cm.code as component_material_code
FROM bills_of_materials b
LEFT JOIN materials fm ON b.finished_material_id = fm.id
LEFT JOIN materials cm ON b.component_material_id = cm.id
WHERE b.supplier_id = $1 AND b.is_active = TRUE AND b.archived = FALSE
ORDER BY b.lead_time_days DESC
`

type GetBOMsBySupplierRow struct {
	ID                    int32          `json:"id"`
	FinishedMaterialID    pgtype.Int4    `json:"finished_material_id"`
	ComponentMaterialID   pgtype.Int4    `json:"component_material_id"`
	Quantity              pgtype.Numeric `json:"quantity"`
	LeadTimeDays          pgtype.Int4    `json:"lead_time_days"`
	EstimatedCost         pgtype.Numeric `json:"estimated_cost"`
	FinishedMaterialName  pgtype.Text    `json:"finished_material_name"`
	FinishedMaterialCode  pgtype.Text    `json:"finished_material_code"`
	ComponentMaterialName pgtype.Text    `json:"component_material_name"`
	ComponentMaterialCode pgtype.Text    `json:"component_material_code"`
}

func (q *Queries) GetBOMsBySupplier(ctx context.Context, supplierID pgtype.Int4) ([]GetBOMsBySupplierRow, error) {
	rows, err := q.db.Query(ctx, getBOMsBySupplier, supplierID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetBOMsBySupplierRow{}
	for rows.Next() {
		var i GetBOMsBySupplierRow
		if err := rows.Scan(
			&i.ID,
			&i.FinishedMaterialID,
			&i.ComponentMaterialID,
			&i.Quantity,
			&i.LeadTimeDays,
			&i.EstimatedCost,
			&i.FinishedMaterialName,
			&i.FinishedMaterialCode,
			&i.ComponentMaterialName,
			&i.ComponentMaterialCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBOMsByVersion = `-- name: GetBOMsByVersion :many
SELECT 
    b.id, b.finished_material_id, b.component_material_id, b.quantity, b.unit_measure_id, b.meta, 
    b.scrap_percentage, b.fixed_quantity, b.is_optional, b.priority, b.reference_designator,
    b.notes, b.effective_date, b.expiry_date, b.version, b.operation_sequence,
    b.estimated_cost, b.actual_cost, b.lead_time_days, b.supplier_id, b.alternate_component_id,
    b.is_active, b.archived, b.created_at, b.updated_at,
    fm.name as finished_material_name,
    fm.code as finished_material_code,
    cm.name as component_material_name,
    cm.code as component_material_code,
    cm.unit_price as component_unit_price
FROM bills_of_materials b
LEFT JOIN materials fm ON b.finished_material_id = fm.id
LEFT JOIN materials cm ON b.component_material_id = cm.id
WHERE b.finished_material_id = $1 AND b.version = $2
ORDER BY b.priority, b.operation_sequence NULLS LAST
`

type GetBOMsByVersionParams struct {
	FinishedMaterialID pgtype.Int4 `json:"finished_material_id"`
	Version            pgtype.Text `json:"version"`
}

type GetBOMsByVersionRow struct {
	ID                    int32              `json:"id"`
	FinishedMaterialID    pgtype.Int4        `json:"finished_material_id"`
	ComponentMaterialID   pgtype.Int4        `json:"component_material_id"`
	Quantity              pgtype.Numeric     `json:"quantity"`
	UnitMeasureID         pgtype.Int4        `json:"unit_measure_id"`
	Meta                  []byte             `json:"meta"`
	ScrapPercentage       pgtype.Numeric     `json:"scrap_percentage"`
	FixedQuantity         pgtype.Bool        `json:"fixed_quantity"`
	IsOptional            pgtype.Bool        `json:"is_optional"`
	Priority              pgtype.Int4        `json:"priority"`
	ReferenceDesignator   pgtype.Text        `json:"reference_designator"`
	Notes                 pgtype.Text        `json:"notes"`
	EffectiveDate         pgtype.Date        `json:"effective_date"`
	ExpiryDate            pgtype.Date        `json:"expiry_date"`
	Version               pgtype.Text        `json:"version"`
	OperationSequence     pgtype.Int4        `json:"operation_sequence"`
	EstimatedCost         pgtype.Numeric     `json:"estimated_cost"`
	ActualCost            pgtype.Numeric     `json:"actual_cost"`
	LeadTimeDays          pgtype.Int4        `json:"lead_time_days"`
	SupplierID            pgtype.Int4        `json:"supplier_id"`
	AlternateComponentID  pgtype.Int4        `json:"alternate_component_id"`
	IsActive              pgtype.Bool        `json:"is_active"`
	Archived              pgtype.Bool        `json:"archived"`
	CreatedAt             pgtype.Timestamptz `json:"created_at"`
	UpdatedAt             pgtype.Timestamptz `json:"updated_at"`
	FinishedMaterialName  pgtype.Text        `json:"finished_material_name"`
	FinishedMaterialCode  pgtype.Text        `json:"finished_material_code"`
	ComponentMaterialName pgtype.Text        `json:"component_material_name"`
	ComponentMaterialCode pgtype.Text        `json:"component_material_code"`
	ComponentUnitPrice    pgtype.Numeric     `json:"component_unit_price"`
}

func (q *Queries) GetBOMsByVersion(ctx context.Context, arg GetBOMsByVersionParams) ([]GetBOMsByVersionRow, error) {
	rows, err := q.db.Query(ctx, getBOMsByVersion, arg.FinishedMaterialID, arg.Version)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetBOMsByVersionRow{}
	for rows.Next() {
		var i GetBOMsByVersionRow
		if err := rows.Scan(
			&i.ID,
			&i.FinishedMaterialID,
			&i.ComponentMaterialID,
			&i.Quantity,
			&i.UnitMeasureID,
			&i.Meta,
			&i.ScrapPercentage,
			&i.FixedQuantity,
			&i.IsOptional,
			&i.Priority,
			&i.ReferenceDesignator,
			&i.Notes,
			&i.EffectiveDate,
			&i.ExpiryDate,
			&i.Version,
			&i.OperationSequence,
			&i.EstimatedCost,
			&i.ActualCost,
			&i.LeadTimeDays,
			&i.SupplierID,
			&i.AlternateComponentID,
			&i.IsActive,
			&i.Archived,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FinishedMaterialName,
			&i.FinishedMaterialCode,
			&i.ComponentMaterialName,
			&i.ComponentMaterialCode,
			&i.ComponentUnitPrice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBillOfMaterialByID = `-- name: GetBillOfMaterialByID :one
SELECT 
    b.id, b.finished_material_id, b.component_material_id, b.quantity, b.unit_measure_id, b.meta, 
    b.scrap_percentage, b.fixed_quantity, b.is_optional, b.priority, b.reference_designator,
    b.notes, b.effective_date, b.expiry_date, b.version, b.operation_sequence,
    b.estimated_cost, b.actual_cost, b.lead_time_days, b.supplier_id, b.alternate_component_id,
    b.is_active, b.archived, b.archived_at, b.archived_by, b.created_at, b.updated_at,
    fm.name as finished_material_name,
    fm.code as finished_material_code,
    cm.name as component_material_name,
    cm.code as component_material_code,
    cm.unit_price as component_unit_price,
    mu.name as unit_name,
    mu.abbreviation as unit_abbreviation,
    s.name as supplier_name,
    alt.name as alternate_component_name,
    alt.code as alternate_component_code
FROM bills_of_materials b
LEFT JOIN materials fm ON b.finished_material_id = fm.id
LEFT JOIN materials cm ON b.component_material_id = cm.id
LEFT JOIN measure_units mu ON b.unit_measure_id = mu.id
LEFT JOIN suppliers s ON b.supplier_id = s.id
LEFT JOIN materials alt ON b.alternate_component_id = alt.id
WHERE b.id = $1
`

type GetBillOfMaterialByIDRow struct {
	ID                     int32              `json:"id"`
	FinishedMaterialID     pgtype.Int4        `json:"finished_material_id"`
	ComponentMaterialID    pgtype.Int4        `json:"component_material_id"`
	Quantity               pgtype.Numeric     `json:"quantity"`
	UnitMeasureID          pgtype.Int4        `json:"unit_measure_id"`
	Meta                   []byte             `json:"meta"`
	ScrapPercentage        pgtype.Numeric     `json:"scrap_percentage"`
	FixedQuantity          pgtype.Bool        `json:"fixed_quantity"`
	IsOptional             pgtype.Bool        `json:"is_optional"`
	Priority               pgtype.Int4        `json:"priority"`
	ReferenceDesignator    pgtype.Text        `json:"reference_designator"`
	Notes                  pgtype.Text        `json:"notes"`
	EffectiveDate          pgtype.Date        `json:"effective_date"`
	ExpiryDate             pgtype.Date        `json:"expiry_date"`
	Version                pgtype.Text        `json:"version"`
	OperationSequence      pgtype.Int4        `json:"operation_sequence"`
	EstimatedCost          pgtype.Numeric     `json:"estimated_cost"`
	ActualCost             pgtype.Numeric     `json:"actual_cost"`
	LeadTimeDays           pgtype.Int4        `json:"lead_time_days"`
	SupplierID             pgtype.Int4        `json:"supplier_id"`
	AlternateComponentID   pgtype.Int4        `json:"alternate_component_id"`
	IsActive               pgtype.Bool        `json:"is_active"`
	Archived               pgtype.Bool        `json:"archived"`
	ArchivedAt             pgtype.Timestamptz `json:"archived_at"`
	ArchivedBy             pgtype.Int4        `json:"archived_by"`
	CreatedAt              pgtype.Timestamptz `json:"created_at"`
	UpdatedAt              pgtype.Timestamptz `json:"updated_at"`
	FinishedMaterialName   pgtype.Text        `json:"finished_material_name"`
	FinishedMaterialCode   pgtype.Text        `json:"finished_material_code"`
	ComponentMaterialName  pgtype.Text        `json:"component_material_name"`
	ComponentMaterialCode  pgtype.Text        `json:"component_material_code"`
	ComponentUnitPrice     pgtype.Numeric     `json:"component_unit_price"`
	UnitName               pgtype.Text        `json:"unit_name"`
	UnitAbbreviation       pgtype.Text        `json:"unit_abbreviation"`
	SupplierName           pgtype.Text        `json:"supplier_name"`
	AlternateComponentName pgtype.Text        `json:"alternate_component_name"`
	AlternateComponentCode pgtype.Text        `json:"alternate_component_code"`
}

func (q *Queries) GetBillOfMaterialByID(ctx context.Context, id int32) (GetBillOfMaterialByIDRow, error) {
	row := q.db.QueryRow(ctx, getBillOfMaterialByID, id)
	var i GetBillOfMaterialByIDRow
	err := row.Scan(
		&i.ID,
		&i.FinishedMaterialID,
		&i.ComponentMaterialID,
		&i.Quantity,
		&i.UnitMeasureID,
		&i.Meta,
		&i.ScrapPercentage,
		&i.FixedQuantity,
		&i.IsOptional,
		&i.Priority,
		&i.ReferenceDesignator,
		&i.Notes,
		&i.EffectiveDate,
		&i.ExpiryDate,
		&i.Version,
		&i.OperationSequence,
		&i.EstimatedCost,
		&i.ActualCost,
		&i.LeadTimeDays,
		&i.SupplierID,
		&i.AlternateComponentID,
		&i.IsActive,
		&i.Archived,
		&i.ArchivedAt,
		&i.ArchivedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FinishedMaterialName,
		&i.FinishedMaterialCode,
		&i.ComponentMaterialName,
		&i.ComponentMaterialCode,
		&i.ComponentUnitPrice,
		&i.UnitName,
		&i.UnitAbbreviation,
		&i.SupplierName,
		&i.AlternateComponentName,
		&i.AlternateComponentCode,
	)
	return i, err
}

const getBillOfMaterialsByComponent = `-- name: GetBillOfMaterialsByComponent :many
SELECT 
    b.id, b.finished_material_id, b.component_material_id, b.quantity, b.unit_measure_id, b.meta, 
    b.created_at, b.updated_at,
    fm.name as finished_material_name,
    fm.code as finished_material_code,
    fm.sku as finished_material_sku,
    mu.name as unit_name,
    mu.abbreviation as unit_abbreviation
FROM bills_of_materials b
LEFT JOIN materials fm ON b.finished_material_id = fm.id
LEFT JOIN measure_units mu ON b.unit_measure_id = mu.id
WHERE b.component_material_id = $1
ORDER BY b.id
`

type GetBillOfMaterialsByComponentRow struct {
	ID                   int32              `json:"id"`
	FinishedMaterialID   pgtype.Int4        `json:"finished_material_id"`
	ComponentMaterialID  pgtype.Int4        `json:"component_material_id"`
	Quantity             pgtype.Numeric     `json:"quantity"`
	UnitMeasureID        pgtype.Int4        `json:"unit_measure_id"`
	Meta                 []byte             `json:"meta"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
	FinishedMaterialName pgtype.Text        `json:"finished_material_name"`
	FinishedMaterialCode pgtype.Text        `json:"finished_material_code"`
	FinishedMaterialSku  pgtype.Text        `json:"finished_material_sku"`
	UnitName             pgtype.Text        `json:"unit_name"`
	UnitAbbreviation     pgtype.Text        `json:"unit_abbreviation"`
}

func (q *Queries) GetBillOfMaterialsByComponent(ctx context.Context, componentMaterialID pgtype.Int4) ([]GetBillOfMaterialsByComponentRow, error) {
	rows, err := q.db.Query(ctx, getBillOfMaterialsByComponent, componentMaterialID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetBillOfMaterialsByComponentRow{}
	for rows.Next() {
		var i GetBillOfMaterialsByComponentRow
		if err := rows.Scan(
			&i.ID,
			&i.FinishedMaterialID,
			&i.ComponentMaterialID,
			&i.Quantity,
			&i.UnitMeasureID,
			&i.Meta,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FinishedMaterialName,
			&i.FinishedMaterialCode,
			&i.FinishedMaterialSku,
			&i.UnitName,
			&i.UnitAbbreviation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBillOfMaterialsByFinishedMaterial = `-- name: GetBillOfMaterialsByFinishedMaterial :many
SELECT 
    b.id, b.finished_material_id, b.component_material_id, b.quantity, b.unit_measure_id, b.meta, 
    b.scrap_percentage, b.fixed_quantity, b.is_optional, b.priority, b.reference_designator,
    b.notes, b.effective_date, b.expiry_date, b.version, b.operation_sequence,
    b.estimated_cost, b.actual_cost, b.lead_time_days, b.supplier_id, b.alternate_component_id,
    b.is_active, b.archived, b.created_at, b.updated_at,
    cm.name as component_material_name,
    cm.code as component_material_code,
    cm.sku as component_material_sku,
    cm.unit_price as component_unit_price,
    mu.name as unit_name,
    mu.abbreviation as unit_abbreviation,
    s.name as supplier_name,
    alt.name as alternate_component_name,
    alt.code as alternate_component_code,
    (b.quantity * (1 + (b.scrap_percentage / 100))) as adjusted_quantity
FROM bills_of_materials b
LEFT JOIN materials cm ON b.component_material_id = cm.id
LEFT JOIN measure_units mu ON b.unit_measure_id = mu.id
LEFT JOIN suppliers s ON b.supplier_id = s.id
LEFT JOIN materials alt ON b.alternate_component_id = alt.id
WHERE b.finished_material_id = $1 AND b.archived = FALSE
ORDER BY b.priority, b.operation_sequence NULLS LAST, b.id
`

type GetBillOfMaterialsByFinishedMaterialRow struct {
	ID                     int32              `json:"id"`
	FinishedMaterialID     pgtype.Int4        `json:"finished_material_id"`
	ComponentMaterialID    pgtype.Int4        `json:"component_material_id"`
	Quantity               pgtype.Numeric     `json:"quantity"`
	UnitMeasureID          pgtype.Int4        `json:"unit_measure_id"`
	Meta                   []byte             `json:"meta"`
	ScrapPercentage        pgtype.Numeric     `json:"scrap_percentage"`
	FixedQuantity          pgtype.Bool        `json:"fixed_quantity"`
	IsOptional             pgtype.Bool        `json:"is_optional"`
	Priority               pgtype.Int4        `json:"priority"`
	ReferenceDesignator    pgtype.Text        `json:"reference_designator"`
	Notes                  pgtype.Text        `json:"notes"`
	EffectiveDate          pgtype.Date        `json:"effective_date"`
	ExpiryDate             pgtype.Date        `json:"expiry_date"`
	Version                pgtype.Text        `json:"version"`
	OperationSequence      pgtype.Int4        `json:"operation_sequence"`
	EstimatedCost          pgtype.Numeric     `json:"estimated_cost"`
	ActualCost             pgtype.Numeric     `json:"actual_cost"`
	LeadTimeDays           pgtype.Int4        `json:"lead_time_days"`
	SupplierID             pgtype.Int4        `json:"supplier_id"`
	AlternateComponentID   pgtype.Int4        `json:"alternate_component_id"`
	IsActive               pgtype.Bool        `json:"is_active"`
	Archived               pgtype.Bool        `json:"archived"`
	CreatedAt              pgtype.Timestamptz `json:"created_at"`
	UpdatedAt              pgtype.Timestamptz `json:"updated_at"`
	ComponentMaterialName  pgtype.Text        `json:"component_material_name"`
	ComponentMaterialCode  pgtype.Text        `json:"component_material_code"`
	ComponentMaterialSku   pgtype.Text        `json:"component_material_sku"`
	ComponentUnitPrice     pgtype.Numeric     `json:"component_unit_price"`
	UnitName               pgtype.Text        `json:"unit_name"`
	UnitAbbreviation       pgtype.Text        `json:"unit_abbreviation"`
	SupplierName           pgtype.Text        `json:"supplier_name"`
	AlternateComponentName pgtype.Text        `json:"alternate_component_name"`
	AlternateComponentCode pgtype.Text        `json:"alternate_component_code"`
	AdjustedQuantity       int32              `json:"adjusted_quantity"`
}

func (q *Queries) GetBillOfMaterialsByFinishedMaterial(ctx context.Context, finishedMaterialID pgtype.Int4) ([]GetBillOfMaterialsByFinishedMaterialRow, error) {
	rows, err := q.db.Query(ctx, getBillOfMaterialsByFinishedMaterial, finishedMaterialID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetBillOfMaterialsByFinishedMaterialRow{}
	for rows.Next() {
		var i GetBillOfMaterialsByFinishedMaterialRow
		if err := rows.Scan(
			&i.ID,
			&i.FinishedMaterialID,
			&i.ComponentMaterialID,
			&i.Quantity,
			&i.UnitMeasureID,
			&i.Meta,
			&i.ScrapPercentage,
			&i.FixedQuantity,
			&i.IsOptional,
			&i.Priority,
			&i.ReferenceDesignator,
			&i.Notes,
			&i.EffectiveDate,
			&i.ExpiryDate,
			&i.Version,
			&i.OperationSequence,
			&i.EstimatedCost,
			&i.ActualCost,
			&i.LeadTimeDays,
			&i.SupplierID,
			&i.AlternateComponentID,
			&i.IsActive,
			&i.Archived,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ComponentMaterialName,
			&i.ComponentMaterialCode,
			&i.ComponentMaterialSku,
			&i.ComponentUnitPrice,
			&i.UnitName,
			&i.UnitAbbreviation,
			&i.SupplierName,
			&i.AlternateComponentName,
			&i.AlternateComponentCode,
			&i.AdjustedQuantity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOptionalComponents = `-- name: GetOptionalComponents :many
SELECT 
    b.id, b.finished_material_id, b.component_material_id, b.quantity,
    b.is_optional, b.priority,
    cm.name as component_name,
    cm.code as component_code,
    mu.abbreviation as unit
FROM bills_of_materials b
LEFT JOIN materials cm ON b.component_material_id = cm.id
LEFT JOIN measure_units mu ON b.unit_measure_id = mu.id
WHERE b.finished_material_id = $1 
    AND b.is_optional = TRUE 
    AND b.is_active = TRUE 
    AND b.archived = FALSE
ORDER BY b.priority
`

type GetOptionalComponentsRow struct {
	ID                  int32          `json:"id"`
	FinishedMaterialID  pgtype.Int4    `json:"finished_material_id"`
	ComponentMaterialID pgtype.Int4    `json:"component_material_id"`
	Quantity            pgtype.Numeric `json:"quantity"`
	IsOptional          pgtype.Bool    `json:"is_optional"`
	Priority            pgtype.Int4    `json:"priority"`
	ComponentName       pgtype.Text    `json:"component_name"`
	ComponentCode       pgtype.Text    `json:"component_code"`
	Unit                pgtype.Text    `json:"unit"`
}

func (q *Queries) GetOptionalComponents(ctx context.Context, finishedMaterialID pgtype.Int4) ([]GetOptionalComponentsRow, error) {
	rows, err := q.db.Query(ctx, getOptionalComponents, finishedMaterialID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOptionalComponentsRow{}
	for rows.Next() {
		var i GetOptionalComponentsRow
		if err := rows.Scan(
			&i.ID,
			&i.FinishedMaterialID,
			&i.ComponentMaterialID,
			&i.Quantity,
			&i.IsOptional,
			&i.Priority,
			&i.ComponentName,
			&i.ComponentCode,
			&i.Unit,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBillsOfMaterials = `-- name: ListBillsOfMaterials :many
SELECT 
    b.id, b.finished_material_id, b.component_material_id, b.quantity, b.unit_measure_id, b.meta, 
    b.scrap_percentage, b.fixed_quantity, b.is_optional, b.priority, b.reference_designator,
    b.notes, b.effective_date, b.expiry_date, b.version, b.operation_sequence,
    b.estimated_cost, b.actual_cost, b.lead_time_days, b.supplier_id, b.alternate_component_id,
    b.is_active, b.archived, b.created_at, b.updated_at,
    fm.name as finished_material_name,
    fm.code as finished_material_code,
    cm.name as component_material_name,
    cm.code as component_material_code,
    cm.unit_price as component_unit_price,
    mu.name as unit_name,
    mu.abbreviation as unit_abbreviation,
    s.name as supplier_name,
    (b.quantity * (1 + (b.scrap_percentage / 100))) as adjusted_quantity
FROM bills_of_materials b
LEFT JOIN materials fm ON b.finished_material_id = fm.id
LEFT JOIN materials cm ON b.component_material_id = cm.id
LEFT JOIN measure_units mu ON b.unit_measure_id = mu.id
LEFT JOIN suppliers s ON b.supplier_id = s.id
WHERE b.archived = FALSE
ORDER BY b.created_at DESC
LIMIT $1 OFFSET $2
`

type ListBillsOfMaterialsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListBillsOfMaterialsRow struct {
	ID                    int32              `json:"id"`
	FinishedMaterialID    pgtype.Int4        `json:"finished_material_id"`
	ComponentMaterialID   pgtype.Int4        `json:"component_material_id"`
	Quantity              pgtype.Numeric     `json:"quantity"`
	UnitMeasureID         pgtype.Int4        `json:"unit_measure_id"`
	Meta                  []byte             `json:"meta"`
	ScrapPercentage       pgtype.Numeric     `json:"scrap_percentage"`
	FixedQuantity         pgtype.Bool        `json:"fixed_quantity"`
	IsOptional            pgtype.Bool        `json:"is_optional"`
	Priority              pgtype.Int4        `json:"priority"`
	ReferenceDesignator   pgtype.Text        `json:"reference_designator"`
	Notes                 pgtype.Text        `json:"notes"`
	EffectiveDate         pgtype.Date        `json:"effective_date"`
	ExpiryDate            pgtype.Date        `json:"expiry_date"`
	Version               pgtype.Text        `json:"version"`
	OperationSequence     pgtype.Int4        `json:"operation_sequence"`
	EstimatedCost         pgtype.Numeric     `json:"estimated_cost"`
	ActualCost            pgtype.Numeric     `json:"actual_cost"`
	LeadTimeDays          pgtype.Int4        `json:"lead_time_days"`
	SupplierID            pgtype.Int4        `json:"supplier_id"`
	AlternateComponentID  pgtype.Int4        `json:"alternate_component_id"`
	IsActive              pgtype.Bool        `json:"is_active"`
	Archived              pgtype.Bool        `json:"archived"`
	CreatedAt             pgtype.Timestamptz `json:"created_at"`
	UpdatedAt             pgtype.Timestamptz `json:"updated_at"`
	FinishedMaterialName  pgtype.Text        `json:"finished_material_name"`
	FinishedMaterialCode  pgtype.Text        `json:"finished_material_code"`
	ComponentMaterialName pgtype.Text        `json:"component_material_name"`
	ComponentMaterialCode pgtype.Text        `json:"component_material_code"`
	ComponentUnitPrice    pgtype.Numeric     `json:"component_unit_price"`
	UnitName              pgtype.Text        `json:"unit_name"`
	UnitAbbreviation      pgtype.Text        `json:"unit_abbreviation"`
	SupplierName          pgtype.Text        `json:"supplier_name"`
	AdjustedQuantity      int32              `json:"adjusted_quantity"`
}

func (q *Queries) ListBillsOfMaterials(ctx context.Context, arg ListBillsOfMaterialsParams) ([]ListBillsOfMaterialsRow, error) {
	rows, err := q.db.Query(ctx, listBillsOfMaterials, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListBillsOfMaterialsRow{}
	for rows.Next() {
		var i ListBillsOfMaterialsRow
		if err := rows.Scan(
			&i.ID,
			&i.FinishedMaterialID,
			&i.ComponentMaterialID,
			&i.Quantity,
			&i.UnitMeasureID,
			&i.Meta,
			&i.ScrapPercentage,
			&i.FixedQuantity,
			&i.IsOptional,
			&i.Priority,
			&i.ReferenceDesignator,
			&i.Notes,
			&i.EffectiveDate,
			&i.ExpiryDate,
			&i.Version,
			&i.OperationSequence,
			&i.EstimatedCost,
			&i.ActualCost,
			&i.LeadTimeDays,
			&i.SupplierID,
			&i.AlternateComponentID,
			&i.IsActive,
			&i.Archived,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FinishedMaterialName,
			&i.FinishedMaterialCode,
			&i.ComponentMaterialName,
			&i.ComponentMaterialCode,
			&i.ComponentUnitPrice,
			&i.UnitName,
			&i.UnitAbbreviation,
			&i.SupplierName,
			&i.AdjustedQuantity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchBillsOfMaterials = `-- name: SearchBillsOfMaterials :many
SELECT 
    b.id, b.finished_material_id, b.component_material_id, b.quantity, b.unit_measure_id, b.meta, 
    b.scrap_percentage, b.fixed_quantity, b.is_optional, b.priority, b.reference_designator,
    b.notes, b.effective_date, b.expiry_date, b.version, b.operation_sequence,
    b.estimated_cost, b.actual_cost, b.lead_time_days, b.supplier_id, b.alternate_component_id,
    b.is_active, b.archived, b.created_at, b.updated_at,
    fm.name as finished_material_name,
    fm.code as finished_material_code,
    cm.name as component_material_name,
    cm.code as component_material_code,
    cm.unit_price as component_unit_price,
    mu.name as unit_name,
    mu.abbreviation as unit_abbreviation,
    s.name as supplier_name,
    (b.quantity * (1 + (b.scrap_percentage / 100))) as adjusted_quantity
FROM bills_of_materials b
LEFT JOIN materials fm ON b.finished_material_id = fm.id
LEFT JOIN materials cm ON b.component_material_id = cm.id
LEFT JOIN measure_units mu ON b.unit_measure_id = mu.id
LEFT JOIN suppliers s ON b.supplier_id = s.id
WHERE b.archived = FALSE
    AND ($3::TEXT IS NULL OR 
     fm.name ILIKE '%' || $3 || '%' OR 
     fm.code ILIKE '%' || $3 || '%' OR
     cm.name ILIKE '%' || $3 || '%' OR
     cm.code ILIKE '%' || $3 || '%' OR
     b.version ILIKE '%' || $3 || '%')
ORDER BY b.created_at DESC
LIMIT $1 OFFSET $2
`

type SearchBillsOfMaterialsParams struct {
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
	Query  pgtype.Text `json:"query"`
}

type SearchBillsOfMaterialsRow struct {
	ID                    int32              `json:"id"`
	FinishedMaterialID    pgtype.Int4        `json:"finished_material_id"`
	ComponentMaterialID   pgtype.Int4        `json:"component_material_id"`
	Quantity              pgtype.Numeric     `json:"quantity"`
	UnitMeasureID         pgtype.Int4        `json:"unit_measure_id"`
	Meta                  []byte             `json:"meta"`
	ScrapPercentage       pgtype.Numeric     `json:"scrap_percentage"`
	FixedQuantity         pgtype.Bool        `json:"fixed_quantity"`
	IsOptional            pgtype.Bool        `json:"is_optional"`
	Priority              pgtype.Int4        `json:"priority"`
	ReferenceDesignator   pgtype.Text        `json:"reference_designator"`
	Notes                 pgtype.Text        `json:"notes"`
	EffectiveDate         pgtype.Date        `json:"effective_date"`
	ExpiryDate            pgtype.Date        `json:"expiry_date"`
	Version               pgtype.Text        `json:"version"`
	OperationSequence     pgtype.Int4        `json:"operation_sequence"`
	EstimatedCost         pgtype.Numeric     `json:"estimated_cost"`
	ActualCost            pgtype.Numeric     `json:"actual_cost"`
	LeadTimeDays          pgtype.Int4        `json:"lead_time_days"`
	SupplierID            pgtype.Int4        `json:"supplier_id"`
	AlternateComponentID  pgtype.Int4        `json:"alternate_component_id"`
	IsActive              pgtype.Bool        `json:"is_active"`
	Archived              pgtype.Bool        `json:"archived"`
	CreatedAt             pgtype.Timestamptz `json:"created_at"`
	UpdatedAt             pgtype.Timestamptz `json:"updated_at"`
	FinishedMaterialName  pgtype.Text        `json:"finished_material_name"`
	FinishedMaterialCode  pgtype.Text        `json:"finished_material_code"`
	ComponentMaterialName pgtype.Text        `json:"component_material_name"`
	ComponentMaterialCode pgtype.Text        `json:"component_material_code"`
	ComponentUnitPrice    pgtype.Numeric     `json:"component_unit_price"`
	UnitName              pgtype.Text        `json:"unit_name"`
	UnitAbbreviation      pgtype.Text        `json:"unit_abbreviation"`
	SupplierName          pgtype.Text        `json:"supplier_name"`
	AdjustedQuantity      int32              `json:"adjusted_quantity"`
}

func (q *Queries) SearchBillsOfMaterials(ctx context.Context, arg SearchBillsOfMaterialsParams) ([]SearchBillsOfMaterialsRow, error) {
	rows, err := q.db.Query(ctx, searchBillsOfMaterials, arg.Limit, arg.Offset, arg.Query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchBillsOfMaterialsRow{}
	for rows.Next() {
		var i SearchBillsOfMaterialsRow
		if err := rows.Scan(
			&i.ID,
			&i.FinishedMaterialID,
			&i.ComponentMaterialID,
			&i.Quantity,
			&i.UnitMeasureID,
			&i.Meta,
			&i.ScrapPercentage,
			&i.FixedQuantity,
			&i.IsOptional,
			&i.Priority,
			&i.ReferenceDesignator,
			&i.Notes,
			&i.EffectiveDate,
			&i.ExpiryDate,
			&i.Version,
			&i.OperationSequence,
			&i.EstimatedCost,
			&i.ActualCost,
			&i.LeadTimeDays,
			&i.SupplierID,
			&i.AlternateComponentID,
			&i.IsActive,
			&i.Archived,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FinishedMaterialName,
			&i.FinishedMaterialCode,
			&i.ComponentMaterialName,
			&i.ComponentMaterialCode,
			&i.ComponentUnitPrice,
			&i.UnitName,
			&i.UnitAbbreviation,
			&i.SupplierName,
			&i.AdjustedQuantity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const unarchiveBOM = `-- name: UnarchiveBOM :one
UPDATE bills_of_materials
SET archived = FALSE, archived_at = NULL, archived_by = NULL, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING 
    id, finished_material_id, component_material_id, quantity, unit_measure_id, meta, 
    scrap_percentage, fixed_quantity, is_optional, priority, reference_designator, 
    notes, effective_date, expiry_date, version, operation_sequence, 
    estimated_cost, actual_cost, lead_time_days, supplier_id, alternate_component_id, 
    is_active, archived, archived_at, archived_by, created_at, updated_at
`

type UnarchiveBOMRow struct {
	ID                   int32              `json:"id"`
	FinishedMaterialID   pgtype.Int4        `json:"finished_material_id"`
	ComponentMaterialID  pgtype.Int4        `json:"component_material_id"`
	Quantity             pgtype.Numeric     `json:"quantity"`
	UnitMeasureID        pgtype.Int4        `json:"unit_measure_id"`
	Meta                 []byte             `json:"meta"`
	ScrapPercentage      pgtype.Numeric     `json:"scrap_percentage"`
	FixedQuantity        pgtype.Bool        `json:"fixed_quantity"`
	IsOptional           pgtype.Bool        `json:"is_optional"`
	Priority             pgtype.Int4        `json:"priority"`
	ReferenceDesignator  pgtype.Text        `json:"reference_designator"`
	Notes                pgtype.Text        `json:"notes"`
	EffectiveDate        pgtype.Date        `json:"effective_date"`
	ExpiryDate           pgtype.Date        `json:"expiry_date"`
	Version              pgtype.Text        `json:"version"`
	OperationSequence    pgtype.Int4        `json:"operation_sequence"`
	EstimatedCost        pgtype.Numeric     `json:"estimated_cost"`
	ActualCost           pgtype.Numeric     `json:"actual_cost"`
	LeadTimeDays         pgtype.Int4        `json:"lead_time_days"`
	SupplierID           pgtype.Int4        `json:"supplier_id"`
	AlternateComponentID pgtype.Int4        `json:"alternate_component_id"`
	IsActive             pgtype.Bool        `json:"is_active"`
	Archived             pgtype.Bool        `json:"archived"`
	ArchivedAt           pgtype.Timestamptz `json:"archived_at"`
	ArchivedBy           pgtype.Int4        `json:"archived_by"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UnarchiveBOM(ctx context.Context, id int32) (UnarchiveBOMRow, error) {
	row := q.db.QueryRow(ctx, unarchiveBOM, id)
	var i UnarchiveBOMRow
	err := row.Scan(
		&i.ID,
		&i.FinishedMaterialID,
		&i.ComponentMaterialID,
		&i.Quantity,
		&i.UnitMeasureID,
		&i.Meta,
		&i.ScrapPercentage,
		&i.FixedQuantity,
		&i.IsOptional,
		&i.Priority,
		&i.ReferenceDesignator,
		&i.Notes,
		&i.EffectiveDate,
		&i.ExpiryDate,
		&i.Version,
		&i.OperationSequence,
		&i.EstimatedCost,
		&i.ActualCost,
		&i.LeadTimeDays,
		&i.SupplierID,
		&i.AlternateComponentID,
		&i.IsActive,
		&i.Archived,
		&i.ArchivedAt,
		&i.ArchivedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateBOMActualCost = `-- name: UpdateBOMActualCost :exec
UPDATE bills_of_materials
SET actual_cost = $2, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

type UpdateBOMActualCostParams struct {
	ID         int32          `json:"id"`
	ActualCost pgtype.Numeric `json:"actual_cost"`
}

func (q *Queries) UpdateBOMActualCost(ctx context.Context, arg UpdateBOMActualCostParams) error {
	_, err := q.db.Exec(ctx, updateBOMActualCost, arg.ID, arg.ActualCost)
	return err
}

const updateBillOfMaterial = `-- name: UpdateBillOfMaterial :one
UPDATE bills_of_materials
SET
    finished_material_id = COALESCE($2, finished_material_id),
    component_material_id = COALESCE($3, component_material_id),
    quantity = COALESCE($4, quantity),
    unit_measure_id = COALESCE($5, unit_measure_id),
    meta = COALESCE($6, meta),
    scrap_percentage = COALESCE($7, scrap_percentage),
    fixed_quantity = COALESCE($8, fixed_quantity),
    is_optional = COALESCE($9, is_optional),
    priority = COALESCE($10, priority),
    reference_designator = COALESCE($11, reference_designator),
    notes = COALESCE($12, notes),
    effective_date = COALESCE($13, effective_date),
    expiry_date = COALESCE($14, expiry_date),
    version = COALESCE($15, version),
    operation_sequence = COALESCE($16, operation_sequence),
    estimated_cost = COALESCE($17, estimated_cost),
    actual_cost = COALESCE($18, actual_cost),
    lead_time_days = COALESCE($19, lead_time_days),
    supplier_id = COALESCE($20, supplier_id),
    alternate_component_id = COALESCE($21, alternate_component_id),
    is_active = COALESCE($22, is_active),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING 
    id, finished_material_id, component_material_id, quantity, unit_measure_id, meta, 
    scrap_percentage, fixed_quantity, is_optional, priority, reference_designator, 
    notes, effective_date, expiry_date, version, operation_sequence, 
    estimated_cost, actual_cost, lead_time_days, supplier_id, alternate_component_id, 
    is_active, archived, archived_at, archived_by, created_at, updated_at
`

type UpdateBillOfMaterialParams struct {
	ID                   int32          `json:"id"`
	FinishedMaterialID   pgtype.Int4    `json:"finished_material_id"`
	ComponentMaterialID  pgtype.Int4    `json:"component_material_id"`
	Quantity             pgtype.Numeric `json:"quantity"`
	UnitMeasureID        pgtype.Int4    `json:"unit_measure_id"`
	Meta                 []byte         `json:"meta"`
	ScrapPercentage      pgtype.Numeric `json:"scrap_percentage"`
	FixedQuantity        pgtype.Bool    `json:"fixed_quantity"`
	IsOptional           pgtype.Bool    `json:"is_optional"`
	Priority             pgtype.Int4    `json:"priority"`
	ReferenceDesignator  pgtype.Text    `json:"reference_designator"`
	Notes                pgtype.Text    `json:"notes"`
	EffectiveDate        pgtype.Date    `json:"effective_date"`
	ExpiryDate           pgtype.Date    `json:"expiry_date"`
	Version              pgtype.Text    `json:"version"`
	OperationSequence    pgtype.Int4    `json:"operation_sequence"`
	EstimatedCost        pgtype.Numeric `json:"estimated_cost"`
	ActualCost           pgtype.Numeric `json:"actual_cost"`
	LeadTimeDays         pgtype.Int4    `json:"lead_time_days"`
	SupplierID           pgtype.Int4    `json:"supplier_id"`
	AlternateComponentID pgtype.Int4    `json:"alternate_component_id"`
	IsActive             pgtype.Bool    `json:"is_active"`
}

type UpdateBillOfMaterialRow struct {
	ID                   int32              `json:"id"`
	FinishedMaterialID   pgtype.Int4        `json:"finished_material_id"`
	ComponentMaterialID  pgtype.Int4        `json:"component_material_id"`
	Quantity             pgtype.Numeric     `json:"quantity"`
	UnitMeasureID        pgtype.Int4        `json:"unit_measure_id"`
	Meta                 []byte             `json:"meta"`
	ScrapPercentage      pgtype.Numeric     `json:"scrap_percentage"`
	FixedQuantity        pgtype.Bool        `json:"fixed_quantity"`
	IsOptional           pgtype.Bool        `json:"is_optional"`
	Priority             pgtype.Int4        `json:"priority"`
	ReferenceDesignator  pgtype.Text        `json:"reference_designator"`
	Notes                pgtype.Text        `json:"notes"`
	EffectiveDate        pgtype.Date        `json:"effective_date"`
	ExpiryDate           pgtype.Date        `json:"expiry_date"`
	Version              pgtype.Text        `json:"version"`
	OperationSequence    pgtype.Int4        `json:"operation_sequence"`
	EstimatedCost        pgtype.Numeric     `json:"estimated_cost"`
	ActualCost           pgtype.Numeric     `json:"actual_cost"`
	LeadTimeDays         pgtype.Int4        `json:"lead_time_days"`
	SupplierID           pgtype.Int4        `json:"supplier_id"`
	AlternateComponentID pgtype.Int4        `json:"alternate_component_id"`
	IsActive             pgtype.Bool        `json:"is_active"`
	Archived             pgtype.Bool        `json:"archived"`
	ArchivedAt           pgtype.Timestamptz `json:"archived_at"`
	ArchivedBy           pgtype.Int4        `json:"archived_by"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpdateBillOfMaterial(ctx context.Context, arg UpdateBillOfMaterialParams) (UpdateBillOfMaterialRow, error) {
	row := q.db.QueryRow(ctx, updateBillOfMaterial,
		arg.ID,
		arg.FinishedMaterialID,
		arg.ComponentMaterialID,
		arg.Quantity,
		arg.UnitMeasureID,
		arg.Meta,
		arg.ScrapPercentage,
		arg.FixedQuantity,
		arg.IsOptional,
		arg.Priority,
		arg.ReferenceDesignator,
		arg.Notes,
		arg.EffectiveDate,
		arg.ExpiryDate,
		arg.Version,
		arg.OperationSequence,
		arg.EstimatedCost,
		arg.ActualCost,
		arg.LeadTimeDays,
		arg.SupplierID,
		arg.AlternateComponentID,
		arg.IsActive,
	)
	var i UpdateBillOfMaterialRow
	err := row.Scan(
		&i.ID,
		&i.FinishedMaterialID,
		&i.ComponentMaterialID,
		&i.Quantity,
		&i.UnitMeasureID,
		&i.Meta,
		&i.ScrapPercentage,
		&i.FixedQuantity,
		&i.IsOptional,
		&i.Priority,
		&i.ReferenceDesignator,
		&i.Notes,
		&i.EffectiveDate,
		&i.ExpiryDate,
		&i.Version,
		&i.OperationSequence,
		&i.EstimatedCost,
		&i.ActualCost,
		&i.LeadTimeDays,
		&i.SupplierID,
		&i.AlternateComponentID,
		&i.IsActive,
		&i.Archived,
		&i.ArchivedAt,
		&i.ArchivedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
