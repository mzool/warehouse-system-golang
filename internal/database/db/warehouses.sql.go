// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: warehouses.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createWarehouse = `-- name: CreateWarehouse :one
INSERT INTO warehouses (name, code, location, description, valuation, parent_warehouse, capacity, meta)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, name, code, location, description, valuation, parent_warehouse, capacity, meta, created_at, updated_at
`

type CreateWarehouseParams struct {
	Name            string          `json:"name"`
	Code            string          `json:"code"`
	Location        pgtype.Text     `json:"location"`
	Description     pgtype.Text     `json:"description"`
	Valuation       ValuationMethod `json:"valuation"`
	ParentWarehouse pgtype.Int4     `json:"parent_warehouse"`
	Capacity        pgtype.Numeric  `json:"capacity"`
	Meta            []byte          `json:"meta"`
}

func (q *Queries) CreateWarehouse(ctx context.Context, arg CreateWarehouseParams) (Warehouse, error) {
	row := q.db.QueryRow(ctx, createWarehouse,
		arg.Name,
		arg.Code,
		arg.Location,
		arg.Description,
		arg.Valuation,
		arg.ParentWarehouse,
		arg.Capacity,
		arg.Meta,
	)
	var i Warehouse
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Code,
		&i.Location,
		&i.Description,
		&i.Valuation,
		&i.ParentWarehouse,
		&i.Capacity,
		&i.Meta,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteWarehouse = `-- name: DeleteWarehouse :exec
DELETE FROM warehouses
WHERE id = $1
`

func (q *Queries) DeleteWarehouse(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteWarehouse, id)
	return err
}

const getWarehouseByCode = `-- name: GetWarehouseByCode :one
SELECT id, name, code, location, description, valuation, parent_warehouse, capacity, meta, created_at, updated_at
FROM warehouses
WHERE code = $1
`

func (q *Queries) GetWarehouseByCode(ctx context.Context, code string) (Warehouse, error) {
	row := q.db.QueryRow(ctx, getWarehouseByCode, code)
	var i Warehouse
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Code,
		&i.Location,
		&i.Description,
		&i.Valuation,
		&i.ParentWarehouse,
		&i.Capacity,
		&i.Meta,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWarehouseByID = `-- name: GetWarehouseByID :one
SELECT id, name, code, location, description, valuation, parent_warehouse, capacity, meta, created_at, updated_at
FROM warehouses
WHERE id = $1
`

func (q *Queries) GetWarehouseByID(ctx context.Context, id int32) (Warehouse, error) {
	row := q.db.QueryRow(ctx, getWarehouseByID, id)
	var i Warehouse
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Code,
		&i.Location,
		&i.Description,
		&i.Valuation,
		&i.ParentWarehouse,
		&i.Capacity,
		&i.Meta,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWarehouseByName = `-- name: GetWarehouseByName :one
SELECT id, name, code, location, description, valuation, parent_warehouse, capacity, meta, created_at, updated_at
FROM warehouses
WHERE name = $1
`

func (q *Queries) GetWarehouseByName(ctx context.Context, name string) (Warehouse, error) {
	row := q.db.QueryRow(ctx, getWarehouseByName, name)
	var i Warehouse
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Code,
		&i.Location,
		&i.Description,
		&i.Valuation,
		&i.ParentWarehouse,
		&i.Capacity,
		&i.Meta,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listWarehouses = `-- name: ListWarehouses :many
SELECT id, name, code, location, description, valuation, parent_warehouse, capacity, meta, created_at, updated_at
FROM warehouses
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListWarehousesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListWarehouses(ctx context.Context, arg ListWarehousesParams) ([]Warehouse, error) {
	rows, err := q.db.Query(ctx, listWarehouses, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Warehouse{}
	for rows.Next() {
		var i Warehouse
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Code,
			&i.Location,
			&i.Description,
			&i.Valuation,
			&i.ParentWarehouse,
			&i.Capacity,
			&i.Meta,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateWarehouse = `-- name: UpdateWarehouse :one
UPDATE warehouses
SET
    name = COALESCE(NULLIF($2, ''), name),
    code = COALESCE(NULLIF($3, ''), code),
    location = COALESCE($4, location),
    description = COALESCE($5, description),
    valuation = COALESCE($6, valuation),
    parent_warehouse = COALESCE($7, parent_warehouse),
    capacity = COALESCE($8, capacity),
    meta = COALESCE($9, meta),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, name, code, location, description, valuation, parent_warehouse, capacity, meta, created_at, updated_at
`

type UpdateWarehouseParams struct {
	ID              int32           `json:"id"`
	Column2         interface{}     `json:"column_2"`
	Column3         interface{}     `json:"column_3"`
	Location        pgtype.Text     `json:"location"`
	Description     pgtype.Text     `json:"description"`
	Valuation       ValuationMethod `json:"valuation"`
	ParentWarehouse pgtype.Int4     `json:"parent_warehouse"`
	Capacity        pgtype.Numeric  `json:"capacity"`
	Meta            []byte          `json:"meta"`
}

func (q *Queries) UpdateWarehouse(ctx context.Context, arg UpdateWarehouseParams) (Warehouse, error) {
	row := q.db.QueryRow(ctx, updateWarehouse,
		arg.ID,
		arg.Column2,
		arg.Column3,
		arg.Location,
		arg.Description,
		arg.Valuation,
		arg.ParentWarehouse,
		arg.Capacity,
		arg.Meta,
	)
	var i Warehouse
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Code,
		&i.Location,
		&i.Description,
		&i.Valuation,
		&i.ParentWarehouse,
		&i.Capacity,
		&i.Meta,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
