// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: laboratory.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkAnalystQualification = `-- name: CheckAnalystQualification :one
SELECT EXISTS(
    SELECT 1 FROM analyst_qualifications
    WHERE analyst_id = $1
        AND test_method_id = $2
        AND is_active = TRUE
        AND (expiry_date IS NULL OR expiry_date >= CURRENT_DATE)
) as is_qualified
`

type CheckAnalystQualificationParams struct {
	AnalystID    int32 `json:"analyst_id"`
	TestMethodID int32 `json:"test_method_id"`
}

func (q *Queries) CheckAnalystQualification(ctx context.Context, arg CheckAnalystQualificationParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkAnalystQualification, arg.AnalystID, arg.TestMethodID)
	var is_qualified bool
	err := row.Scan(&is_qualified)
	return is_qualified, err
}

const createAnalystQualification = `-- name: CreateAnalystQualification :one

INSERT INTO analyst_qualifications (
    analyst_id, test_method_id,
    qualification_date, qualified_by, expiry_date,
    training_completed, training_date, training_hours,
    assessment_score, assessment_notes,
    is_active, requalification_required, notes
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
)
RETURNING id, analyst_id, test_method_id, qualification_date, qualified_by, expiry_date, training_completed, training_date, training_hours, assessment_score, assessment_notes, is_active, requalification_required, notes, created_at, updated_at
`

type CreateAnalystQualificationParams struct {
	AnalystID               int32          `json:"analyst_id"`
	TestMethodID            int32          `json:"test_method_id"`
	QualificationDate       pgtype.Date    `json:"qualification_date"`
	QualifiedBy             pgtype.Int4    `json:"qualified_by"`
	ExpiryDate              pgtype.Date    `json:"expiry_date"`
	TrainingCompleted       pgtype.Bool    `json:"training_completed"`
	TrainingDate            pgtype.Date    `json:"training_date"`
	TrainingHours           pgtype.Numeric `json:"training_hours"`
	AssessmentScore         pgtype.Numeric `json:"assessment_score"`
	AssessmentNotes         pgtype.Text    `json:"assessment_notes"`
	IsActive                pgtype.Bool    `json:"is_active"`
	RequalificationRequired pgtype.Bool    `json:"requalification_required"`
	Notes                   pgtype.Text    `json:"notes"`
}

// ============================================================================
// ANALYST QUALIFICATIONS
// ============================================================================
func (q *Queries) CreateAnalystQualification(ctx context.Context, arg CreateAnalystQualificationParams) (AnalystQualification, error) {
	row := q.db.QueryRow(ctx, createAnalystQualification,
		arg.AnalystID,
		arg.TestMethodID,
		arg.QualificationDate,
		arg.QualifiedBy,
		arg.ExpiryDate,
		arg.TrainingCompleted,
		arg.TrainingDate,
		arg.TrainingHours,
		arg.AssessmentScore,
		arg.AssessmentNotes,
		arg.IsActive,
		arg.RequalificationRequired,
		arg.Notes,
	)
	var i AnalystQualification
	err := row.Scan(
		&i.ID,
		&i.AnalystID,
		&i.TestMethodID,
		&i.QualificationDate,
		&i.QualifiedBy,
		&i.ExpiryDate,
		&i.TrainingCompleted,
		&i.TrainingDate,
		&i.TrainingHours,
		&i.AssessmentScore,
		&i.AssessmentNotes,
		&i.IsActive,
		&i.RequalificationRequired,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createCertificateOfAnalysis = `-- name: CreateCertificateOfAnalysis :one

INSERT INTO certificates_of_analysis (
    coa_number, material_id, batch_number, lot_number,
    quality_inspection_id, manufacture_date, expiry_date,
    quantity, unit_id, test_results,
    customer_id, sales_order_id, recipient_name, recipient_address,
    status, issue_date,
    prepared_by, prepared_date,
    reviewed_by, reviewed_date,
    approved_by, approved_date,
    digital_signature, signature_timestamp,
    pdf_file_path, template_used, notes
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27
)
RETURNING id, coa_number, material_id, batch_number, lot_number, quality_inspection_id, manufacture_date, expiry_date, quantity, unit_id, test_results, customer_id, sales_order_id, recipient_name, recipient_address, status, issue_date, prepared_by, prepared_date, reviewed_by, reviewed_date, approved_by, approved_date, digital_signature, signature_timestamp, pdf_file_path, template_used, notes, created_at, updated_at
`

type CreateCertificateOfAnalysisParams struct {
	CoaNumber           string             `json:"coa_number"`
	MaterialID          int32              `json:"material_id"`
	BatchNumber         string             `json:"batch_number"`
	LotNumber           pgtype.Text        `json:"lot_number"`
	QualityInspectionID pgtype.Int4        `json:"quality_inspection_id"`
	ManufactureDate     pgtype.Date        `json:"manufacture_date"`
	ExpiryDate          pgtype.Date        `json:"expiry_date"`
	Quantity            pgtype.Numeric     `json:"quantity"`
	UnitID              pgtype.Int4        `json:"unit_id"`
	TestResults         []byte             `json:"test_results"`
	CustomerID          pgtype.Int4        `json:"customer_id"`
	SalesOrderID        pgtype.Int4        `json:"sales_order_id"`
	RecipientName       pgtype.Text        `json:"recipient_name"`
	RecipientAddress    pgtype.Text        `json:"recipient_address"`
	Status              NullCoaStatus      `json:"status"`
	IssueDate           pgtype.Date        `json:"issue_date"`
	PreparedBy          pgtype.Int4        `json:"prepared_by"`
	PreparedDate        pgtype.Date        `json:"prepared_date"`
	ReviewedBy          pgtype.Int4        `json:"reviewed_by"`
	ReviewedDate        pgtype.Date        `json:"reviewed_date"`
	ApprovedBy          pgtype.Int4        `json:"approved_by"`
	ApprovedDate        pgtype.Date        `json:"approved_date"`
	DigitalSignature    pgtype.Text        `json:"digital_signature"`
	SignatureTimestamp  pgtype.Timestamptz `json:"signature_timestamp"`
	PdfFilePath         pgtype.Text        `json:"pdf_file_path"`
	TemplateUsed        pgtype.Text        `json:"template_used"`
	Notes               pgtype.Text        `json:"notes"`
}

// ============================================================================
// CERTIFICATES OF ANALYSIS
// ============================================================================
func (q *Queries) CreateCertificateOfAnalysis(ctx context.Context, arg CreateCertificateOfAnalysisParams) (CertificatesOfAnalysis, error) {
	row := q.db.QueryRow(ctx, createCertificateOfAnalysis,
		arg.CoaNumber,
		arg.MaterialID,
		arg.BatchNumber,
		arg.LotNumber,
		arg.QualityInspectionID,
		arg.ManufactureDate,
		arg.ExpiryDate,
		arg.Quantity,
		arg.UnitID,
		arg.TestResults,
		arg.CustomerID,
		arg.SalesOrderID,
		arg.RecipientName,
		arg.RecipientAddress,
		arg.Status,
		arg.IssueDate,
		arg.PreparedBy,
		arg.PreparedDate,
		arg.ReviewedBy,
		arg.ReviewedDate,
		arg.ApprovedBy,
		arg.ApprovedDate,
		arg.DigitalSignature,
		arg.SignatureTimestamp,
		arg.PdfFilePath,
		arg.TemplateUsed,
		arg.Notes,
	)
	var i CertificatesOfAnalysis
	err := row.Scan(
		&i.ID,
		&i.CoaNumber,
		&i.MaterialID,
		&i.BatchNumber,
		&i.LotNumber,
		&i.QualityInspectionID,
		&i.ManufactureDate,
		&i.ExpiryDate,
		&i.Quantity,
		&i.UnitID,
		&i.TestResults,
		&i.CustomerID,
		&i.SalesOrderID,
		&i.RecipientName,
		&i.RecipientAddress,
		&i.Status,
		&i.IssueDate,
		&i.PreparedBy,
		&i.PreparedDate,
		&i.ReviewedBy,
		&i.ReviewedDate,
		&i.ApprovedBy,
		&i.ApprovedDate,
		&i.DigitalSignature,
		&i.SignatureTimestamp,
		&i.PdfFilePath,
		&i.TemplateUsed,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createLabEquipment = `-- name: CreateLabEquipment :one

INSERT INTO lab_equipment (
    equipment_code, equipment_name, equipment_type,
    manufacturer, model_number, serial_number,
    location, warehouse_id,
    calibration_frequency_days, last_calibration_date, next_calibration_date,
    calibration_status, calibration_certificate,
    last_maintenance_date, next_maintenance_date, maintenance_notes,
    is_operational, is_qualified, qualification_date,
    attachments, notes
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21
)
RETURNING id, equipment_code, equipment_name, equipment_type, manufacturer, model_number, serial_number, location, warehouse_id, calibration_frequency_days, last_calibration_date, next_calibration_date, calibration_status, calibration_certificate, last_maintenance_date, next_maintenance_date, maintenance_notes, is_operational, is_qualified, qualification_date, attachments, notes, created_at, updated_at
`

type CreateLabEquipmentParams struct {
	EquipmentCode            string                `json:"equipment_code"`
	EquipmentName            string                `json:"equipment_name"`
	EquipmentType            string                `json:"equipment_type"`
	Manufacturer             pgtype.Text           `json:"manufacturer"`
	ModelNumber              pgtype.Text           `json:"model_number"`
	SerialNumber             pgtype.Text           `json:"serial_number"`
	Location                 pgtype.Text           `json:"location"`
	WarehouseID              pgtype.Int4           `json:"warehouse_id"`
	CalibrationFrequencyDays pgtype.Int4           `json:"calibration_frequency_days"`
	LastCalibrationDate      pgtype.Date           `json:"last_calibration_date"`
	NextCalibrationDate      pgtype.Date           `json:"next_calibration_date"`
	CalibrationStatus        NullCalibrationStatus `json:"calibration_status"`
	CalibrationCertificate   pgtype.Text           `json:"calibration_certificate"`
	LastMaintenanceDate      pgtype.Date           `json:"last_maintenance_date"`
	NextMaintenanceDate      pgtype.Date           `json:"next_maintenance_date"`
	MaintenanceNotes         pgtype.Text           `json:"maintenance_notes"`
	IsOperational            pgtype.Bool           `json:"is_operational"`
	IsQualified              pgtype.Bool           `json:"is_qualified"`
	QualificationDate        pgtype.Date           `json:"qualification_date"`
	Attachments              []byte                `json:"attachments"`
	Notes                    pgtype.Text           `json:"notes"`
}

// ============================================================================
// LAB EQUIPMENT
// ============================================================================
func (q *Queries) CreateLabEquipment(ctx context.Context, arg CreateLabEquipmentParams) (LabEquipment, error) {
	row := q.db.QueryRow(ctx, createLabEquipment,
		arg.EquipmentCode,
		arg.EquipmentName,
		arg.EquipmentType,
		arg.Manufacturer,
		arg.ModelNumber,
		arg.SerialNumber,
		arg.Location,
		arg.WarehouseID,
		arg.CalibrationFrequencyDays,
		arg.LastCalibrationDate,
		arg.NextCalibrationDate,
		arg.CalibrationStatus,
		arg.CalibrationCertificate,
		arg.LastMaintenanceDate,
		arg.NextMaintenanceDate,
		arg.MaintenanceNotes,
		arg.IsOperational,
		arg.IsQualified,
		arg.QualificationDate,
		arg.Attachments,
		arg.Notes,
	)
	var i LabEquipment
	err := row.Scan(
		&i.ID,
		&i.EquipmentCode,
		&i.EquipmentName,
		&i.EquipmentType,
		&i.Manufacturer,
		&i.ModelNumber,
		&i.SerialNumber,
		&i.Location,
		&i.WarehouseID,
		&i.CalibrationFrequencyDays,
		&i.LastCalibrationDate,
		&i.NextCalibrationDate,
		&i.CalibrationStatus,
		&i.CalibrationCertificate,
		&i.LastMaintenanceDate,
		&i.NextMaintenanceDate,
		&i.MaintenanceNotes,
		&i.IsOperational,
		&i.IsQualified,
		&i.QualificationDate,
		&i.Attachments,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createLabSample = `-- name: CreateLabSample :one

INSERT INTO lab_samples (
    sample_number, sample_type, sample_status,
    material_id, batch_number, lot_number,
    quality_inspection_id, purchase_order_id, stock_transaction_id,
    sample_quantity, sample_unit_id, container_type, container_count,
    storage_location, storage_conditions,
    collected_by, collection_date, collection_method, sampling_plan,
    received_by_lab, lab_received_date,
    retention_required, retention_period_days, retention_expiry_date,
    is_external_lab, external_lab_name, external_lab_reference,
    sent_to_lab_date, expected_results_date,
    attachments, notes
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31
)
RETURNING id, sample_number, sample_type, sample_status, material_id, batch_number, lot_number, quality_inspection_id, purchase_order_id, stock_transaction_id, sample_quantity, sample_unit_id, container_type, container_count, storage_location, storage_conditions, collected_by, collection_date, collection_method, sampling_plan, received_by_lab, lab_received_date, transferred_to, transfer_date, chain_of_custody, retention_required, retention_period_days, retention_expiry_date, disposed_date, disposed_by, disposal_method, is_external_lab, external_lab_name, external_lab_reference, sent_to_lab_date, expected_results_date, attachments, notes, created_at, updated_at
`

type CreateLabSampleParams struct {
	SampleNumber         string              `json:"sample_number"`
	SampleType           LabSampleType       `json:"sample_type"`
	SampleStatus         NullLabSampleStatus `json:"sample_status"`
	MaterialID           pgtype.Int4         `json:"material_id"`
	BatchNumber          pgtype.Text         `json:"batch_number"`
	LotNumber            pgtype.Text         `json:"lot_number"`
	QualityInspectionID  pgtype.Int4         `json:"quality_inspection_id"`
	PurchaseOrderID      pgtype.Int4         `json:"purchase_order_id"`
	StockTransactionID   pgtype.Int4         `json:"stock_transaction_id"`
	SampleQuantity       pgtype.Numeric      `json:"sample_quantity"`
	SampleUnitID         pgtype.Int4         `json:"sample_unit_id"`
	ContainerType        pgtype.Text         `json:"container_type"`
	ContainerCount       pgtype.Int4         `json:"container_count"`
	StorageLocation      pgtype.Text         `json:"storage_location"`
	StorageConditions    pgtype.Text         `json:"storage_conditions"`
	CollectedBy          pgtype.Int4         `json:"collected_by"`
	CollectionDate       pgtype.Timestamptz  `json:"collection_date"`
	CollectionMethod     pgtype.Text         `json:"collection_method"`
	SamplingPlan         pgtype.Text         `json:"sampling_plan"`
	ReceivedByLab        pgtype.Int4         `json:"received_by_lab"`
	LabReceivedDate      pgtype.Timestamptz  `json:"lab_received_date"`
	RetentionRequired    pgtype.Bool         `json:"retention_required"`
	RetentionPeriodDays  pgtype.Int4         `json:"retention_period_days"`
	RetentionExpiryDate  pgtype.Date         `json:"retention_expiry_date"`
	IsExternalLab        pgtype.Bool         `json:"is_external_lab"`
	ExternalLabName      pgtype.Text         `json:"external_lab_name"`
	ExternalLabReference pgtype.Text         `json:"external_lab_reference"`
	SentToLabDate        pgtype.Date         `json:"sent_to_lab_date"`
	ExpectedResultsDate  pgtype.Date         `json:"expected_results_date"`
	Attachments          []byte              `json:"attachments"`
	Notes                pgtype.Text         `json:"notes"`
}

// ============================================================================
// LAB SAMPLES
// ============================================================================
func (q *Queries) CreateLabSample(ctx context.Context, arg CreateLabSampleParams) (LabSample, error) {
	row := q.db.QueryRow(ctx, createLabSample,
		arg.SampleNumber,
		arg.SampleType,
		arg.SampleStatus,
		arg.MaterialID,
		arg.BatchNumber,
		arg.LotNumber,
		arg.QualityInspectionID,
		arg.PurchaseOrderID,
		arg.StockTransactionID,
		arg.SampleQuantity,
		arg.SampleUnitID,
		arg.ContainerType,
		arg.ContainerCount,
		arg.StorageLocation,
		arg.StorageConditions,
		arg.CollectedBy,
		arg.CollectionDate,
		arg.CollectionMethod,
		arg.SamplingPlan,
		arg.ReceivedByLab,
		arg.LabReceivedDate,
		arg.RetentionRequired,
		arg.RetentionPeriodDays,
		arg.RetentionExpiryDate,
		arg.IsExternalLab,
		arg.ExternalLabName,
		arg.ExternalLabReference,
		arg.SentToLabDate,
		arg.ExpectedResultsDate,
		arg.Attachments,
		arg.Notes,
	)
	var i LabSample
	err := row.Scan(
		&i.ID,
		&i.SampleNumber,
		&i.SampleType,
		&i.SampleStatus,
		&i.MaterialID,
		&i.BatchNumber,
		&i.LotNumber,
		&i.QualityInspectionID,
		&i.PurchaseOrderID,
		&i.StockTransactionID,
		&i.SampleQuantity,
		&i.SampleUnitID,
		&i.ContainerType,
		&i.ContainerCount,
		&i.StorageLocation,
		&i.StorageConditions,
		&i.CollectedBy,
		&i.CollectionDate,
		&i.CollectionMethod,
		&i.SamplingPlan,
		&i.ReceivedByLab,
		&i.LabReceivedDate,
		&i.TransferredTo,
		&i.TransferDate,
		&i.ChainOfCustody,
		&i.RetentionRequired,
		&i.RetentionPeriodDays,
		&i.RetentionExpiryDate,
		&i.DisposedDate,
		&i.DisposedBy,
		&i.DisposalMethod,
		&i.IsExternalLab,
		&i.ExternalLabName,
		&i.ExternalLabReference,
		&i.SentToLabDate,
		&i.ExpectedResultsDate,
		&i.Attachments,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createLabTestAssignment = `-- name: CreateLabTestAssignment :one

INSERT INTO lab_test_assignments (
    sample_id, test_method_id,
    priority, requested_date, scheduled_date, due_date,
    assigned_to, assigned_date,
    status, is_rush, notes
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
)
RETURNING id, sample_id, test_method_id, priority, requested_date, scheduled_date, due_date, assigned_to, assigned_date, started_date, completed_date, status, is_rush, result_value, result_text, result_unit_id, pass_fail, reviewed_by, review_date, review_notes, is_retest, original_test_id, retest_reason, notes, created_at, updated_at
`

type CreateLabTestAssignmentParams struct {
	SampleID      int32                `json:"sample_id"`
	TestMethodID  int32                `json:"test_method_id"`
	Priority      pgtype.Int4          `json:"priority"`
	RequestedDate pgtype.Date          `json:"requested_date"`
	ScheduledDate pgtype.Date          `json:"scheduled_date"`
	DueDate       pgtype.Date          `json:"due_date"`
	AssignedTo    pgtype.Int4          `json:"assigned_to"`
	AssignedDate  pgtype.Timestamptz   `json:"assigned_date"`
	Status        NullTestResultStatus `json:"status"`
	IsRush        pgtype.Bool          `json:"is_rush"`
	Notes         pgtype.Text          `json:"notes"`
}

// ============================================================================
// LAB TEST ASSIGNMENTS
// ============================================================================
func (q *Queries) CreateLabTestAssignment(ctx context.Context, arg CreateLabTestAssignmentParams) (LabTestAssignment, error) {
	row := q.db.QueryRow(ctx, createLabTestAssignment,
		arg.SampleID,
		arg.TestMethodID,
		arg.Priority,
		arg.RequestedDate,
		arg.ScheduledDate,
		arg.DueDate,
		arg.AssignedTo,
		arg.AssignedDate,
		arg.Status,
		arg.IsRush,
		arg.Notes,
	)
	var i LabTestAssignment
	err := row.Scan(
		&i.ID,
		&i.SampleID,
		&i.TestMethodID,
		&i.Priority,
		&i.RequestedDate,
		&i.ScheduledDate,
		&i.DueDate,
		&i.AssignedTo,
		&i.AssignedDate,
		&i.StartedDate,
		&i.CompletedDate,
		&i.Status,
		&i.IsRush,
		&i.ResultValue,
		&i.ResultText,
		&i.ResultUnitID,
		&i.PassFail,
		&i.ReviewedBy,
		&i.ReviewDate,
		&i.ReviewNotes,
		&i.IsRetest,
		&i.OriginalTestID,
		&i.RetestReason,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createLabTestMethod = `-- name: CreateLabTestMethod :one

INSERT INTO lab_test_methods (
    method_code, method_name, description,
    standard_reference, standard_organization,
    test_type, test_category, methodology,
    sample_size, sample_unit_id, preparation_time, test_duration,
    required_equipment, specification_limits,
    version, effective_date, supersedes_method_id,
    status, approved_by, approval_date,
    attachments, notes, is_active
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23
)
RETURNING id, method_code, method_name, description, standard_reference, standard_organization, test_type, test_category, methodology, sample_size, sample_unit_id, preparation_time, test_duration, required_equipment, specification_limits, version, effective_date, supersedes_method_id, status, approved_by, approval_date, attachments, notes, is_active, created_at, updated_at
`

type CreateLabTestMethodParams struct {
	MethodCode           string               `json:"method_code"`
	MethodName           string               `json:"method_name"`
	Description          pgtype.Text          `json:"description"`
	StandardReference    pgtype.Text          `json:"standard_reference"`
	StandardOrganization pgtype.Text          `json:"standard_organization"`
	TestType             string               `json:"test_type"`
	TestCategory         pgtype.Text          `json:"test_category"`
	Methodology          pgtype.Text          `json:"methodology"`
	SampleSize           pgtype.Numeric       `json:"sample_size"`
	SampleUnitID         pgtype.Int4          `json:"sample_unit_id"`
	PreparationTime      pgtype.Int4          `json:"preparation_time"`
	TestDuration         pgtype.Int4          `json:"test_duration"`
	RequiredEquipment    []byte               `json:"required_equipment"`
	SpecificationLimits  []byte               `json:"specification_limits"`
	Version              pgtype.Text          `json:"version"`
	EffectiveDate        pgtype.Date          `json:"effective_date"`
	SupersedesMethodID   pgtype.Int4          `json:"supersedes_method_id"`
	Status               NullTestMethodStatus `json:"status"`
	ApprovedBy           pgtype.Int4          `json:"approved_by"`
	ApprovalDate         pgtype.Date          `json:"approval_date"`
	Attachments          []byte               `json:"attachments"`
	Notes                pgtype.Text          `json:"notes"`
	IsActive             pgtype.Bool          `json:"is_active"`
}

// ============================================================================
// LAB TEST METHODS
// ============================================================================
func (q *Queries) CreateLabTestMethod(ctx context.Context, arg CreateLabTestMethodParams) (LabTestMethod, error) {
	row := q.db.QueryRow(ctx, createLabTestMethod,
		arg.MethodCode,
		arg.MethodName,
		arg.Description,
		arg.StandardReference,
		arg.StandardOrganization,
		arg.TestType,
		arg.TestCategory,
		arg.Methodology,
		arg.SampleSize,
		arg.SampleUnitID,
		arg.PreparationTime,
		arg.TestDuration,
		arg.RequiredEquipment,
		arg.SpecificationLimits,
		arg.Version,
		arg.EffectiveDate,
		arg.SupersedesMethodID,
		arg.Status,
		arg.ApprovedBy,
		arg.ApprovalDate,
		arg.Attachments,
		arg.Notes,
		arg.IsActive,
	)
	var i LabTestMethod
	err := row.Scan(
		&i.ID,
		&i.MethodCode,
		&i.MethodName,
		&i.Description,
		&i.StandardReference,
		&i.StandardOrganization,
		&i.TestType,
		&i.TestCategory,
		&i.Methodology,
		&i.SampleSize,
		&i.SampleUnitID,
		&i.PreparationTime,
		&i.TestDuration,
		&i.RequiredEquipment,
		&i.SpecificationLimits,
		&i.Version,
		&i.EffectiveDate,
		&i.SupersedesMethodID,
		&i.Status,
		&i.ApprovedBy,
		&i.ApprovalDate,
		&i.Attachments,
		&i.Notes,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createLabTestResult = `-- name: CreateLabTestResult :one

INSERT INTO lab_test_results (
    test_assignment_id, test_date, analyst_id, equipment_id,
    parameter_name, result_value, result_text, result_unit_id,
    specification_min, specification_max, specification_target,
    is_in_spec, deviation,
    replicate_number, dilution_factor, preparation_details,
    test_temperature, test_humidity, test_conditions,
    system_suitability_pass, blank_value, reference_standard_value,
    raw_data_file, chromatogram_file, attachments, notes
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26
)
RETURNING id, test_assignment_id, test_date, analyst_id, equipment_id, parameter_name, result_value, result_text, result_unit_id, specification_min, specification_max, specification_target, is_in_spec, deviation, replicate_number, dilution_factor, preparation_details, test_temperature, test_humidity, test_conditions, system_suitability_pass, blank_value, reference_standard_value, raw_data_file, chromatogram_file, attachments, notes, created_at
`

type CreateLabTestResultParams struct {
	TestAssignmentID       int32              `json:"test_assignment_id"`
	TestDate               pgtype.Timestamptz `json:"test_date"`
	AnalystID              pgtype.Int4        `json:"analyst_id"`
	EquipmentID            pgtype.Int4        `json:"equipment_id"`
	ParameterName          string             `json:"parameter_name"`
	ResultValue            pgtype.Numeric     `json:"result_value"`
	ResultText             pgtype.Text        `json:"result_text"`
	ResultUnitID           pgtype.Int4        `json:"result_unit_id"`
	SpecificationMin       pgtype.Numeric     `json:"specification_min"`
	SpecificationMax       pgtype.Numeric     `json:"specification_max"`
	SpecificationTarget    pgtype.Numeric     `json:"specification_target"`
	IsInSpec               pgtype.Bool        `json:"is_in_spec"`
	Deviation              pgtype.Numeric     `json:"deviation"`
	ReplicateNumber        pgtype.Int4        `json:"replicate_number"`
	DilutionFactor         pgtype.Numeric     `json:"dilution_factor"`
	PreparationDetails     pgtype.Text        `json:"preparation_details"`
	TestTemperature        pgtype.Numeric     `json:"test_temperature"`
	TestHumidity           pgtype.Numeric     `json:"test_humidity"`
	TestConditions         []byte             `json:"test_conditions"`
	SystemSuitabilityPass  pgtype.Bool        `json:"system_suitability_pass"`
	BlankValue             pgtype.Numeric     `json:"blank_value"`
	ReferenceStandardValue pgtype.Numeric     `json:"reference_standard_value"`
	RawDataFile            pgtype.Text        `json:"raw_data_file"`
	ChromatogramFile       pgtype.Text        `json:"chromatogram_file"`
	Attachments            []byte             `json:"attachments"`
	Notes                  pgtype.Text        `json:"notes"`
}

// ============================================================================
// LAB TEST RESULTS
// ============================================================================
func (q *Queries) CreateLabTestResult(ctx context.Context, arg CreateLabTestResultParams) (LabTestResult, error) {
	row := q.db.QueryRow(ctx, createLabTestResult,
		arg.TestAssignmentID,
		arg.TestDate,
		arg.AnalystID,
		arg.EquipmentID,
		arg.ParameterName,
		arg.ResultValue,
		arg.ResultText,
		arg.ResultUnitID,
		arg.SpecificationMin,
		arg.SpecificationMax,
		arg.SpecificationTarget,
		arg.IsInSpec,
		arg.Deviation,
		arg.ReplicateNumber,
		arg.DilutionFactor,
		arg.PreparationDetails,
		arg.TestTemperature,
		arg.TestHumidity,
		arg.TestConditions,
		arg.SystemSuitabilityPass,
		arg.BlankValue,
		arg.ReferenceStandardValue,
		arg.RawDataFile,
		arg.ChromatogramFile,
		arg.Attachments,
		arg.Notes,
	)
	var i LabTestResult
	err := row.Scan(
		&i.ID,
		&i.TestAssignmentID,
		&i.TestDate,
		&i.AnalystID,
		&i.EquipmentID,
		&i.ParameterName,
		&i.ResultValue,
		&i.ResultText,
		&i.ResultUnitID,
		&i.SpecificationMin,
		&i.SpecificationMax,
		&i.SpecificationTarget,
		&i.IsInSpec,
		&i.Deviation,
		&i.ReplicateNumber,
		&i.DilutionFactor,
		&i.PreparationDetails,
		&i.TestTemperature,
		&i.TestHumidity,
		&i.TestConditions,
		&i.SystemSuitabilityPass,
		&i.BlankValue,
		&i.ReferenceStandardValue,
		&i.RawDataFile,
		&i.ChromatogramFile,
		&i.Attachments,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}

const createOOSInvestigation = `-- name: CreateOOSInvestigation :one

INSERT INTO oos_investigations (
    oos_number, test_assignment_id, sample_id, ncr_id,
    oos_description, severity,
    initiated_by, initiated_date, investigator_id,
    status, notes, attachments
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
)
RETURNING id, oos_number, test_assignment_id, sample_id, ncr_id, oos_description, severity, phase_1_start_date, phase_1_complete_date, phase_1_findings, lab_error_found, lab_error_description, phase_2_required, phase_2_start_date, phase_2_complete_date, phase_2_findings, root_cause, retest_required, retest_completed, retest_results, final_conclusion, corrective_action, preventive_action, batch_disposition, impact_on_other_batches, initiated_by, initiated_date, investigator_id, reviewed_by, approved_by, status, closed_date, notes, attachments, created_at, updated_at
`

type CreateOOSInvestigationParams struct {
	OosNumber        string             `json:"oos_number"`
	TestAssignmentID int32              `json:"test_assignment_id"`
	SampleID         pgtype.Int4        `json:"sample_id"`
	NcrID            pgtype.Int4        `json:"ncr_id"`
	OosDescription   string             `json:"oos_description"`
	Severity         NullNcrSeverity    `json:"severity"`
	InitiatedBy      pgtype.Int4        `json:"initiated_by"`
	InitiatedDate    pgtype.Timestamptz `json:"initiated_date"`
	InvestigatorID   pgtype.Int4        `json:"investigator_id"`
	Status           pgtype.Text        `json:"status"`
	Notes            pgtype.Text        `json:"notes"`
	Attachments      []byte             `json:"attachments"`
}

// ============================================================================
// OOS INVESTIGATIONS
// ============================================================================
func (q *Queries) CreateOOSInvestigation(ctx context.Context, arg CreateOOSInvestigationParams) (OosInvestigation, error) {
	row := q.db.QueryRow(ctx, createOOSInvestigation,
		arg.OosNumber,
		arg.TestAssignmentID,
		arg.SampleID,
		arg.NcrID,
		arg.OosDescription,
		arg.Severity,
		arg.InitiatedBy,
		arg.InitiatedDate,
		arg.InvestigatorID,
		arg.Status,
		arg.Notes,
		arg.Attachments,
	)
	var i OosInvestigation
	err := row.Scan(
		&i.ID,
		&i.OosNumber,
		&i.TestAssignmentID,
		&i.SampleID,
		&i.NcrID,
		&i.OosDescription,
		&i.Severity,
		&i.Phase1StartDate,
		&i.Phase1CompleteDate,
		&i.Phase1Findings,
		&i.LabErrorFound,
		&i.LabErrorDescription,
		&i.Phase2Required,
		&i.Phase2StartDate,
		&i.Phase2CompleteDate,
		&i.Phase2Findings,
		&i.RootCause,
		&i.RetestRequired,
		&i.RetestCompleted,
		&i.RetestResults,
		&i.FinalConclusion,
		&i.CorrectiveAction,
		&i.PreventiveAction,
		&i.BatchDisposition,
		&i.ImpactOnOtherBatches,
		&i.InitiatedBy,
		&i.InitiatedDate,
		&i.InvestigatorID,
		&i.ReviewedBy,
		&i.ApprovedBy,
		&i.Status,
		&i.ClosedDate,
		&i.Notes,
		&i.Attachments,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createStabilitySample = `-- name: CreateStabilitySample :one

INSERT INTO stability_samples (
    stability_study_id, lab_sample_id,
    time_point_months, scheduled_pull_date, actual_pull_date,
    testing_due_date, notes
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
RETURNING id, stability_study_id, lab_sample_id, time_point_months, scheduled_pull_date, actual_pull_date, testing_due_date, testing_completed, testing_completed_date, results_summary, all_tests_passed, notes, created_at, updated_at
`

type CreateStabilitySampleParams struct {
	StabilityStudyID  int32       `json:"stability_study_id"`
	LabSampleID       pgtype.Int4 `json:"lab_sample_id"`
	TimePointMonths   int32       `json:"time_point_months"`
	ScheduledPullDate pgtype.Date `json:"scheduled_pull_date"`
	ActualPullDate    pgtype.Date `json:"actual_pull_date"`
	TestingDueDate    pgtype.Date `json:"testing_due_date"`
	Notes             pgtype.Text `json:"notes"`
}

// ============================================================================
// STABILITY SAMPLES
// ============================================================================
func (q *Queries) CreateStabilitySample(ctx context.Context, arg CreateStabilitySampleParams) (StabilitySample, error) {
	row := q.db.QueryRow(ctx, createStabilitySample,
		arg.StabilityStudyID,
		arg.LabSampleID,
		arg.TimePointMonths,
		arg.ScheduledPullDate,
		arg.ActualPullDate,
		arg.TestingDueDate,
		arg.Notes,
	)
	var i StabilitySample
	err := row.Scan(
		&i.ID,
		&i.StabilityStudyID,
		&i.LabSampleID,
		&i.TimePointMonths,
		&i.ScheduledPullDate,
		&i.ActualPullDate,
		&i.TestingDueDate,
		&i.TestingCompleted,
		&i.TestingCompletedDate,
		&i.ResultsSummary,
		&i.AllTestsPassed,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createStabilityStudy = `-- name: CreateStabilityStudy :one

INSERT INTO stability_studies (
    study_number, study_name, material_id, batch_number,
    study_type, storage_condition, study_duration_months,
    start_date, expected_end_date,
    test_schedule, test_methods,
    status, protocol_approved_by, protocol_approval_date,
    notes, attachments
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16
)
RETURNING id, study_number, study_name, material_id, batch_number, study_type, storage_condition, study_duration_months, start_date, expected_end_date, actual_end_date, test_schedule, test_methods, status, results_summary, conclusion, shelf_life_recommendation, protocol_approved_by, protocol_approval_date, report_approved_by, report_approval_date, notes, attachments, created_at, updated_at
`

type CreateStabilityStudyParams struct {
	StudyNumber          string      `json:"study_number"`
	StudyName            string      `json:"study_name"`
	MaterialID           int32       `json:"material_id"`
	BatchNumber          string      `json:"batch_number"`
	StudyType            pgtype.Text `json:"study_type"`
	StorageCondition     string      `json:"storage_condition"`
	StudyDurationMonths  pgtype.Int4 `json:"study_duration_months"`
	StartDate            pgtype.Date `json:"start_date"`
	ExpectedEndDate      pgtype.Date `json:"expected_end_date"`
	TestSchedule         []byte      `json:"test_schedule"`
	TestMethods          []byte      `json:"test_methods"`
	Status               pgtype.Text `json:"status"`
	ProtocolApprovedBy   pgtype.Int4 `json:"protocol_approved_by"`
	ProtocolApprovalDate pgtype.Date `json:"protocol_approval_date"`
	Notes                pgtype.Text `json:"notes"`
	Attachments          []byte      `json:"attachments"`
}

// ============================================================================
// STABILITY STUDIES
// ============================================================================
func (q *Queries) CreateStabilityStudy(ctx context.Context, arg CreateStabilityStudyParams) (StabilityStudy, error) {
	row := q.db.QueryRow(ctx, createStabilityStudy,
		arg.StudyNumber,
		arg.StudyName,
		arg.MaterialID,
		arg.BatchNumber,
		arg.StudyType,
		arg.StorageCondition,
		arg.StudyDurationMonths,
		arg.StartDate,
		arg.ExpectedEndDate,
		arg.TestSchedule,
		arg.TestMethods,
		arg.Status,
		arg.ProtocolApprovedBy,
		arg.ProtocolApprovalDate,
		arg.Notes,
		arg.Attachments,
	)
	var i StabilityStudy
	err := row.Scan(
		&i.ID,
		&i.StudyNumber,
		&i.StudyName,
		&i.MaterialID,
		&i.BatchNumber,
		&i.StudyType,
		&i.StorageCondition,
		&i.StudyDurationMonths,
		&i.StartDate,
		&i.ExpectedEndDate,
		&i.ActualEndDate,
		&i.TestSchedule,
		&i.TestMethods,
		&i.Status,
		&i.ResultsSummary,
		&i.Conclusion,
		&i.ShelfLifeRecommendation,
		&i.ProtocolApprovedBy,
		&i.ProtocolApprovalDate,
		&i.ReportApprovedBy,
		&i.ReportApprovalDate,
		&i.Notes,
		&i.Attachments,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAnalystQualification = `-- name: DeleteAnalystQualification :exec
DELETE FROM analyst_qualifications
WHERE id = $1
`

func (q *Queries) DeleteAnalystQualification(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteAnalystQualification, id)
	return err
}

const deleteCertificateOfAnalysis = `-- name: DeleteCertificateOfAnalysis :exec
DELETE FROM certificates_of_analysis
WHERE id = $1
`

func (q *Queries) DeleteCertificateOfAnalysis(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteCertificateOfAnalysis, id)
	return err
}

const deleteLabEquipment = `-- name: DeleteLabEquipment :exec
DELETE FROM lab_equipment
WHERE id = $1
`

func (q *Queries) DeleteLabEquipment(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteLabEquipment, id)
	return err
}

const deleteLabSample = `-- name: DeleteLabSample :exec
DELETE FROM lab_samples
WHERE id = $1
`

func (q *Queries) DeleteLabSample(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteLabSample, id)
	return err
}

const deleteLabTestAssignment = `-- name: DeleteLabTestAssignment :exec
DELETE FROM lab_test_assignments
WHERE id = $1
`

func (q *Queries) DeleteLabTestAssignment(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteLabTestAssignment, id)
	return err
}

const deleteLabTestMethod = `-- name: DeleteLabTestMethod :exec
DELETE FROM lab_test_methods
WHERE id = $1
`

func (q *Queries) DeleteLabTestMethod(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteLabTestMethod, id)
	return err
}

const deleteLabTestResult = `-- name: DeleteLabTestResult :exec
DELETE FROM lab_test_results
WHERE id = $1
`

func (q *Queries) DeleteLabTestResult(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteLabTestResult, id)
	return err
}

const deleteOOSInvestigation = `-- name: DeleteOOSInvestigation :exec
DELETE FROM oos_investigations
WHERE id = $1
`

func (q *Queries) DeleteOOSInvestigation(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteOOSInvestigation, id)
	return err
}

const deleteStabilitySample = `-- name: DeleteStabilitySample :exec
DELETE FROM stability_samples
WHERE id = $1
`

func (q *Queries) DeleteStabilitySample(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteStabilitySample, id)
	return err
}

const deleteStabilityStudy = `-- name: DeleteStabilityStudy :exec
DELETE FROM stability_studies
WHERE id = $1
`

func (q *Queries) DeleteStabilityStudy(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteStabilityStudy, id)
	return err
}

const getAnalystProductivity = `-- name: GetAnalystProductivity :many
SELECT 
    u.id,
    u.full_name,
    COUNT(DISTINCT lta.id) as total_assignments,
    COUNT(DISTINCT CASE WHEN lta.status = 'pass' THEN lta.id END) as completed_tests,
    COUNT(DISTINCT CASE WHEN lta.status = 'fail' THEN lta.id END) as failed_tests,
    AVG(EXTRACT(EPOCH FROM (lta.completed_date - lta.started_date))/3600) as avg_hours_per_test
FROM users u
LEFT JOIN lab_test_assignments lta ON u.id = lta.assigned_to
WHERE lta.completed_date >= $1 AND lta.completed_date <= $2
GROUP BY u.id, u.full_name
ORDER BY completed_tests DESC
`

type GetAnalystProductivityParams struct {
	CompletedDate   pgtype.Timestamptz `json:"completed_date"`
	CompletedDate_2 pgtype.Timestamptz `json:"completed_date_2"`
}

type GetAnalystProductivityRow struct {
	ID               int32       `json:"id"`
	FullName         pgtype.Text `json:"full_name"`
	TotalAssignments int64       `json:"total_assignments"`
	CompletedTests   int64       `json:"completed_tests"`
	FailedTests      int64       `json:"failed_tests"`
	AvgHoursPerTest  float64     `json:"avg_hours_per_test"`
}

func (q *Queries) GetAnalystProductivity(ctx context.Context, arg GetAnalystProductivityParams) ([]GetAnalystProductivityRow, error) {
	rows, err := q.db.Query(ctx, getAnalystProductivity, arg.CompletedDate, arg.CompletedDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAnalystProductivityRow{}
	for rows.Next() {
		var i GetAnalystProductivityRow
		if err := rows.Scan(
			&i.ID,
			&i.FullName,
			&i.TotalAssignments,
			&i.CompletedTests,
			&i.FailedTests,
			&i.AvgHoursPerTest,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAnalystQualificationByID = `-- name: GetAnalystQualificationByID :one
SELECT 
    aq.id, aq.analyst_id, aq.test_method_id, aq.qualification_date, aq.qualified_by, aq.expiry_date, aq.training_completed, aq.training_date, aq.training_hours, aq.assessment_score, aq.assessment_notes, aq.is_active, aq.requalification_required, aq.notes, aq.created_at, aq.updated_at,
    analyst.full_name as analyst_name,
    ltm.method_code,
    ltm.method_name,
    qualified.full_name as qualified_by_name
FROM analyst_qualifications aq
LEFT JOIN users analyst ON aq.analyst_id = analyst.id
LEFT JOIN lab_test_methods ltm ON aq.test_method_id = ltm.id
LEFT JOIN users qualified ON aq.qualified_by = qualified.id
WHERE aq.id = $1
`

type GetAnalystQualificationByIDRow struct {
	ID                      int32              `json:"id"`
	AnalystID               int32              `json:"analyst_id"`
	TestMethodID            int32              `json:"test_method_id"`
	QualificationDate       pgtype.Date        `json:"qualification_date"`
	QualifiedBy             pgtype.Int4        `json:"qualified_by"`
	ExpiryDate              pgtype.Date        `json:"expiry_date"`
	TrainingCompleted       pgtype.Bool        `json:"training_completed"`
	TrainingDate            pgtype.Date        `json:"training_date"`
	TrainingHours           pgtype.Numeric     `json:"training_hours"`
	AssessmentScore         pgtype.Numeric     `json:"assessment_score"`
	AssessmentNotes         pgtype.Text        `json:"assessment_notes"`
	IsActive                pgtype.Bool        `json:"is_active"`
	RequalificationRequired pgtype.Bool        `json:"requalification_required"`
	Notes                   pgtype.Text        `json:"notes"`
	CreatedAt               pgtype.Timestamptz `json:"created_at"`
	UpdatedAt               pgtype.Timestamptz `json:"updated_at"`
	AnalystName             pgtype.Text        `json:"analyst_name"`
	MethodCode              pgtype.Text        `json:"method_code"`
	MethodName              pgtype.Text        `json:"method_name"`
	QualifiedByName         pgtype.Text        `json:"qualified_by_name"`
}

func (q *Queries) GetAnalystQualificationByID(ctx context.Context, id int32) (GetAnalystQualificationByIDRow, error) {
	row := q.db.QueryRow(ctx, getAnalystQualificationByID, id)
	var i GetAnalystQualificationByIDRow
	err := row.Scan(
		&i.ID,
		&i.AnalystID,
		&i.TestMethodID,
		&i.QualificationDate,
		&i.QualifiedBy,
		&i.ExpiryDate,
		&i.TrainingCompleted,
		&i.TrainingDate,
		&i.TrainingHours,
		&i.AssessmentScore,
		&i.AssessmentNotes,
		&i.IsActive,
		&i.RequalificationRequired,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AnalystName,
		&i.MethodCode,
		&i.MethodName,
		&i.QualifiedByName,
	)
	return i, err
}

const getCertificateOfAnalysisByID = `-- name: GetCertificateOfAnalysisByID :one
SELECT 
    coa.id, coa.coa_number, coa.material_id, coa.batch_number, coa.lot_number, coa.quality_inspection_id, coa.manufacture_date, coa.expiry_date, coa.quantity, coa.unit_id, coa.test_results, coa.customer_id, coa.sales_order_id, coa.recipient_name, coa.recipient_address, coa.status, coa.issue_date, coa.prepared_by, coa.prepared_date, coa.reviewed_by, coa.reviewed_date, coa.approved_by, coa.approved_date, coa.digital_signature, coa.signature_timestamp, coa.pdf_file_path, coa.template_used, coa.notes, coa.created_at, coa.updated_at,
    m.name as material_name,
    m.sku as material_sku,
    cust.name as customer_name,
    prep.full_name as prepared_by_name,
    rev.full_name as reviewed_by_name,
    app.full_name as approved_by_name
FROM certificates_of_analysis coa
LEFT JOIN materials m ON coa.material_id = m.id
LEFT JOIN customers cust ON coa.customer_id = cust.id
LEFT JOIN users prep ON coa.prepared_by = prep.id
LEFT JOIN users rev ON coa.reviewed_by = rev.id
LEFT JOIN users app ON coa.approved_by = app.id
WHERE coa.id = $1
`

type GetCertificateOfAnalysisByIDRow struct {
	ID                  int32              `json:"id"`
	CoaNumber           string             `json:"coa_number"`
	MaterialID          int32              `json:"material_id"`
	BatchNumber         string             `json:"batch_number"`
	LotNumber           pgtype.Text        `json:"lot_number"`
	QualityInspectionID pgtype.Int4        `json:"quality_inspection_id"`
	ManufactureDate     pgtype.Date        `json:"manufacture_date"`
	ExpiryDate          pgtype.Date        `json:"expiry_date"`
	Quantity            pgtype.Numeric     `json:"quantity"`
	UnitID              pgtype.Int4        `json:"unit_id"`
	TestResults         []byte             `json:"test_results"`
	CustomerID          pgtype.Int4        `json:"customer_id"`
	SalesOrderID        pgtype.Int4        `json:"sales_order_id"`
	RecipientName       pgtype.Text        `json:"recipient_name"`
	RecipientAddress    pgtype.Text        `json:"recipient_address"`
	Status              NullCoaStatus      `json:"status"`
	IssueDate           pgtype.Date        `json:"issue_date"`
	PreparedBy          pgtype.Int4        `json:"prepared_by"`
	PreparedDate        pgtype.Date        `json:"prepared_date"`
	ReviewedBy          pgtype.Int4        `json:"reviewed_by"`
	ReviewedDate        pgtype.Date        `json:"reviewed_date"`
	ApprovedBy          pgtype.Int4        `json:"approved_by"`
	ApprovedDate        pgtype.Date        `json:"approved_date"`
	DigitalSignature    pgtype.Text        `json:"digital_signature"`
	SignatureTimestamp  pgtype.Timestamptz `json:"signature_timestamp"`
	PdfFilePath         pgtype.Text        `json:"pdf_file_path"`
	TemplateUsed        pgtype.Text        `json:"template_used"`
	Notes               pgtype.Text        `json:"notes"`
	CreatedAt           pgtype.Timestamptz `json:"created_at"`
	UpdatedAt           pgtype.Timestamptz `json:"updated_at"`
	MaterialName        pgtype.Text        `json:"material_name"`
	MaterialSku         pgtype.Text        `json:"material_sku"`
	CustomerName        pgtype.Text        `json:"customer_name"`
	PreparedByName      pgtype.Text        `json:"prepared_by_name"`
	ReviewedByName      pgtype.Text        `json:"reviewed_by_name"`
	ApprovedByName      pgtype.Text        `json:"approved_by_name"`
}

func (q *Queries) GetCertificateOfAnalysisByID(ctx context.Context, id int32) (GetCertificateOfAnalysisByIDRow, error) {
	row := q.db.QueryRow(ctx, getCertificateOfAnalysisByID, id)
	var i GetCertificateOfAnalysisByIDRow
	err := row.Scan(
		&i.ID,
		&i.CoaNumber,
		&i.MaterialID,
		&i.BatchNumber,
		&i.LotNumber,
		&i.QualityInspectionID,
		&i.ManufactureDate,
		&i.ExpiryDate,
		&i.Quantity,
		&i.UnitID,
		&i.TestResults,
		&i.CustomerID,
		&i.SalesOrderID,
		&i.RecipientName,
		&i.RecipientAddress,
		&i.Status,
		&i.IssueDate,
		&i.PreparedBy,
		&i.PreparedDate,
		&i.ReviewedBy,
		&i.ReviewedDate,
		&i.ApprovedBy,
		&i.ApprovedDate,
		&i.DigitalSignature,
		&i.SignatureTimestamp,
		&i.PdfFilePath,
		&i.TemplateUsed,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MaterialName,
		&i.MaterialSku,
		&i.CustomerName,
		&i.PreparedByName,
		&i.ReviewedByName,
		&i.ApprovedByName,
	)
	return i, err
}

const getCertificateOfAnalysisByNumber = `-- name: GetCertificateOfAnalysisByNumber :one
SELECT id, coa_number, material_id, batch_number, lot_number, quality_inspection_id, manufacture_date, expiry_date, quantity, unit_id, test_results, customer_id, sales_order_id, recipient_name, recipient_address, status, issue_date, prepared_by, prepared_date, reviewed_by, reviewed_date, approved_by, approved_date, digital_signature, signature_timestamp, pdf_file_path, template_used, notes, created_at, updated_at FROM certificates_of_analysis
WHERE coa_number = $1
`

func (q *Queries) GetCertificateOfAnalysisByNumber(ctx context.Context, coaNumber string) (CertificatesOfAnalysis, error) {
	row := q.db.QueryRow(ctx, getCertificateOfAnalysisByNumber, coaNumber)
	var i CertificatesOfAnalysis
	err := row.Scan(
		&i.ID,
		&i.CoaNumber,
		&i.MaterialID,
		&i.BatchNumber,
		&i.LotNumber,
		&i.QualityInspectionID,
		&i.ManufactureDate,
		&i.ExpiryDate,
		&i.Quantity,
		&i.UnitID,
		&i.TestResults,
		&i.CustomerID,
		&i.SalesOrderID,
		&i.RecipientName,
		&i.RecipientAddress,
		&i.Status,
		&i.IssueDate,
		&i.PreparedBy,
		&i.PreparedDate,
		&i.ReviewedBy,
		&i.ReviewedDate,
		&i.ApprovedBy,
		&i.ApprovedDate,
		&i.DigitalSignature,
		&i.SignatureTimestamp,
		&i.PdfFilePath,
		&i.TemplateUsed,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLabDashboardStats = `-- name: GetLabDashboardStats :one

SELECT 
    (SELECT COUNT(*) FROM lab_samples WHERE sample_status = 'pending') as pending_samples,
    (SELECT COUNT(*) FROM lab_test_assignments WHERE status IN ('pending', 'in_progress')) as pending_tests,
    (SELECT COUNT(*) FROM lab_test_assignments WHERE due_date < CURRENT_DATE AND status IN ('pending', 'in_progress')) as overdue_tests,
    (SELECT COUNT(*) FROM lab_equipment WHERE calibration_status = 'overdue') as overdue_calibrations,
    (SELECT COUNT(*) FROM oos_investigations WHERE status = 'open') as open_oos
`

type GetLabDashboardStatsRow struct {
	PendingSamples      int64 `json:"pending_samples"`
	PendingTests        int64 `json:"pending_tests"`
	OverdueTests        int64 `json:"overdue_tests"`
	OverdueCalibrations int64 `json:"overdue_calibrations"`
	OpenOos             int64 `json:"open_oos"`
}

// ============================================================================
// STATISTICS & REPORTS
// ============================================================================
func (q *Queries) GetLabDashboardStats(ctx context.Context) (GetLabDashboardStatsRow, error) {
	row := q.db.QueryRow(ctx, getLabDashboardStats)
	var i GetLabDashboardStatsRow
	err := row.Scan(
		&i.PendingSamples,
		&i.PendingTests,
		&i.OverdueTests,
		&i.OverdueCalibrations,
		&i.OpenOos,
	)
	return i, err
}

const getLabEquipmentByCode = `-- name: GetLabEquipmentByCode :one
SELECT id, equipment_code, equipment_name, equipment_type, manufacturer, model_number, serial_number, location, warehouse_id, calibration_frequency_days, last_calibration_date, next_calibration_date, calibration_status, calibration_certificate, last_maintenance_date, next_maintenance_date, maintenance_notes, is_operational, is_qualified, qualification_date, attachments, notes, created_at, updated_at FROM lab_equipment
WHERE equipment_code = $1
`

func (q *Queries) GetLabEquipmentByCode(ctx context.Context, equipmentCode string) (LabEquipment, error) {
	row := q.db.QueryRow(ctx, getLabEquipmentByCode, equipmentCode)
	var i LabEquipment
	err := row.Scan(
		&i.ID,
		&i.EquipmentCode,
		&i.EquipmentName,
		&i.EquipmentType,
		&i.Manufacturer,
		&i.ModelNumber,
		&i.SerialNumber,
		&i.Location,
		&i.WarehouseID,
		&i.CalibrationFrequencyDays,
		&i.LastCalibrationDate,
		&i.NextCalibrationDate,
		&i.CalibrationStatus,
		&i.CalibrationCertificate,
		&i.LastMaintenanceDate,
		&i.NextMaintenanceDate,
		&i.MaintenanceNotes,
		&i.IsOperational,
		&i.IsQualified,
		&i.QualificationDate,
		&i.Attachments,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLabEquipmentByID = `-- name: GetLabEquipmentByID :one
SELECT 
    le.id, le.equipment_code, le.equipment_name, le.equipment_type, le.manufacturer, le.model_number, le.serial_number, le.location, le.warehouse_id, le.calibration_frequency_days, le.last_calibration_date, le.next_calibration_date, le.calibration_status, le.calibration_certificate, le.last_maintenance_date, le.next_maintenance_date, le.maintenance_notes, le.is_operational, le.is_qualified, le.qualification_date, le.attachments, le.notes, le.created_at, le.updated_at,
    w.name as warehouse_name
FROM lab_equipment le
LEFT JOIN warehouses w ON le.warehouse_id = w.id
WHERE le.id = $1
`

type GetLabEquipmentByIDRow struct {
	ID                       int32                 `json:"id"`
	EquipmentCode            string                `json:"equipment_code"`
	EquipmentName            string                `json:"equipment_name"`
	EquipmentType            string                `json:"equipment_type"`
	Manufacturer             pgtype.Text           `json:"manufacturer"`
	ModelNumber              pgtype.Text           `json:"model_number"`
	SerialNumber             pgtype.Text           `json:"serial_number"`
	Location                 pgtype.Text           `json:"location"`
	WarehouseID              pgtype.Int4           `json:"warehouse_id"`
	CalibrationFrequencyDays pgtype.Int4           `json:"calibration_frequency_days"`
	LastCalibrationDate      pgtype.Date           `json:"last_calibration_date"`
	NextCalibrationDate      pgtype.Date           `json:"next_calibration_date"`
	CalibrationStatus        NullCalibrationStatus `json:"calibration_status"`
	CalibrationCertificate   pgtype.Text           `json:"calibration_certificate"`
	LastMaintenanceDate      pgtype.Date           `json:"last_maintenance_date"`
	NextMaintenanceDate      pgtype.Date           `json:"next_maintenance_date"`
	MaintenanceNotes         pgtype.Text           `json:"maintenance_notes"`
	IsOperational            pgtype.Bool           `json:"is_operational"`
	IsQualified              pgtype.Bool           `json:"is_qualified"`
	QualificationDate        pgtype.Date           `json:"qualification_date"`
	Attachments              []byte                `json:"attachments"`
	Notes                    pgtype.Text           `json:"notes"`
	CreatedAt                pgtype.Timestamptz    `json:"created_at"`
	UpdatedAt                pgtype.Timestamptz    `json:"updated_at"`
	WarehouseName            pgtype.Text           `json:"warehouse_name"`
}

func (q *Queries) GetLabEquipmentByID(ctx context.Context, id int32) (GetLabEquipmentByIDRow, error) {
	row := q.db.QueryRow(ctx, getLabEquipmentByID, id)
	var i GetLabEquipmentByIDRow
	err := row.Scan(
		&i.ID,
		&i.EquipmentCode,
		&i.EquipmentName,
		&i.EquipmentType,
		&i.Manufacturer,
		&i.ModelNumber,
		&i.SerialNumber,
		&i.Location,
		&i.WarehouseID,
		&i.CalibrationFrequencyDays,
		&i.LastCalibrationDate,
		&i.NextCalibrationDate,
		&i.CalibrationStatus,
		&i.CalibrationCertificate,
		&i.LastMaintenanceDate,
		&i.NextMaintenanceDate,
		&i.MaintenanceNotes,
		&i.IsOperational,
		&i.IsQualified,
		&i.QualificationDate,
		&i.Attachments,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.WarehouseName,
	)
	return i, err
}

const getLabSampleByID = `-- name: GetLabSampleByID :one
SELECT 
    ls.id, ls.sample_number, ls.sample_type, ls.sample_status, ls.material_id, ls.batch_number, ls.lot_number, ls.quality_inspection_id, ls.purchase_order_id, ls.stock_transaction_id, ls.sample_quantity, ls.sample_unit_id, ls.container_type, ls.container_count, ls.storage_location, ls.storage_conditions, ls.collected_by, ls.collection_date, ls.collection_method, ls.sampling_plan, ls.received_by_lab, ls.lab_received_date, ls.transferred_to, ls.transfer_date, ls.chain_of_custody, ls.retention_required, ls.retention_period_days, ls.retention_expiry_date, ls.disposed_date, ls.disposed_by, ls.disposal_method, ls.is_external_lab, ls.external_lab_name, ls.external_lab_reference, ls.sent_to_lab_date, ls.expected_results_date, ls.attachments, ls.notes, ls.created_at, ls.updated_at,
    m.name as material_name,
    m.sku as material_sku,
    u.abbreviation as unit_abbreviation,
    collected.full_name as collected_by_name,
    received.full_name as received_by_lab_name
FROM lab_samples ls
LEFT JOIN materials m ON ls.material_id = m.id
LEFT JOIN measure_units u ON ls.sample_unit_id = u.id
LEFT JOIN users collected ON ls.collected_by = collected.id
LEFT JOIN users received ON ls.received_by_lab = received.id
WHERE ls.id = $1
`

type GetLabSampleByIDRow struct {
	ID                   int32               `json:"id"`
	SampleNumber         string              `json:"sample_number"`
	SampleType           LabSampleType       `json:"sample_type"`
	SampleStatus         NullLabSampleStatus `json:"sample_status"`
	MaterialID           pgtype.Int4         `json:"material_id"`
	BatchNumber          pgtype.Text         `json:"batch_number"`
	LotNumber            pgtype.Text         `json:"lot_number"`
	QualityInspectionID  pgtype.Int4         `json:"quality_inspection_id"`
	PurchaseOrderID      pgtype.Int4         `json:"purchase_order_id"`
	StockTransactionID   pgtype.Int4         `json:"stock_transaction_id"`
	SampleQuantity       pgtype.Numeric      `json:"sample_quantity"`
	SampleUnitID         pgtype.Int4         `json:"sample_unit_id"`
	ContainerType        pgtype.Text         `json:"container_type"`
	ContainerCount       pgtype.Int4         `json:"container_count"`
	StorageLocation      pgtype.Text         `json:"storage_location"`
	StorageConditions    pgtype.Text         `json:"storage_conditions"`
	CollectedBy          pgtype.Int4         `json:"collected_by"`
	CollectionDate       pgtype.Timestamptz  `json:"collection_date"`
	CollectionMethod     pgtype.Text         `json:"collection_method"`
	SamplingPlan         pgtype.Text         `json:"sampling_plan"`
	ReceivedByLab        pgtype.Int4         `json:"received_by_lab"`
	LabReceivedDate      pgtype.Timestamptz  `json:"lab_received_date"`
	TransferredTo        pgtype.Int4         `json:"transferred_to"`
	TransferDate         pgtype.Timestamptz  `json:"transfer_date"`
	ChainOfCustody       []byte              `json:"chain_of_custody"`
	RetentionRequired    pgtype.Bool         `json:"retention_required"`
	RetentionPeriodDays  pgtype.Int4         `json:"retention_period_days"`
	RetentionExpiryDate  pgtype.Date         `json:"retention_expiry_date"`
	DisposedDate         pgtype.Date         `json:"disposed_date"`
	DisposedBy           pgtype.Int4         `json:"disposed_by"`
	DisposalMethod       pgtype.Text         `json:"disposal_method"`
	IsExternalLab        pgtype.Bool         `json:"is_external_lab"`
	ExternalLabName      pgtype.Text         `json:"external_lab_name"`
	ExternalLabReference pgtype.Text         `json:"external_lab_reference"`
	SentToLabDate        pgtype.Date         `json:"sent_to_lab_date"`
	ExpectedResultsDate  pgtype.Date         `json:"expected_results_date"`
	Attachments          []byte              `json:"attachments"`
	Notes                pgtype.Text         `json:"notes"`
	CreatedAt            pgtype.Timestamptz  `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz  `json:"updated_at"`
	MaterialName         pgtype.Text         `json:"material_name"`
	MaterialSku          pgtype.Text         `json:"material_sku"`
	UnitAbbreviation     pgtype.Text         `json:"unit_abbreviation"`
	CollectedByName      pgtype.Text         `json:"collected_by_name"`
	ReceivedByLabName    pgtype.Text         `json:"received_by_lab_name"`
}

func (q *Queries) GetLabSampleByID(ctx context.Context, id int32) (GetLabSampleByIDRow, error) {
	row := q.db.QueryRow(ctx, getLabSampleByID, id)
	var i GetLabSampleByIDRow
	err := row.Scan(
		&i.ID,
		&i.SampleNumber,
		&i.SampleType,
		&i.SampleStatus,
		&i.MaterialID,
		&i.BatchNumber,
		&i.LotNumber,
		&i.QualityInspectionID,
		&i.PurchaseOrderID,
		&i.StockTransactionID,
		&i.SampleQuantity,
		&i.SampleUnitID,
		&i.ContainerType,
		&i.ContainerCount,
		&i.StorageLocation,
		&i.StorageConditions,
		&i.CollectedBy,
		&i.CollectionDate,
		&i.CollectionMethod,
		&i.SamplingPlan,
		&i.ReceivedByLab,
		&i.LabReceivedDate,
		&i.TransferredTo,
		&i.TransferDate,
		&i.ChainOfCustody,
		&i.RetentionRequired,
		&i.RetentionPeriodDays,
		&i.RetentionExpiryDate,
		&i.DisposedDate,
		&i.DisposedBy,
		&i.DisposalMethod,
		&i.IsExternalLab,
		&i.ExternalLabName,
		&i.ExternalLabReference,
		&i.SentToLabDate,
		&i.ExpectedResultsDate,
		&i.Attachments,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MaterialName,
		&i.MaterialSku,
		&i.UnitAbbreviation,
		&i.CollectedByName,
		&i.ReceivedByLabName,
	)
	return i, err
}

const getLabSampleByNumber = `-- name: GetLabSampleByNumber :one
SELECT id, sample_number, sample_type, sample_status, material_id, batch_number, lot_number, quality_inspection_id, purchase_order_id, stock_transaction_id, sample_quantity, sample_unit_id, container_type, container_count, storage_location, storage_conditions, collected_by, collection_date, collection_method, sampling_plan, received_by_lab, lab_received_date, transferred_to, transfer_date, chain_of_custody, retention_required, retention_period_days, retention_expiry_date, disposed_date, disposed_by, disposal_method, is_external_lab, external_lab_name, external_lab_reference, sent_to_lab_date, expected_results_date, attachments, notes, created_at, updated_at FROM lab_samples
WHERE sample_number = $1
`

func (q *Queries) GetLabSampleByNumber(ctx context.Context, sampleNumber string) (LabSample, error) {
	row := q.db.QueryRow(ctx, getLabSampleByNumber, sampleNumber)
	var i LabSample
	err := row.Scan(
		&i.ID,
		&i.SampleNumber,
		&i.SampleType,
		&i.SampleStatus,
		&i.MaterialID,
		&i.BatchNumber,
		&i.LotNumber,
		&i.QualityInspectionID,
		&i.PurchaseOrderID,
		&i.StockTransactionID,
		&i.SampleQuantity,
		&i.SampleUnitID,
		&i.ContainerType,
		&i.ContainerCount,
		&i.StorageLocation,
		&i.StorageConditions,
		&i.CollectedBy,
		&i.CollectionDate,
		&i.CollectionMethod,
		&i.SamplingPlan,
		&i.ReceivedByLab,
		&i.LabReceivedDate,
		&i.TransferredTo,
		&i.TransferDate,
		&i.ChainOfCustody,
		&i.RetentionRequired,
		&i.RetentionPeriodDays,
		&i.RetentionExpiryDate,
		&i.DisposedDate,
		&i.DisposedBy,
		&i.DisposalMethod,
		&i.IsExternalLab,
		&i.ExternalLabName,
		&i.ExternalLabReference,
		&i.SentToLabDate,
		&i.ExpectedResultsDate,
		&i.Attachments,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLabTestAssignmentByID = `-- name: GetLabTestAssignmentByID :one
SELECT 
    lta.id, lta.sample_id, lta.test_method_id, lta.priority, lta.requested_date, lta.scheduled_date, lta.due_date, lta.assigned_to, lta.assigned_date, lta.started_date, lta.completed_date, lta.status, lta.is_rush, lta.result_value, lta.result_text, lta.result_unit_id, lta.pass_fail, lta.reviewed_by, lta.review_date, lta.review_notes, lta.is_retest, lta.original_test_id, lta.retest_reason, lta.notes, lta.created_at, lta.updated_at,
    ls.sample_number,
    ls.material_id,
    m.name as material_name,
    ls.batch_number,
    ltm.method_code,
    ltm.method_name,
    assigned.full_name as assigned_to_name,
    reviewed.full_name as reviewed_by_name
FROM lab_test_assignments lta
LEFT JOIN lab_samples ls ON lta.sample_id = ls.id
LEFT JOIN materials m ON ls.material_id = m.id
LEFT JOIN lab_test_methods ltm ON lta.test_method_id = ltm.id
LEFT JOIN users assigned ON lta.assigned_to = assigned.id
LEFT JOIN users reviewed ON lta.reviewed_by = reviewed.id
WHERE lta.id = $1
`

type GetLabTestAssignmentByIDRow struct {
	ID             int32                `json:"id"`
	SampleID       int32                `json:"sample_id"`
	TestMethodID   int32                `json:"test_method_id"`
	Priority       pgtype.Int4          `json:"priority"`
	RequestedDate  pgtype.Date          `json:"requested_date"`
	ScheduledDate  pgtype.Date          `json:"scheduled_date"`
	DueDate        pgtype.Date          `json:"due_date"`
	AssignedTo     pgtype.Int4          `json:"assigned_to"`
	AssignedDate   pgtype.Timestamptz   `json:"assigned_date"`
	StartedDate    pgtype.Timestamptz   `json:"started_date"`
	CompletedDate  pgtype.Timestamptz   `json:"completed_date"`
	Status         NullTestResultStatus `json:"status"`
	IsRush         pgtype.Bool          `json:"is_rush"`
	ResultValue    pgtype.Numeric       `json:"result_value"`
	ResultText     pgtype.Text          `json:"result_text"`
	ResultUnitID   pgtype.Int4          `json:"result_unit_id"`
	PassFail       pgtype.Bool          `json:"pass_fail"`
	ReviewedBy     pgtype.Int4          `json:"reviewed_by"`
	ReviewDate     pgtype.Timestamptz   `json:"review_date"`
	ReviewNotes    pgtype.Text          `json:"review_notes"`
	IsRetest       pgtype.Bool          `json:"is_retest"`
	OriginalTestID pgtype.Int4          `json:"original_test_id"`
	RetestReason   pgtype.Text          `json:"retest_reason"`
	Notes          pgtype.Text          `json:"notes"`
	CreatedAt      pgtype.Timestamptz   `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz   `json:"updated_at"`
	SampleNumber   pgtype.Text          `json:"sample_number"`
	MaterialID     pgtype.Int4          `json:"material_id"`
	MaterialName   pgtype.Text          `json:"material_name"`
	BatchNumber    pgtype.Text          `json:"batch_number"`
	MethodCode     pgtype.Text          `json:"method_code"`
	MethodName     pgtype.Text          `json:"method_name"`
	AssignedToName pgtype.Text          `json:"assigned_to_name"`
	ReviewedByName pgtype.Text          `json:"reviewed_by_name"`
}

func (q *Queries) GetLabTestAssignmentByID(ctx context.Context, id int32) (GetLabTestAssignmentByIDRow, error) {
	row := q.db.QueryRow(ctx, getLabTestAssignmentByID, id)
	var i GetLabTestAssignmentByIDRow
	err := row.Scan(
		&i.ID,
		&i.SampleID,
		&i.TestMethodID,
		&i.Priority,
		&i.RequestedDate,
		&i.ScheduledDate,
		&i.DueDate,
		&i.AssignedTo,
		&i.AssignedDate,
		&i.StartedDate,
		&i.CompletedDate,
		&i.Status,
		&i.IsRush,
		&i.ResultValue,
		&i.ResultText,
		&i.ResultUnitID,
		&i.PassFail,
		&i.ReviewedBy,
		&i.ReviewDate,
		&i.ReviewNotes,
		&i.IsRetest,
		&i.OriginalTestID,
		&i.RetestReason,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SampleNumber,
		&i.MaterialID,
		&i.MaterialName,
		&i.BatchNumber,
		&i.MethodCode,
		&i.MethodName,
		&i.AssignedToName,
		&i.ReviewedByName,
	)
	return i, err
}

const getLabTestMethodByCode = `-- name: GetLabTestMethodByCode :one
SELECT id, method_code, method_name, description, standard_reference, standard_organization, test_type, test_category, methodology, sample_size, sample_unit_id, preparation_time, test_duration, required_equipment, specification_limits, version, effective_date, supersedes_method_id, status, approved_by, approval_date, attachments, notes, is_active, created_at, updated_at FROM lab_test_methods
WHERE method_code = $1
`

func (q *Queries) GetLabTestMethodByCode(ctx context.Context, methodCode string) (LabTestMethod, error) {
	row := q.db.QueryRow(ctx, getLabTestMethodByCode, methodCode)
	var i LabTestMethod
	err := row.Scan(
		&i.ID,
		&i.MethodCode,
		&i.MethodName,
		&i.Description,
		&i.StandardReference,
		&i.StandardOrganization,
		&i.TestType,
		&i.TestCategory,
		&i.Methodology,
		&i.SampleSize,
		&i.SampleUnitID,
		&i.PreparationTime,
		&i.TestDuration,
		&i.RequiredEquipment,
		&i.SpecificationLimits,
		&i.Version,
		&i.EffectiveDate,
		&i.SupersedesMethodID,
		&i.Status,
		&i.ApprovedBy,
		&i.ApprovalDate,
		&i.Attachments,
		&i.Notes,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLabTestMethodByID = `-- name: GetLabTestMethodByID :one
SELECT 
    ltm.id, ltm.method_code, ltm.method_name, ltm.description, ltm.standard_reference, ltm.standard_organization, ltm.test_type, ltm.test_category, ltm.methodology, ltm.sample_size, ltm.sample_unit_id, ltm.preparation_time, ltm.test_duration, ltm.required_equipment, ltm.specification_limits, ltm.version, ltm.effective_date, ltm.supersedes_method_id, ltm.status, ltm.approved_by, ltm.approval_date, ltm.attachments, ltm.notes, ltm.is_active, ltm.created_at, ltm.updated_at,
    u.abbreviation as sample_unit_abbreviation,
    app.full_name as approved_by_name
FROM lab_test_methods ltm
LEFT JOIN measure_units u ON ltm.sample_unit_id = u.id
LEFT JOIN users app ON ltm.approved_by = app.id
WHERE ltm.id = $1
`

type GetLabTestMethodByIDRow struct {
	ID                     int32                `json:"id"`
	MethodCode             string               `json:"method_code"`
	MethodName             string               `json:"method_name"`
	Description            pgtype.Text          `json:"description"`
	StandardReference      pgtype.Text          `json:"standard_reference"`
	StandardOrganization   pgtype.Text          `json:"standard_organization"`
	TestType               string               `json:"test_type"`
	TestCategory           pgtype.Text          `json:"test_category"`
	Methodology            pgtype.Text          `json:"methodology"`
	SampleSize             pgtype.Numeric       `json:"sample_size"`
	SampleUnitID           pgtype.Int4          `json:"sample_unit_id"`
	PreparationTime        pgtype.Int4          `json:"preparation_time"`
	TestDuration           pgtype.Int4          `json:"test_duration"`
	RequiredEquipment      []byte               `json:"required_equipment"`
	SpecificationLimits    []byte               `json:"specification_limits"`
	Version                pgtype.Text          `json:"version"`
	EffectiveDate          pgtype.Date          `json:"effective_date"`
	SupersedesMethodID     pgtype.Int4          `json:"supersedes_method_id"`
	Status                 NullTestMethodStatus `json:"status"`
	ApprovedBy             pgtype.Int4          `json:"approved_by"`
	ApprovalDate           pgtype.Date          `json:"approval_date"`
	Attachments            []byte               `json:"attachments"`
	Notes                  pgtype.Text          `json:"notes"`
	IsActive               pgtype.Bool          `json:"is_active"`
	CreatedAt              pgtype.Timestamptz   `json:"created_at"`
	UpdatedAt              pgtype.Timestamptz   `json:"updated_at"`
	SampleUnitAbbreviation pgtype.Text          `json:"sample_unit_abbreviation"`
	ApprovedByName         pgtype.Text          `json:"approved_by_name"`
}

func (q *Queries) GetLabTestMethodByID(ctx context.Context, id int32) (GetLabTestMethodByIDRow, error) {
	row := q.db.QueryRow(ctx, getLabTestMethodByID, id)
	var i GetLabTestMethodByIDRow
	err := row.Scan(
		&i.ID,
		&i.MethodCode,
		&i.MethodName,
		&i.Description,
		&i.StandardReference,
		&i.StandardOrganization,
		&i.TestType,
		&i.TestCategory,
		&i.Methodology,
		&i.SampleSize,
		&i.SampleUnitID,
		&i.PreparationTime,
		&i.TestDuration,
		&i.RequiredEquipment,
		&i.SpecificationLimits,
		&i.Version,
		&i.EffectiveDate,
		&i.SupersedesMethodID,
		&i.Status,
		&i.ApprovedBy,
		&i.ApprovalDate,
		&i.Attachments,
		&i.Notes,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SampleUnitAbbreviation,
		&i.ApprovedByName,
	)
	return i, err
}

const getLabTestResultByID = `-- name: GetLabTestResultByID :one
SELECT 
    ltr.id, ltr.test_assignment_id, ltr.test_date, ltr.analyst_id, ltr.equipment_id, ltr.parameter_name, ltr.result_value, ltr.result_text, ltr.result_unit_id, ltr.specification_min, ltr.specification_max, ltr.specification_target, ltr.is_in_spec, ltr.deviation, ltr.replicate_number, ltr.dilution_factor, ltr.preparation_details, ltr.test_temperature, ltr.test_humidity, ltr.test_conditions, ltr.system_suitability_pass, ltr.blank_value, ltr.reference_standard_value, ltr.raw_data_file, ltr.chromatogram_file, ltr.attachments, ltr.notes, ltr.created_at,
    analyst.full_name as analyst_name,
    le.equipment_code,
    le.equipment_name
FROM lab_test_results ltr
LEFT JOIN users analyst ON ltr.analyst_id = analyst.id
LEFT JOIN lab_equipment le ON ltr.equipment_id = le.id
WHERE ltr.id = $1
`

type GetLabTestResultByIDRow struct {
	ID                     int32              `json:"id"`
	TestAssignmentID       int32              `json:"test_assignment_id"`
	TestDate               pgtype.Timestamptz `json:"test_date"`
	AnalystID              pgtype.Int4        `json:"analyst_id"`
	EquipmentID            pgtype.Int4        `json:"equipment_id"`
	ParameterName          string             `json:"parameter_name"`
	ResultValue            pgtype.Numeric     `json:"result_value"`
	ResultText             pgtype.Text        `json:"result_text"`
	ResultUnitID           pgtype.Int4        `json:"result_unit_id"`
	SpecificationMin       pgtype.Numeric     `json:"specification_min"`
	SpecificationMax       pgtype.Numeric     `json:"specification_max"`
	SpecificationTarget    pgtype.Numeric     `json:"specification_target"`
	IsInSpec               pgtype.Bool        `json:"is_in_spec"`
	Deviation              pgtype.Numeric     `json:"deviation"`
	ReplicateNumber        pgtype.Int4        `json:"replicate_number"`
	DilutionFactor         pgtype.Numeric     `json:"dilution_factor"`
	PreparationDetails     pgtype.Text        `json:"preparation_details"`
	TestTemperature        pgtype.Numeric     `json:"test_temperature"`
	TestHumidity           pgtype.Numeric     `json:"test_humidity"`
	TestConditions         []byte             `json:"test_conditions"`
	SystemSuitabilityPass  pgtype.Bool        `json:"system_suitability_pass"`
	BlankValue             pgtype.Numeric     `json:"blank_value"`
	ReferenceStandardValue pgtype.Numeric     `json:"reference_standard_value"`
	RawDataFile            pgtype.Text        `json:"raw_data_file"`
	ChromatogramFile       pgtype.Text        `json:"chromatogram_file"`
	Attachments            []byte             `json:"attachments"`
	Notes                  pgtype.Text        `json:"notes"`
	CreatedAt              pgtype.Timestamptz `json:"created_at"`
	AnalystName            pgtype.Text        `json:"analyst_name"`
	EquipmentCode          pgtype.Text        `json:"equipment_code"`
	EquipmentName          pgtype.Text        `json:"equipment_name"`
}

func (q *Queries) GetLabTestResultByID(ctx context.Context, id int32) (GetLabTestResultByIDRow, error) {
	row := q.db.QueryRow(ctx, getLabTestResultByID, id)
	var i GetLabTestResultByIDRow
	err := row.Scan(
		&i.ID,
		&i.TestAssignmentID,
		&i.TestDate,
		&i.AnalystID,
		&i.EquipmentID,
		&i.ParameterName,
		&i.ResultValue,
		&i.ResultText,
		&i.ResultUnitID,
		&i.SpecificationMin,
		&i.SpecificationMax,
		&i.SpecificationTarget,
		&i.IsInSpec,
		&i.Deviation,
		&i.ReplicateNumber,
		&i.DilutionFactor,
		&i.PreparationDetails,
		&i.TestTemperature,
		&i.TestHumidity,
		&i.TestConditions,
		&i.SystemSuitabilityPass,
		&i.BlankValue,
		&i.ReferenceStandardValue,
		&i.RawDataFile,
		&i.ChromatogramFile,
		&i.Attachments,
		&i.Notes,
		&i.CreatedAt,
		&i.AnalystName,
		&i.EquipmentCode,
		&i.EquipmentName,
	)
	return i, err
}

const getOOSInvestigationByID = `-- name: GetOOSInvestigationByID :one
SELECT 
    oos.id, oos.oos_number, oos.test_assignment_id, oos.sample_id, oos.ncr_id, oos.oos_description, oos.severity, oos.phase_1_start_date, oos.phase_1_complete_date, oos.phase_1_findings, oos.lab_error_found, oos.lab_error_description, oos.phase_2_required, oos.phase_2_start_date, oos.phase_2_complete_date, oos.phase_2_findings, oos.root_cause, oos.retest_required, oos.retest_completed, oos.retest_results, oos.final_conclusion, oos.corrective_action, oos.preventive_action, oos.batch_disposition, oos.impact_on_other_batches, oos.initiated_by, oos.initiated_date, oos.investigator_id, oos.reviewed_by, oos.approved_by, oos.status, oos.closed_date, oos.notes, oos.attachments, oos.created_at, oos.updated_at,
    ls.sample_number,
    ls.material_id,
    m.name as material_name,
    ls.batch_number,
    init.full_name as initiated_by_name,
    inv.full_name as investigator_name,
    rev.full_name as reviewed_by_name,
    app.full_name as approved_by_name
FROM oos_investigations oos
LEFT JOIN lab_samples ls ON oos.sample_id = ls.id
LEFT JOIN materials m ON ls.material_id = m.id
LEFT JOIN users init ON oos.initiated_by = init.id
LEFT JOIN users inv ON oos.investigator_id = inv.id
LEFT JOIN users rev ON oos.reviewed_by = rev.id
LEFT JOIN users app ON oos.approved_by = app.id
WHERE oos.id = $1
`

type GetOOSInvestigationByIDRow struct {
	ID                   int32              `json:"id"`
	OosNumber            string             `json:"oos_number"`
	TestAssignmentID     int32              `json:"test_assignment_id"`
	SampleID             pgtype.Int4        `json:"sample_id"`
	NcrID                pgtype.Int4        `json:"ncr_id"`
	OosDescription       string             `json:"oos_description"`
	Severity             NullNcrSeverity    `json:"severity"`
	Phase1StartDate      pgtype.Date        `json:"phase_1_start_date"`
	Phase1CompleteDate   pgtype.Date        `json:"phase_1_complete_date"`
	Phase1Findings       pgtype.Text        `json:"phase_1_findings"`
	LabErrorFound        pgtype.Bool        `json:"lab_error_found"`
	LabErrorDescription  pgtype.Text        `json:"lab_error_description"`
	Phase2Required       pgtype.Bool        `json:"phase_2_required"`
	Phase2StartDate      pgtype.Date        `json:"phase_2_start_date"`
	Phase2CompleteDate   pgtype.Date        `json:"phase_2_complete_date"`
	Phase2Findings       pgtype.Text        `json:"phase_2_findings"`
	RootCause            pgtype.Text        `json:"root_cause"`
	RetestRequired       pgtype.Bool        `json:"retest_required"`
	RetestCompleted      pgtype.Bool        `json:"retest_completed"`
	RetestResults        pgtype.Text        `json:"retest_results"`
	FinalConclusion      pgtype.Text        `json:"final_conclusion"`
	CorrectiveAction     pgtype.Text        `json:"corrective_action"`
	PreventiveAction     pgtype.Text        `json:"preventive_action"`
	BatchDisposition     pgtype.Text        `json:"batch_disposition"`
	ImpactOnOtherBatches pgtype.Text        `json:"impact_on_other_batches"`
	InitiatedBy          pgtype.Int4        `json:"initiated_by"`
	InitiatedDate        pgtype.Timestamptz `json:"initiated_date"`
	InvestigatorID       pgtype.Int4        `json:"investigator_id"`
	ReviewedBy           pgtype.Int4        `json:"reviewed_by"`
	ApprovedBy           pgtype.Int4        `json:"approved_by"`
	Status               pgtype.Text        `json:"status"`
	ClosedDate           pgtype.Date        `json:"closed_date"`
	Notes                pgtype.Text        `json:"notes"`
	Attachments          []byte             `json:"attachments"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
	SampleNumber         pgtype.Text        `json:"sample_number"`
	MaterialID           pgtype.Int4        `json:"material_id"`
	MaterialName         pgtype.Text        `json:"material_name"`
	BatchNumber          pgtype.Text        `json:"batch_number"`
	InitiatedByName      pgtype.Text        `json:"initiated_by_name"`
	InvestigatorName     pgtype.Text        `json:"investigator_name"`
	ReviewedByName       pgtype.Text        `json:"reviewed_by_name"`
	ApprovedByName       pgtype.Text        `json:"approved_by_name"`
}

func (q *Queries) GetOOSInvestigationByID(ctx context.Context, id int32) (GetOOSInvestigationByIDRow, error) {
	row := q.db.QueryRow(ctx, getOOSInvestigationByID, id)
	var i GetOOSInvestigationByIDRow
	err := row.Scan(
		&i.ID,
		&i.OosNumber,
		&i.TestAssignmentID,
		&i.SampleID,
		&i.NcrID,
		&i.OosDescription,
		&i.Severity,
		&i.Phase1StartDate,
		&i.Phase1CompleteDate,
		&i.Phase1Findings,
		&i.LabErrorFound,
		&i.LabErrorDescription,
		&i.Phase2Required,
		&i.Phase2StartDate,
		&i.Phase2CompleteDate,
		&i.Phase2Findings,
		&i.RootCause,
		&i.RetestRequired,
		&i.RetestCompleted,
		&i.RetestResults,
		&i.FinalConclusion,
		&i.CorrectiveAction,
		&i.PreventiveAction,
		&i.BatchDisposition,
		&i.ImpactOnOtherBatches,
		&i.InitiatedBy,
		&i.InitiatedDate,
		&i.InvestigatorID,
		&i.ReviewedBy,
		&i.ApprovedBy,
		&i.Status,
		&i.ClosedDate,
		&i.Notes,
		&i.Attachments,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SampleNumber,
		&i.MaterialID,
		&i.MaterialName,
		&i.BatchNumber,
		&i.InitiatedByName,
		&i.InvestigatorName,
		&i.ReviewedByName,
		&i.ApprovedByName,
	)
	return i, err
}

const getOOSInvestigationByNumber = `-- name: GetOOSInvestigationByNumber :one
SELECT id, oos_number, test_assignment_id, sample_id, ncr_id, oos_description, severity, phase_1_start_date, phase_1_complete_date, phase_1_findings, lab_error_found, lab_error_description, phase_2_required, phase_2_start_date, phase_2_complete_date, phase_2_findings, root_cause, retest_required, retest_completed, retest_results, final_conclusion, corrective_action, preventive_action, batch_disposition, impact_on_other_batches, initiated_by, initiated_date, investigator_id, reviewed_by, approved_by, status, closed_date, notes, attachments, created_at, updated_at FROM oos_investigations
WHERE oos_number = $1
`

func (q *Queries) GetOOSInvestigationByNumber(ctx context.Context, oosNumber string) (OosInvestigation, error) {
	row := q.db.QueryRow(ctx, getOOSInvestigationByNumber, oosNumber)
	var i OosInvestigation
	err := row.Scan(
		&i.ID,
		&i.OosNumber,
		&i.TestAssignmentID,
		&i.SampleID,
		&i.NcrID,
		&i.OosDescription,
		&i.Severity,
		&i.Phase1StartDate,
		&i.Phase1CompleteDate,
		&i.Phase1Findings,
		&i.LabErrorFound,
		&i.LabErrorDescription,
		&i.Phase2Required,
		&i.Phase2StartDate,
		&i.Phase2CompleteDate,
		&i.Phase2Findings,
		&i.RootCause,
		&i.RetestRequired,
		&i.RetestCompleted,
		&i.RetestResults,
		&i.FinalConclusion,
		&i.CorrectiveAction,
		&i.PreventiveAction,
		&i.BatchDisposition,
		&i.ImpactOnOtherBatches,
		&i.InitiatedBy,
		&i.InitiatedDate,
		&i.InvestigatorID,
		&i.ReviewedBy,
		&i.ApprovedBy,
		&i.Status,
		&i.ClosedDate,
		&i.Notes,
		&i.Attachments,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getStabilitySampleByID = `-- name: GetStabilitySampleByID :one
SELECT 
    stab_s.id, stab_s.stability_study_id, stab_s.lab_sample_id, stab_s.time_point_months, stab_s.scheduled_pull_date, stab_s.actual_pull_date, stab_s.testing_due_date, stab_s.testing_completed, stab_s.testing_completed_date, stab_s.results_summary, stab_s.all_tests_passed, stab_s.notes, stab_s.created_at, stab_s.updated_at,
    ls.sample_number,
    ss.study_number,
    ss.study_name
FROM stability_samples stab_s
LEFT JOIN lab_samples ls ON stab_s.lab_sample_id = ls.id
LEFT JOIN stability_studies ss ON stab_s.stability_study_id = ss.id
WHERE stab_s.id = $1
`

type GetStabilitySampleByIDRow struct {
	ID                   int32              `json:"id"`
	StabilityStudyID     int32              `json:"stability_study_id"`
	LabSampleID          pgtype.Int4        `json:"lab_sample_id"`
	TimePointMonths      int32              `json:"time_point_months"`
	ScheduledPullDate    pgtype.Date        `json:"scheduled_pull_date"`
	ActualPullDate       pgtype.Date        `json:"actual_pull_date"`
	TestingDueDate       pgtype.Date        `json:"testing_due_date"`
	TestingCompleted     pgtype.Bool        `json:"testing_completed"`
	TestingCompletedDate pgtype.Date        `json:"testing_completed_date"`
	ResultsSummary       []byte             `json:"results_summary"`
	AllTestsPassed       pgtype.Bool        `json:"all_tests_passed"`
	Notes                pgtype.Text        `json:"notes"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
	SampleNumber         pgtype.Text        `json:"sample_number"`
	StudyNumber          pgtype.Text        `json:"study_number"`
	StudyName            pgtype.Text        `json:"study_name"`
}

func (q *Queries) GetStabilitySampleByID(ctx context.Context, id int32) (GetStabilitySampleByIDRow, error) {
	row := q.db.QueryRow(ctx, getStabilitySampleByID, id)
	var i GetStabilitySampleByIDRow
	err := row.Scan(
		&i.ID,
		&i.StabilityStudyID,
		&i.LabSampleID,
		&i.TimePointMonths,
		&i.ScheduledPullDate,
		&i.ActualPullDate,
		&i.TestingDueDate,
		&i.TestingCompleted,
		&i.TestingCompletedDate,
		&i.ResultsSummary,
		&i.AllTestsPassed,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SampleNumber,
		&i.StudyNumber,
		&i.StudyName,
	)
	return i, err
}

const getStabilityStudyByID = `-- name: GetStabilityStudyByID :one
SELECT 
    ss.id, ss.study_number, ss.study_name, ss.material_id, ss.batch_number, ss.study_type, ss.storage_condition, ss.study_duration_months, ss.start_date, ss.expected_end_date, ss.actual_end_date, ss.test_schedule, ss.test_methods, ss.status, ss.results_summary, ss.conclusion, ss.shelf_life_recommendation, ss.protocol_approved_by, ss.protocol_approval_date, ss.report_approved_by, ss.report_approval_date, ss.notes, ss.attachments, ss.created_at, ss.updated_at,
    m.name as material_name,
    m.sku as material_sku,
    prot_app.full_name as protocol_approved_by_name,
    rep_app.full_name as report_approved_by_name
FROM stability_studies ss
LEFT JOIN materials m ON ss.material_id = m.id
LEFT JOIN users prot_app ON ss.protocol_approved_by = prot_app.id
LEFT JOIN users rep_app ON ss.report_approved_by = rep_app.id
WHERE ss.id = $1
`

type GetStabilityStudyByIDRow struct {
	ID                      int32              `json:"id"`
	StudyNumber             string             `json:"study_number"`
	StudyName               string             `json:"study_name"`
	MaterialID              int32              `json:"material_id"`
	BatchNumber             string             `json:"batch_number"`
	StudyType               pgtype.Text        `json:"study_type"`
	StorageCondition        string             `json:"storage_condition"`
	StudyDurationMonths     pgtype.Int4        `json:"study_duration_months"`
	StartDate               pgtype.Date        `json:"start_date"`
	ExpectedEndDate         pgtype.Date        `json:"expected_end_date"`
	ActualEndDate           pgtype.Date        `json:"actual_end_date"`
	TestSchedule            []byte             `json:"test_schedule"`
	TestMethods             []byte             `json:"test_methods"`
	Status                  pgtype.Text        `json:"status"`
	ResultsSummary          pgtype.Text        `json:"results_summary"`
	Conclusion              pgtype.Text        `json:"conclusion"`
	ShelfLifeRecommendation pgtype.Int4        `json:"shelf_life_recommendation"`
	ProtocolApprovedBy      pgtype.Int4        `json:"protocol_approved_by"`
	ProtocolApprovalDate    pgtype.Date        `json:"protocol_approval_date"`
	ReportApprovedBy        pgtype.Int4        `json:"report_approved_by"`
	ReportApprovalDate      pgtype.Date        `json:"report_approval_date"`
	Notes                   pgtype.Text        `json:"notes"`
	Attachments             []byte             `json:"attachments"`
	CreatedAt               pgtype.Timestamptz `json:"created_at"`
	UpdatedAt               pgtype.Timestamptz `json:"updated_at"`
	MaterialName            pgtype.Text        `json:"material_name"`
	MaterialSku             pgtype.Text        `json:"material_sku"`
	ProtocolApprovedByName  pgtype.Text        `json:"protocol_approved_by_name"`
	ReportApprovedByName    pgtype.Text        `json:"report_approved_by_name"`
}

func (q *Queries) GetStabilityStudyByID(ctx context.Context, id int32) (GetStabilityStudyByIDRow, error) {
	row := q.db.QueryRow(ctx, getStabilityStudyByID, id)
	var i GetStabilityStudyByIDRow
	err := row.Scan(
		&i.ID,
		&i.StudyNumber,
		&i.StudyName,
		&i.MaterialID,
		&i.BatchNumber,
		&i.StudyType,
		&i.StorageCondition,
		&i.StudyDurationMonths,
		&i.StartDate,
		&i.ExpectedEndDate,
		&i.ActualEndDate,
		&i.TestSchedule,
		&i.TestMethods,
		&i.Status,
		&i.ResultsSummary,
		&i.Conclusion,
		&i.ShelfLifeRecommendation,
		&i.ProtocolApprovedBy,
		&i.ProtocolApprovalDate,
		&i.ReportApprovedBy,
		&i.ReportApprovalDate,
		&i.Notes,
		&i.Attachments,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MaterialName,
		&i.MaterialSku,
		&i.ProtocolApprovedByName,
		&i.ReportApprovedByName,
	)
	return i, err
}

const getStabilityStudyByNumber = `-- name: GetStabilityStudyByNumber :one
SELECT id, study_number, study_name, material_id, batch_number, study_type, storage_condition, study_duration_months, start_date, expected_end_date, actual_end_date, test_schedule, test_methods, status, results_summary, conclusion, shelf_life_recommendation, protocol_approved_by, protocol_approval_date, report_approved_by, report_approval_date, notes, attachments, created_at, updated_at FROM stability_studies
WHERE study_number = $1
`

func (q *Queries) GetStabilityStudyByNumber(ctx context.Context, studyNumber string) (StabilityStudy, error) {
	row := q.db.QueryRow(ctx, getStabilityStudyByNumber, studyNumber)
	var i StabilityStudy
	err := row.Scan(
		&i.ID,
		&i.StudyNumber,
		&i.StudyName,
		&i.MaterialID,
		&i.BatchNumber,
		&i.StudyType,
		&i.StorageCondition,
		&i.StudyDurationMonths,
		&i.StartDate,
		&i.ExpectedEndDate,
		&i.ActualEndDate,
		&i.TestSchedule,
		&i.TestMethods,
		&i.Status,
		&i.ResultsSummary,
		&i.Conclusion,
		&i.ShelfLifeRecommendation,
		&i.ProtocolApprovedBy,
		&i.ProtocolApprovalDate,
		&i.ReportApprovedBy,
		&i.ReportApprovalDate,
		&i.Notes,
		&i.Attachments,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listActiveStabilityStudies = `-- name: ListActiveStabilityStudies :many
SELECT id, study_number, study_name, material_id, batch_number, study_type, storage_condition, study_duration_months, start_date, expected_end_date, actual_end_date, test_schedule, test_methods, status, results_summary, conclusion, shelf_life_recommendation, protocol_approved_by, protocol_approval_date, report_approved_by, report_approval_date, notes, attachments, created_at, updated_at FROM stability_studies
WHERE status = 'active'
ORDER BY start_date
`

func (q *Queries) ListActiveStabilityStudies(ctx context.Context) ([]StabilityStudy, error) {
	rows, err := q.db.Query(ctx, listActiveStabilityStudies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []StabilityStudy{}
	for rows.Next() {
		var i StabilityStudy
		if err := rows.Scan(
			&i.ID,
			&i.StudyNumber,
			&i.StudyName,
			&i.MaterialID,
			&i.BatchNumber,
			&i.StudyType,
			&i.StorageCondition,
			&i.StudyDurationMonths,
			&i.StartDate,
			&i.ExpectedEndDate,
			&i.ActualEndDate,
			&i.TestSchedule,
			&i.TestMethods,
			&i.Status,
			&i.ResultsSummary,
			&i.Conclusion,
			&i.ShelfLifeRecommendation,
			&i.ProtocolApprovedBy,
			&i.ProtocolApprovalDate,
			&i.ReportApprovedBy,
			&i.ReportApprovalDate,
			&i.Notes,
			&i.Attachments,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAnalystQualifications = `-- name: ListAnalystQualifications :many
SELECT 
    aq.id, aq.analyst_id, aq.test_method_id, aq.qualification_date, aq.qualified_by, aq.expiry_date, aq.training_completed, aq.training_date, aq.training_hours, aq.assessment_score, aq.assessment_notes, aq.is_active, aq.requalification_required, aq.notes, aq.created_at, aq.updated_at,
    analyst.full_name as analyst_name,
    ltm.method_code,
    ltm.method_name
FROM analyst_qualifications aq
LEFT JOIN users analyst ON aq.analyst_id = analyst.id
LEFT JOIN lab_test_methods ltm ON aq.test_method_id = ltm.id
WHERE aq.analyst_id = $1
ORDER BY aq.qualification_date DESC
`

type ListAnalystQualificationsRow struct {
	ID                      int32              `json:"id"`
	AnalystID               int32              `json:"analyst_id"`
	TestMethodID            int32              `json:"test_method_id"`
	QualificationDate       pgtype.Date        `json:"qualification_date"`
	QualifiedBy             pgtype.Int4        `json:"qualified_by"`
	ExpiryDate              pgtype.Date        `json:"expiry_date"`
	TrainingCompleted       pgtype.Bool        `json:"training_completed"`
	TrainingDate            pgtype.Date        `json:"training_date"`
	TrainingHours           pgtype.Numeric     `json:"training_hours"`
	AssessmentScore         pgtype.Numeric     `json:"assessment_score"`
	AssessmentNotes         pgtype.Text        `json:"assessment_notes"`
	IsActive                pgtype.Bool        `json:"is_active"`
	RequalificationRequired pgtype.Bool        `json:"requalification_required"`
	Notes                   pgtype.Text        `json:"notes"`
	CreatedAt               pgtype.Timestamptz `json:"created_at"`
	UpdatedAt               pgtype.Timestamptz `json:"updated_at"`
	AnalystName             pgtype.Text        `json:"analyst_name"`
	MethodCode              pgtype.Text        `json:"method_code"`
	MethodName              pgtype.Text        `json:"method_name"`
}

func (q *Queries) ListAnalystQualifications(ctx context.Context, analystID int32) ([]ListAnalystQualificationsRow, error) {
	rows, err := q.db.Query(ctx, listAnalystQualifications, analystID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAnalystQualificationsRow{}
	for rows.Next() {
		var i ListAnalystQualificationsRow
		if err := rows.Scan(
			&i.ID,
			&i.AnalystID,
			&i.TestMethodID,
			&i.QualificationDate,
			&i.QualifiedBy,
			&i.ExpiryDate,
			&i.TrainingCompleted,
			&i.TrainingDate,
			&i.TrainingHours,
			&i.AssessmentScore,
			&i.AssessmentNotes,
			&i.IsActive,
			&i.RequalificationRequired,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AnalystName,
			&i.MethodCode,
			&i.MethodName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCertificatesOfAnalysis = `-- name: ListCertificatesOfAnalysis :many
SELECT 
    coa.id, coa.coa_number, coa.status,
    coa.material_id, m.name as material_name,
    coa.batch_number, coa.issue_date,
    cust.name as customer_name,
    coa.created_at
FROM certificates_of_analysis coa
LEFT JOIN materials m ON coa.material_id = m.id
LEFT JOIN customers cust ON coa.customer_id = cust.id
ORDER BY coa.created_at DESC
LIMIT $1 OFFSET $2
`

type ListCertificatesOfAnalysisParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListCertificatesOfAnalysisRow struct {
	ID           int32              `json:"id"`
	CoaNumber    string             `json:"coa_number"`
	Status       NullCoaStatus      `json:"status"`
	MaterialID   int32              `json:"material_id"`
	MaterialName pgtype.Text        `json:"material_name"`
	BatchNumber  string             `json:"batch_number"`
	IssueDate    pgtype.Date        `json:"issue_date"`
	CustomerName pgtype.Text        `json:"customer_name"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) ListCertificatesOfAnalysis(ctx context.Context, arg ListCertificatesOfAnalysisParams) ([]ListCertificatesOfAnalysisRow, error) {
	rows, err := q.db.Query(ctx, listCertificatesOfAnalysis, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCertificatesOfAnalysisRow{}
	for rows.Next() {
		var i ListCertificatesOfAnalysisRow
		if err := rows.Scan(
			&i.ID,
			&i.CoaNumber,
			&i.Status,
			&i.MaterialID,
			&i.MaterialName,
			&i.BatchNumber,
			&i.IssueDate,
			&i.CustomerName,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCertificatesOfAnalysisByBatch = `-- name: ListCertificatesOfAnalysisByBatch :many
SELECT id, coa_number, material_id, batch_number, lot_number, quality_inspection_id, manufacture_date, expiry_date, quantity, unit_id, test_results, customer_id, sales_order_id, recipient_name, recipient_address, status, issue_date, prepared_by, prepared_date, reviewed_by, reviewed_date, approved_by, approved_date, digital_signature, signature_timestamp, pdf_file_path, template_used, notes, created_at, updated_at FROM certificates_of_analysis
WHERE batch_number = $1
ORDER BY created_at DESC
`

func (q *Queries) ListCertificatesOfAnalysisByBatch(ctx context.Context, batchNumber string) ([]CertificatesOfAnalysis, error) {
	rows, err := q.db.Query(ctx, listCertificatesOfAnalysisByBatch, batchNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CertificatesOfAnalysis{}
	for rows.Next() {
		var i CertificatesOfAnalysis
		if err := rows.Scan(
			&i.ID,
			&i.CoaNumber,
			&i.MaterialID,
			&i.BatchNumber,
			&i.LotNumber,
			&i.QualityInspectionID,
			&i.ManufactureDate,
			&i.ExpiryDate,
			&i.Quantity,
			&i.UnitID,
			&i.TestResults,
			&i.CustomerID,
			&i.SalesOrderID,
			&i.RecipientName,
			&i.RecipientAddress,
			&i.Status,
			&i.IssueDate,
			&i.PreparedBy,
			&i.PreparedDate,
			&i.ReviewedBy,
			&i.ReviewedDate,
			&i.ApprovedBy,
			&i.ApprovedDate,
			&i.DigitalSignature,
			&i.SignatureTimestamp,
			&i.PdfFilePath,
			&i.TemplateUsed,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCertificatesOfAnalysisByCustomer = `-- name: ListCertificatesOfAnalysisByCustomer :many
SELECT id, coa_number, material_id, batch_number, lot_number, quality_inspection_id, manufacture_date, expiry_date, quantity, unit_id, test_results, customer_id, sales_order_id, recipient_name, recipient_address, status, issue_date, prepared_by, prepared_date, reviewed_by, reviewed_date, approved_by, approved_date, digital_signature, signature_timestamp, pdf_file_path, template_used, notes, created_at, updated_at FROM certificates_of_analysis
WHERE customer_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListCertificatesOfAnalysisByCustomerParams struct {
	CustomerID pgtype.Int4 `json:"customer_id"`
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
}

func (q *Queries) ListCertificatesOfAnalysisByCustomer(ctx context.Context, arg ListCertificatesOfAnalysisByCustomerParams) ([]CertificatesOfAnalysis, error) {
	rows, err := q.db.Query(ctx, listCertificatesOfAnalysisByCustomer, arg.CustomerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CertificatesOfAnalysis{}
	for rows.Next() {
		var i CertificatesOfAnalysis
		if err := rows.Scan(
			&i.ID,
			&i.CoaNumber,
			&i.MaterialID,
			&i.BatchNumber,
			&i.LotNumber,
			&i.QualityInspectionID,
			&i.ManufactureDate,
			&i.ExpiryDate,
			&i.Quantity,
			&i.UnitID,
			&i.TestResults,
			&i.CustomerID,
			&i.SalesOrderID,
			&i.RecipientName,
			&i.RecipientAddress,
			&i.Status,
			&i.IssueDate,
			&i.PreparedBy,
			&i.PreparedDate,
			&i.ReviewedBy,
			&i.ReviewedDate,
			&i.ApprovedBy,
			&i.ApprovedDate,
			&i.DigitalSignature,
			&i.SignatureTimestamp,
			&i.PdfFilePath,
			&i.TemplateUsed,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCertificatesOfAnalysisByMaterial = `-- name: ListCertificatesOfAnalysisByMaterial :many
SELECT id, coa_number, material_id, batch_number, lot_number, quality_inspection_id, manufacture_date, expiry_date, quantity, unit_id, test_results, customer_id, sales_order_id, recipient_name, recipient_address, status, issue_date, prepared_by, prepared_date, reviewed_by, reviewed_date, approved_by, approved_date, digital_signature, signature_timestamp, pdf_file_path, template_used, notes, created_at, updated_at FROM certificates_of_analysis
WHERE material_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListCertificatesOfAnalysisByMaterial(ctx context.Context, materialID int32) ([]CertificatesOfAnalysis, error) {
	rows, err := q.db.Query(ctx, listCertificatesOfAnalysisByMaterial, materialID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CertificatesOfAnalysis{}
	for rows.Next() {
		var i CertificatesOfAnalysis
		if err := rows.Scan(
			&i.ID,
			&i.CoaNumber,
			&i.MaterialID,
			&i.BatchNumber,
			&i.LotNumber,
			&i.QualityInspectionID,
			&i.ManufactureDate,
			&i.ExpiryDate,
			&i.Quantity,
			&i.UnitID,
			&i.TestResults,
			&i.CustomerID,
			&i.SalesOrderID,
			&i.RecipientName,
			&i.RecipientAddress,
			&i.Status,
			&i.IssueDate,
			&i.PreparedBy,
			&i.PreparedDate,
			&i.ReviewedBy,
			&i.ReviewedDate,
			&i.ApprovedBy,
			&i.ApprovedDate,
			&i.DigitalSignature,
			&i.SignatureTimestamp,
			&i.PdfFilePath,
			&i.TemplateUsed,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCertificatesOfAnalysisByStatus = `-- name: ListCertificatesOfAnalysisByStatus :many
SELECT id, coa_number, material_id, batch_number, lot_number, quality_inspection_id, manufacture_date, expiry_date, quantity, unit_id, test_results, customer_id, sales_order_id, recipient_name, recipient_address, status, issue_date, prepared_by, prepared_date, reviewed_by, reviewed_date, approved_by, approved_date, digital_signature, signature_timestamp, pdf_file_path, template_used, notes, created_at, updated_at FROM certificates_of_analysis
WHERE status = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListCertificatesOfAnalysisByStatusParams struct {
	Status NullCoaStatus `json:"status"`
	Limit  int32         `json:"limit"`
	Offset int32         `json:"offset"`
}

func (q *Queries) ListCertificatesOfAnalysisByStatus(ctx context.Context, arg ListCertificatesOfAnalysisByStatusParams) ([]CertificatesOfAnalysis, error) {
	rows, err := q.db.Query(ctx, listCertificatesOfAnalysisByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CertificatesOfAnalysis{}
	for rows.Next() {
		var i CertificatesOfAnalysis
		if err := rows.Scan(
			&i.ID,
			&i.CoaNumber,
			&i.MaterialID,
			&i.BatchNumber,
			&i.LotNumber,
			&i.QualityInspectionID,
			&i.ManufactureDate,
			&i.ExpiryDate,
			&i.Quantity,
			&i.UnitID,
			&i.TestResults,
			&i.CustomerID,
			&i.SalesOrderID,
			&i.RecipientName,
			&i.RecipientAddress,
			&i.Status,
			&i.IssueDate,
			&i.PreparedBy,
			&i.PreparedDate,
			&i.ReviewedBy,
			&i.ReviewedDate,
			&i.ApprovedBy,
			&i.ApprovedDate,
			&i.DigitalSignature,
			&i.SignatureTimestamp,
			&i.PdfFilePath,
			&i.TemplateUsed,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listExpiringQualifications = `-- name: ListExpiringQualifications :many
SELECT 
    aq.id, aq.analyst_id, aq.test_method_id, aq.qualification_date, aq.qualified_by, aq.expiry_date, aq.training_completed, aq.training_date, aq.training_hours, aq.assessment_score, aq.assessment_notes, aq.is_active, aq.requalification_required, aq.notes, aq.created_at, aq.updated_at,
    u.full_name as analyst_name,
    ltm.method_code,
    ltm.method_name
FROM analyst_qualifications aq
LEFT JOIN users u ON aq.analyst_id = u.id
LEFT JOIN lab_test_methods ltm ON aq.test_method_id = ltm.id
WHERE aq.expiry_date <= $1
    AND aq.is_active = TRUE
ORDER BY aq.expiry_date
`

type ListExpiringQualificationsRow struct {
	ID                      int32              `json:"id"`
	AnalystID               int32              `json:"analyst_id"`
	TestMethodID            int32              `json:"test_method_id"`
	QualificationDate       pgtype.Date        `json:"qualification_date"`
	QualifiedBy             pgtype.Int4        `json:"qualified_by"`
	ExpiryDate              pgtype.Date        `json:"expiry_date"`
	TrainingCompleted       pgtype.Bool        `json:"training_completed"`
	TrainingDate            pgtype.Date        `json:"training_date"`
	TrainingHours           pgtype.Numeric     `json:"training_hours"`
	AssessmentScore         pgtype.Numeric     `json:"assessment_score"`
	AssessmentNotes         pgtype.Text        `json:"assessment_notes"`
	IsActive                pgtype.Bool        `json:"is_active"`
	RequalificationRequired pgtype.Bool        `json:"requalification_required"`
	Notes                   pgtype.Text        `json:"notes"`
	CreatedAt               pgtype.Timestamptz `json:"created_at"`
	UpdatedAt               pgtype.Timestamptz `json:"updated_at"`
	AnalystName             pgtype.Text        `json:"analyst_name"`
	MethodCode              pgtype.Text        `json:"method_code"`
	MethodName              pgtype.Text        `json:"method_name"`
}

func (q *Queries) ListExpiringQualifications(ctx context.Context, expiryDate pgtype.Date) ([]ListExpiringQualificationsRow, error) {
	rows, err := q.db.Query(ctx, listExpiringQualifications, expiryDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListExpiringQualificationsRow{}
	for rows.Next() {
		var i ListExpiringQualificationsRow
		if err := rows.Scan(
			&i.ID,
			&i.AnalystID,
			&i.TestMethodID,
			&i.QualificationDate,
			&i.QualifiedBy,
			&i.ExpiryDate,
			&i.TrainingCompleted,
			&i.TrainingDate,
			&i.TrainingHours,
			&i.AssessmentScore,
			&i.AssessmentNotes,
			&i.IsActive,
			&i.RequalificationRequired,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AnalystName,
			&i.MethodCode,
			&i.MethodName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLabEquipment = `-- name: ListLabEquipment :many
SELECT 
    id, equipment_code, equipment_name, equipment_type,
    location, calibration_status, next_calibration_date,
    is_operational, is_qualified
FROM lab_equipment
ORDER BY equipment_code
LIMIT $1 OFFSET $2
`

type ListLabEquipmentParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListLabEquipmentRow struct {
	ID                  int32                 `json:"id"`
	EquipmentCode       string                `json:"equipment_code"`
	EquipmentName       string                `json:"equipment_name"`
	EquipmentType       string                `json:"equipment_type"`
	Location            pgtype.Text           `json:"location"`
	CalibrationStatus   NullCalibrationStatus `json:"calibration_status"`
	NextCalibrationDate pgtype.Date           `json:"next_calibration_date"`
	IsOperational       pgtype.Bool           `json:"is_operational"`
	IsQualified         pgtype.Bool           `json:"is_qualified"`
}

func (q *Queries) ListLabEquipment(ctx context.Context, arg ListLabEquipmentParams) ([]ListLabEquipmentRow, error) {
	rows, err := q.db.Query(ctx, listLabEquipment, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListLabEquipmentRow{}
	for rows.Next() {
		var i ListLabEquipmentRow
		if err := rows.Scan(
			&i.ID,
			&i.EquipmentCode,
			&i.EquipmentName,
			&i.EquipmentType,
			&i.Location,
			&i.CalibrationStatus,
			&i.NextCalibrationDate,
			&i.IsOperational,
			&i.IsQualified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLabEquipmentByCalibrationStatus = `-- name: ListLabEquipmentByCalibrationStatus :many
SELECT id, equipment_code, equipment_name, equipment_type, manufacturer, model_number, serial_number, location, warehouse_id, calibration_frequency_days, last_calibration_date, next_calibration_date, calibration_status, calibration_certificate, last_maintenance_date, next_maintenance_date, maintenance_notes, is_operational, is_qualified, qualification_date, attachments, notes, created_at, updated_at FROM lab_equipment
WHERE calibration_status = $1
ORDER BY next_calibration_date
LIMIT $2 OFFSET $3
`

type ListLabEquipmentByCalibrationStatusParams struct {
	CalibrationStatus NullCalibrationStatus `json:"calibration_status"`
	Limit             int32                 `json:"limit"`
	Offset            int32                 `json:"offset"`
}

func (q *Queries) ListLabEquipmentByCalibrationStatus(ctx context.Context, arg ListLabEquipmentByCalibrationStatusParams) ([]LabEquipment, error) {
	rows, err := q.db.Query(ctx, listLabEquipmentByCalibrationStatus, arg.CalibrationStatus, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LabEquipment{}
	for rows.Next() {
		var i LabEquipment
		if err := rows.Scan(
			&i.ID,
			&i.EquipmentCode,
			&i.EquipmentName,
			&i.EquipmentType,
			&i.Manufacturer,
			&i.ModelNumber,
			&i.SerialNumber,
			&i.Location,
			&i.WarehouseID,
			&i.CalibrationFrequencyDays,
			&i.LastCalibrationDate,
			&i.NextCalibrationDate,
			&i.CalibrationStatus,
			&i.CalibrationCertificate,
			&i.LastMaintenanceDate,
			&i.NextMaintenanceDate,
			&i.MaintenanceNotes,
			&i.IsOperational,
			&i.IsQualified,
			&i.QualificationDate,
			&i.Attachments,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLabEquipmentByType = `-- name: ListLabEquipmentByType :many
SELECT id, equipment_code, equipment_name, equipment_type, manufacturer, model_number, serial_number, location, warehouse_id, calibration_frequency_days, last_calibration_date, next_calibration_date, calibration_status, calibration_certificate, last_maintenance_date, next_maintenance_date, maintenance_notes, is_operational, is_qualified, qualification_date, attachments, notes, created_at, updated_at FROM lab_equipment
WHERE equipment_type = $1
ORDER BY equipment_code
`

func (q *Queries) ListLabEquipmentByType(ctx context.Context, equipmentType string) ([]LabEquipment, error) {
	rows, err := q.db.Query(ctx, listLabEquipmentByType, equipmentType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LabEquipment{}
	for rows.Next() {
		var i LabEquipment
		if err := rows.Scan(
			&i.ID,
			&i.EquipmentCode,
			&i.EquipmentName,
			&i.EquipmentType,
			&i.Manufacturer,
			&i.ModelNumber,
			&i.SerialNumber,
			&i.Location,
			&i.WarehouseID,
			&i.CalibrationFrequencyDays,
			&i.LastCalibrationDate,
			&i.NextCalibrationDate,
			&i.CalibrationStatus,
			&i.CalibrationCertificate,
			&i.LastMaintenanceDate,
			&i.NextMaintenanceDate,
			&i.MaintenanceNotes,
			&i.IsOperational,
			&i.IsQualified,
			&i.QualificationDate,
			&i.Attachments,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLabEquipmentCalibrationDue = `-- name: ListLabEquipmentCalibrationDue :many
SELECT id, equipment_code, equipment_name, equipment_type, manufacturer, model_number, serial_number, location, warehouse_id, calibration_frequency_days, last_calibration_date, next_calibration_date, calibration_status, calibration_certificate, last_maintenance_date, next_maintenance_date, maintenance_notes, is_operational, is_qualified, qualification_date, attachments, notes, created_at, updated_at FROM lab_equipment
WHERE next_calibration_date <= $1
ORDER BY next_calibration_date
`

func (q *Queries) ListLabEquipmentCalibrationDue(ctx context.Context, nextCalibrationDate pgtype.Date) ([]LabEquipment, error) {
	rows, err := q.db.Query(ctx, listLabEquipmentCalibrationDue, nextCalibrationDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LabEquipment{}
	for rows.Next() {
		var i LabEquipment
		if err := rows.Scan(
			&i.ID,
			&i.EquipmentCode,
			&i.EquipmentName,
			&i.EquipmentType,
			&i.Manufacturer,
			&i.ModelNumber,
			&i.SerialNumber,
			&i.Location,
			&i.WarehouseID,
			&i.CalibrationFrequencyDays,
			&i.LastCalibrationDate,
			&i.NextCalibrationDate,
			&i.CalibrationStatus,
			&i.CalibrationCertificate,
			&i.LastMaintenanceDate,
			&i.NextMaintenanceDate,
			&i.MaintenanceNotes,
			&i.IsOperational,
			&i.IsQualified,
			&i.QualificationDate,
			&i.Attachments,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLabSamples = `-- name: ListLabSamples :many
SELECT 
    ls.id, ls.sample_number, ls.sample_type, ls.sample_status,
    ls.material_id, m.name as material_name, m.sku as material_sku,
    ls.batch_number, ls.sample_quantity, u.abbreviation as unit_abbreviation,
    ls.collection_date, ls.storage_location,
    ls.is_external_lab, ls.external_lab_name,
    ls.created_at
FROM lab_samples ls
LEFT JOIN materials m ON ls.material_id = m.id
LEFT JOIN measure_units u ON ls.sample_unit_id = u.id
ORDER BY ls.created_at DESC
LIMIT $1 OFFSET $2
`

type ListLabSamplesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListLabSamplesRow struct {
	ID               int32               `json:"id"`
	SampleNumber     string              `json:"sample_number"`
	SampleType       LabSampleType       `json:"sample_type"`
	SampleStatus     NullLabSampleStatus `json:"sample_status"`
	MaterialID       pgtype.Int4         `json:"material_id"`
	MaterialName     pgtype.Text         `json:"material_name"`
	MaterialSku      pgtype.Text         `json:"material_sku"`
	BatchNumber      pgtype.Text         `json:"batch_number"`
	SampleQuantity   pgtype.Numeric      `json:"sample_quantity"`
	UnitAbbreviation pgtype.Text         `json:"unit_abbreviation"`
	CollectionDate   pgtype.Timestamptz  `json:"collection_date"`
	StorageLocation  pgtype.Text         `json:"storage_location"`
	IsExternalLab    pgtype.Bool         `json:"is_external_lab"`
	ExternalLabName  pgtype.Text         `json:"external_lab_name"`
	CreatedAt        pgtype.Timestamptz  `json:"created_at"`
}

func (q *Queries) ListLabSamples(ctx context.Context, arg ListLabSamplesParams) ([]ListLabSamplesRow, error) {
	rows, err := q.db.Query(ctx, listLabSamples, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListLabSamplesRow{}
	for rows.Next() {
		var i ListLabSamplesRow
		if err := rows.Scan(
			&i.ID,
			&i.SampleNumber,
			&i.SampleType,
			&i.SampleStatus,
			&i.MaterialID,
			&i.MaterialName,
			&i.MaterialSku,
			&i.BatchNumber,
			&i.SampleQuantity,
			&i.UnitAbbreviation,
			&i.CollectionDate,
			&i.StorageLocation,
			&i.IsExternalLab,
			&i.ExternalLabName,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLabSamplesByBatch = `-- name: ListLabSamplesByBatch :many
SELECT id, sample_number, sample_type, sample_status, material_id, batch_number, lot_number, quality_inspection_id, purchase_order_id, stock_transaction_id, sample_quantity, sample_unit_id, container_type, container_count, storage_location, storage_conditions, collected_by, collection_date, collection_method, sampling_plan, received_by_lab, lab_received_date, transferred_to, transfer_date, chain_of_custody, retention_required, retention_period_days, retention_expiry_date, disposed_date, disposed_by, disposal_method, is_external_lab, external_lab_name, external_lab_reference, sent_to_lab_date, expected_results_date, attachments, notes, created_at, updated_at FROM lab_samples
WHERE batch_number = $1
ORDER BY created_at DESC
`

func (q *Queries) ListLabSamplesByBatch(ctx context.Context, batchNumber pgtype.Text) ([]LabSample, error) {
	rows, err := q.db.Query(ctx, listLabSamplesByBatch, batchNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LabSample{}
	for rows.Next() {
		var i LabSample
		if err := rows.Scan(
			&i.ID,
			&i.SampleNumber,
			&i.SampleType,
			&i.SampleStatus,
			&i.MaterialID,
			&i.BatchNumber,
			&i.LotNumber,
			&i.QualityInspectionID,
			&i.PurchaseOrderID,
			&i.StockTransactionID,
			&i.SampleQuantity,
			&i.SampleUnitID,
			&i.ContainerType,
			&i.ContainerCount,
			&i.StorageLocation,
			&i.StorageConditions,
			&i.CollectedBy,
			&i.CollectionDate,
			&i.CollectionMethod,
			&i.SamplingPlan,
			&i.ReceivedByLab,
			&i.LabReceivedDate,
			&i.TransferredTo,
			&i.TransferDate,
			&i.ChainOfCustody,
			&i.RetentionRequired,
			&i.RetentionPeriodDays,
			&i.RetentionExpiryDate,
			&i.DisposedDate,
			&i.DisposedBy,
			&i.DisposalMethod,
			&i.IsExternalLab,
			&i.ExternalLabName,
			&i.ExternalLabReference,
			&i.SentToLabDate,
			&i.ExpectedResultsDate,
			&i.Attachments,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLabSamplesByMaterial = `-- name: ListLabSamplesByMaterial :many
SELECT id, sample_number, sample_type, sample_status, material_id, batch_number, lot_number, quality_inspection_id, purchase_order_id, stock_transaction_id, sample_quantity, sample_unit_id, container_type, container_count, storage_location, storage_conditions, collected_by, collection_date, collection_method, sampling_plan, received_by_lab, lab_received_date, transferred_to, transfer_date, chain_of_custody, retention_required, retention_period_days, retention_expiry_date, disposed_date, disposed_by, disposal_method, is_external_lab, external_lab_name, external_lab_reference, sent_to_lab_date, expected_results_date, attachments, notes, created_at, updated_at FROM lab_samples
WHERE material_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListLabSamplesByMaterial(ctx context.Context, materialID pgtype.Int4) ([]LabSample, error) {
	rows, err := q.db.Query(ctx, listLabSamplesByMaterial, materialID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LabSample{}
	for rows.Next() {
		var i LabSample
		if err := rows.Scan(
			&i.ID,
			&i.SampleNumber,
			&i.SampleType,
			&i.SampleStatus,
			&i.MaterialID,
			&i.BatchNumber,
			&i.LotNumber,
			&i.QualityInspectionID,
			&i.PurchaseOrderID,
			&i.StockTransactionID,
			&i.SampleQuantity,
			&i.SampleUnitID,
			&i.ContainerType,
			&i.ContainerCount,
			&i.StorageLocation,
			&i.StorageConditions,
			&i.CollectedBy,
			&i.CollectionDate,
			&i.CollectionMethod,
			&i.SamplingPlan,
			&i.ReceivedByLab,
			&i.LabReceivedDate,
			&i.TransferredTo,
			&i.TransferDate,
			&i.ChainOfCustody,
			&i.RetentionRequired,
			&i.RetentionPeriodDays,
			&i.RetentionExpiryDate,
			&i.DisposedDate,
			&i.DisposedBy,
			&i.DisposalMethod,
			&i.IsExternalLab,
			&i.ExternalLabName,
			&i.ExternalLabReference,
			&i.SentToLabDate,
			&i.ExpectedResultsDate,
			&i.Attachments,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLabSamplesByStatus = `-- name: ListLabSamplesByStatus :many
SELECT id, sample_number, sample_type, sample_status, material_id, batch_number, lot_number, quality_inspection_id, purchase_order_id, stock_transaction_id, sample_quantity, sample_unit_id, container_type, container_count, storage_location, storage_conditions, collected_by, collection_date, collection_method, sampling_plan, received_by_lab, lab_received_date, transferred_to, transfer_date, chain_of_custody, retention_required, retention_period_days, retention_expiry_date, disposed_date, disposed_by, disposal_method, is_external_lab, external_lab_name, external_lab_reference, sent_to_lab_date, expected_results_date, attachments, notes, created_at, updated_at FROM lab_samples
WHERE sample_status = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListLabSamplesByStatusParams struct {
	SampleStatus NullLabSampleStatus `json:"sample_status"`
	Limit        int32               `json:"limit"`
	Offset       int32               `json:"offset"`
}

func (q *Queries) ListLabSamplesByStatus(ctx context.Context, arg ListLabSamplesByStatusParams) ([]LabSample, error) {
	rows, err := q.db.Query(ctx, listLabSamplesByStatus, arg.SampleStatus, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LabSample{}
	for rows.Next() {
		var i LabSample
		if err := rows.Scan(
			&i.ID,
			&i.SampleNumber,
			&i.SampleType,
			&i.SampleStatus,
			&i.MaterialID,
			&i.BatchNumber,
			&i.LotNumber,
			&i.QualityInspectionID,
			&i.PurchaseOrderID,
			&i.StockTransactionID,
			&i.SampleQuantity,
			&i.SampleUnitID,
			&i.ContainerType,
			&i.ContainerCount,
			&i.StorageLocation,
			&i.StorageConditions,
			&i.CollectedBy,
			&i.CollectionDate,
			&i.CollectionMethod,
			&i.SamplingPlan,
			&i.ReceivedByLab,
			&i.LabReceivedDate,
			&i.TransferredTo,
			&i.TransferDate,
			&i.ChainOfCustody,
			&i.RetentionRequired,
			&i.RetentionPeriodDays,
			&i.RetentionExpiryDate,
			&i.DisposedDate,
			&i.DisposedBy,
			&i.DisposalMethod,
			&i.IsExternalLab,
			&i.ExternalLabName,
			&i.ExternalLabReference,
			&i.SentToLabDate,
			&i.ExpectedResultsDate,
			&i.Attachments,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLabSamplesByType = `-- name: ListLabSamplesByType :many
SELECT id, sample_number, sample_type, sample_status, material_id, batch_number, lot_number, quality_inspection_id, purchase_order_id, stock_transaction_id, sample_quantity, sample_unit_id, container_type, container_count, storage_location, storage_conditions, collected_by, collection_date, collection_method, sampling_plan, received_by_lab, lab_received_date, transferred_to, transfer_date, chain_of_custody, retention_required, retention_period_days, retention_expiry_date, disposed_date, disposed_by, disposal_method, is_external_lab, external_lab_name, external_lab_reference, sent_to_lab_date, expected_results_date, attachments, notes, created_at, updated_at FROM lab_samples
WHERE sample_type = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListLabSamplesByTypeParams struct {
	SampleType LabSampleType `json:"sample_type"`
	Limit      int32         `json:"limit"`
	Offset     int32         `json:"offset"`
}

func (q *Queries) ListLabSamplesByType(ctx context.Context, arg ListLabSamplesByTypeParams) ([]LabSample, error) {
	rows, err := q.db.Query(ctx, listLabSamplesByType, arg.SampleType, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LabSample{}
	for rows.Next() {
		var i LabSample
		if err := rows.Scan(
			&i.ID,
			&i.SampleNumber,
			&i.SampleType,
			&i.SampleStatus,
			&i.MaterialID,
			&i.BatchNumber,
			&i.LotNumber,
			&i.QualityInspectionID,
			&i.PurchaseOrderID,
			&i.StockTransactionID,
			&i.SampleQuantity,
			&i.SampleUnitID,
			&i.ContainerType,
			&i.ContainerCount,
			&i.StorageLocation,
			&i.StorageConditions,
			&i.CollectedBy,
			&i.CollectionDate,
			&i.CollectionMethod,
			&i.SamplingPlan,
			&i.ReceivedByLab,
			&i.LabReceivedDate,
			&i.TransferredTo,
			&i.TransferDate,
			&i.ChainOfCustody,
			&i.RetentionRequired,
			&i.RetentionPeriodDays,
			&i.RetentionExpiryDate,
			&i.DisposedDate,
			&i.DisposedBy,
			&i.DisposalMethod,
			&i.IsExternalLab,
			&i.ExternalLabName,
			&i.ExternalLabReference,
			&i.SentToLabDate,
			&i.ExpectedResultsDate,
			&i.Attachments,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLabSamplesPendingDisposal = `-- name: ListLabSamplesPendingDisposal :many
SELECT id, sample_number, sample_type, sample_status, material_id, batch_number, lot_number, quality_inspection_id, purchase_order_id, stock_transaction_id, sample_quantity, sample_unit_id, container_type, container_count, storage_location, storage_conditions, collected_by, collection_date, collection_method, sampling_plan, received_by_lab, lab_received_date, transferred_to, transfer_date, chain_of_custody, retention_required, retention_period_days, retention_expiry_date, disposed_date, disposed_by, disposal_method, is_external_lab, external_lab_name, external_lab_reference, sent_to_lab_date, expected_results_date, attachments, notes, created_at, updated_at FROM lab_samples
WHERE retention_expiry_date <= $1
    AND sample_status IN ('retained', 'completed')
ORDER BY retention_expiry_date
`

func (q *Queries) ListLabSamplesPendingDisposal(ctx context.Context, retentionExpiryDate pgtype.Date) ([]LabSample, error) {
	rows, err := q.db.Query(ctx, listLabSamplesPendingDisposal, retentionExpiryDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LabSample{}
	for rows.Next() {
		var i LabSample
		if err := rows.Scan(
			&i.ID,
			&i.SampleNumber,
			&i.SampleType,
			&i.SampleStatus,
			&i.MaterialID,
			&i.BatchNumber,
			&i.LotNumber,
			&i.QualityInspectionID,
			&i.PurchaseOrderID,
			&i.StockTransactionID,
			&i.SampleQuantity,
			&i.SampleUnitID,
			&i.ContainerType,
			&i.ContainerCount,
			&i.StorageLocation,
			&i.StorageConditions,
			&i.CollectedBy,
			&i.CollectionDate,
			&i.CollectionMethod,
			&i.SamplingPlan,
			&i.ReceivedByLab,
			&i.LabReceivedDate,
			&i.TransferredTo,
			&i.TransferDate,
			&i.ChainOfCustody,
			&i.RetentionRequired,
			&i.RetentionPeriodDays,
			&i.RetentionExpiryDate,
			&i.DisposedDate,
			&i.DisposedBy,
			&i.DisposalMethod,
			&i.IsExternalLab,
			&i.ExternalLabName,
			&i.ExternalLabReference,
			&i.SentToLabDate,
			&i.ExpectedResultsDate,
			&i.Attachments,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLabTestAssignments = `-- name: ListLabTestAssignments :many
SELECT 
    lta.id, lta.status, lta.priority, lta.is_rush,
    lta.scheduled_date, lta.due_date,
    ls.sample_number, ls.batch_number,
    m.name as material_name,
    ltm.method_code, ltm.method_name,
    assigned.full_name as assigned_to_name,
    lta.created_at
FROM lab_test_assignments lta
LEFT JOIN lab_samples ls ON lta.sample_id = ls.id
LEFT JOIN materials m ON ls.material_id = m.id
LEFT JOIN lab_test_methods ltm ON lta.test_method_id = ltm.id
LEFT JOIN users assigned ON lta.assigned_to = assigned.id
ORDER BY lta.created_at DESC
LIMIT $1 OFFSET $2
`

type ListLabTestAssignmentsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListLabTestAssignmentsRow struct {
	ID             int32                `json:"id"`
	Status         NullTestResultStatus `json:"status"`
	Priority       pgtype.Int4          `json:"priority"`
	IsRush         pgtype.Bool          `json:"is_rush"`
	ScheduledDate  pgtype.Date          `json:"scheduled_date"`
	DueDate        pgtype.Date          `json:"due_date"`
	SampleNumber   pgtype.Text          `json:"sample_number"`
	BatchNumber    pgtype.Text          `json:"batch_number"`
	MaterialName   pgtype.Text          `json:"material_name"`
	MethodCode     pgtype.Text          `json:"method_code"`
	MethodName     pgtype.Text          `json:"method_name"`
	AssignedToName pgtype.Text          `json:"assigned_to_name"`
	CreatedAt      pgtype.Timestamptz   `json:"created_at"`
}

func (q *Queries) ListLabTestAssignments(ctx context.Context, arg ListLabTestAssignmentsParams) ([]ListLabTestAssignmentsRow, error) {
	rows, err := q.db.Query(ctx, listLabTestAssignments, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListLabTestAssignmentsRow{}
	for rows.Next() {
		var i ListLabTestAssignmentsRow
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.Priority,
			&i.IsRush,
			&i.ScheduledDate,
			&i.DueDate,
			&i.SampleNumber,
			&i.BatchNumber,
			&i.MaterialName,
			&i.MethodCode,
			&i.MethodName,
			&i.AssignedToName,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLabTestAssignmentsByAnalyst = `-- name: ListLabTestAssignmentsByAnalyst :many
SELECT id, sample_id, test_method_id, priority, requested_date, scheduled_date, due_date, assigned_to, assigned_date, started_date, completed_date, status, is_rush, result_value, result_text, result_unit_id, pass_fail, reviewed_by, review_date, review_notes, is_retest, original_test_id, retest_reason, notes, created_at, updated_at FROM lab_test_assignments
WHERE assigned_to = $1 AND status IN ('pending', 'in_progress')
ORDER BY is_rush DESC, priority, due_date
LIMIT $2 OFFSET $3
`

type ListLabTestAssignmentsByAnalystParams struct {
	AssignedTo pgtype.Int4 `json:"assigned_to"`
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
}

func (q *Queries) ListLabTestAssignmentsByAnalyst(ctx context.Context, arg ListLabTestAssignmentsByAnalystParams) ([]LabTestAssignment, error) {
	rows, err := q.db.Query(ctx, listLabTestAssignmentsByAnalyst, arg.AssignedTo, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LabTestAssignment{}
	for rows.Next() {
		var i LabTestAssignment
		if err := rows.Scan(
			&i.ID,
			&i.SampleID,
			&i.TestMethodID,
			&i.Priority,
			&i.RequestedDate,
			&i.ScheduledDate,
			&i.DueDate,
			&i.AssignedTo,
			&i.AssignedDate,
			&i.StartedDate,
			&i.CompletedDate,
			&i.Status,
			&i.IsRush,
			&i.ResultValue,
			&i.ResultText,
			&i.ResultUnitID,
			&i.PassFail,
			&i.ReviewedBy,
			&i.ReviewDate,
			&i.ReviewNotes,
			&i.IsRetest,
			&i.OriginalTestID,
			&i.RetestReason,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLabTestAssignmentsBySample = `-- name: ListLabTestAssignmentsBySample :many
SELECT 
    lta.id, lta.sample_id, lta.test_method_id, lta.priority, lta.requested_date, lta.scheduled_date, lta.due_date, lta.assigned_to, lta.assigned_date, lta.started_date, lta.completed_date, lta.status, lta.is_rush, lta.result_value, lta.result_text, lta.result_unit_id, lta.pass_fail, lta.reviewed_by, lta.review_date, lta.review_notes, lta.is_retest, lta.original_test_id, lta.retest_reason, lta.notes, lta.created_at, lta.updated_at,
    ltm.method_code,
    ltm.method_name,
    assigned.full_name as assigned_to_name
FROM lab_test_assignments lta
LEFT JOIN lab_test_methods ltm ON lta.test_method_id = ltm.id
LEFT JOIN users assigned ON lta.assigned_to = assigned.id
WHERE lta.sample_id = $1
ORDER BY lta.created_at
`

type ListLabTestAssignmentsBySampleRow struct {
	ID             int32                `json:"id"`
	SampleID       int32                `json:"sample_id"`
	TestMethodID   int32                `json:"test_method_id"`
	Priority       pgtype.Int4          `json:"priority"`
	RequestedDate  pgtype.Date          `json:"requested_date"`
	ScheduledDate  pgtype.Date          `json:"scheduled_date"`
	DueDate        pgtype.Date          `json:"due_date"`
	AssignedTo     pgtype.Int4          `json:"assigned_to"`
	AssignedDate   pgtype.Timestamptz   `json:"assigned_date"`
	StartedDate    pgtype.Timestamptz   `json:"started_date"`
	CompletedDate  pgtype.Timestamptz   `json:"completed_date"`
	Status         NullTestResultStatus `json:"status"`
	IsRush         pgtype.Bool          `json:"is_rush"`
	ResultValue    pgtype.Numeric       `json:"result_value"`
	ResultText     pgtype.Text          `json:"result_text"`
	ResultUnitID   pgtype.Int4          `json:"result_unit_id"`
	PassFail       pgtype.Bool          `json:"pass_fail"`
	ReviewedBy     pgtype.Int4          `json:"reviewed_by"`
	ReviewDate     pgtype.Timestamptz   `json:"review_date"`
	ReviewNotes    pgtype.Text          `json:"review_notes"`
	IsRetest       pgtype.Bool          `json:"is_retest"`
	OriginalTestID pgtype.Int4          `json:"original_test_id"`
	RetestReason   pgtype.Text          `json:"retest_reason"`
	Notes          pgtype.Text          `json:"notes"`
	CreatedAt      pgtype.Timestamptz   `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz   `json:"updated_at"`
	MethodCode     pgtype.Text          `json:"method_code"`
	MethodName     pgtype.Text          `json:"method_name"`
	AssignedToName pgtype.Text          `json:"assigned_to_name"`
}

func (q *Queries) ListLabTestAssignmentsBySample(ctx context.Context, sampleID int32) ([]ListLabTestAssignmentsBySampleRow, error) {
	rows, err := q.db.Query(ctx, listLabTestAssignmentsBySample, sampleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListLabTestAssignmentsBySampleRow{}
	for rows.Next() {
		var i ListLabTestAssignmentsBySampleRow
		if err := rows.Scan(
			&i.ID,
			&i.SampleID,
			&i.TestMethodID,
			&i.Priority,
			&i.RequestedDate,
			&i.ScheduledDate,
			&i.DueDate,
			&i.AssignedTo,
			&i.AssignedDate,
			&i.StartedDate,
			&i.CompletedDate,
			&i.Status,
			&i.IsRush,
			&i.ResultValue,
			&i.ResultText,
			&i.ResultUnitID,
			&i.PassFail,
			&i.ReviewedBy,
			&i.ReviewDate,
			&i.ReviewNotes,
			&i.IsRetest,
			&i.OriginalTestID,
			&i.RetestReason,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MethodCode,
			&i.MethodName,
			&i.AssignedToName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLabTestAssignmentsByStatus = `-- name: ListLabTestAssignmentsByStatus :many
SELECT id, sample_id, test_method_id, priority, requested_date, scheduled_date, due_date, assigned_to, assigned_date, started_date, completed_date, status, is_rush, result_value, result_text, result_unit_id, pass_fail, reviewed_by, review_date, review_notes, is_retest, original_test_id, retest_reason, notes, created_at, updated_at FROM lab_test_assignments
WHERE status = $1
ORDER BY priority, due_date
LIMIT $2 OFFSET $3
`

type ListLabTestAssignmentsByStatusParams struct {
	Status NullTestResultStatus `json:"status"`
	Limit  int32                `json:"limit"`
	Offset int32                `json:"offset"`
}

func (q *Queries) ListLabTestAssignmentsByStatus(ctx context.Context, arg ListLabTestAssignmentsByStatusParams) ([]LabTestAssignment, error) {
	rows, err := q.db.Query(ctx, listLabTestAssignmentsByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LabTestAssignment{}
	for rows.Next() {
		var i LabTestAssignment
		if err := rows.Scan(
			&i.ID,
			&i.SampleID,
			&i.TestMethodID,
			&i.Priority,
			&i.RequestedDate,
			&i.ScheduledDate,
			&i.DueDate,
			&i.AssignedTo,
			&i.AssignedDate,
			&i.StartedDate,
			&i.CompletedDate,
			&i.Status,
			&i.IsRush,
			&i.ResultValue,
			&i.ResultText,
			&i.ResultUnitID,
			&i.PassFail,
			&i.ReviewedBy,
			&i.ReviewDate,
			&i.ReviewNotes,
			&i.IsRetest,
			&i.OriginalTestID,
			&i.RetestReason,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLabTestMethods = `-- name: ListLabTestMethods :many
SELECT 
    id, method_code, method_name, test_type, test_category,
    standard_reference, version, status, is_active
FROM lab_test_methods
WHERE is_active = TRUE
ORDER BY method_code
LIMIT $1 OFFSET $2
`

type ListLabTestMethodsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListLabTestMethodsRow struct {
	ID                int32                `json:"id"`
	MethodCode        string               `json:"method_code"`
	MethodName        string               `json:"method_name"`
	TestType          string               `json:"test_type"`
	TestCategory      pgtype.Text          `json:"test_category"`
	StandardReference pgtype.Text          `json:"standard_reference"`
	Version           pgtype.Text          `json:"version"`
	Status            NullTestMethodStatus `json:"status"`
	IsActive          pgtype.Bool          `json:"is_active"`
}

func (q *Queries) ListLabTestMethods(ctx context.Context, arg ListLabTestMethodsParams) ([]ListLabTestMethodsRow, error) {
	rows, err := q.db.Query(ctx, listLabTestMethods, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListLabTestMethodsRow{}
	for rows.Next() {
		var i ListLabTestMethodsRow
		if err := rows.Scan(
			&i.ID,
			&i.MethodCode,
			&i.MethodName,
			&i.TestType,
			&i.TestCategory,
			&i.StandardReference,
			&i.Version,
			&i.Status,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLabTestMethodsByStatus = `-- name: ListLabTestMethodsByStatus :many
SELECT id, method_code, method_name, description, standard_reference, standard_organization, test_type, test_category, methodology, sample_size, sample_unit_id, preparation_time, test_duration, required_equipment, specification_limits, version, effective_date, supersedes_method_id, status, approved_by, approval_date, attachments, notes, is_active, created_at, updated_at FROM lab_test_methods
WHERE status = $1
ORDER BY method_code
LIMIT $2 OFFSET $3
`

type ListLabTestMethodsByStatusParams struct {
	Status NullTestMethodStatus `json:"status"`
	Limit  int32                `json:"limit"`
	Offset int32                `json:"offset"`
}

func (q *Queries) ListLabTestMethodsByStatus(ctx context.Context, arg ListLabTestMethodsByStatusParams) ([]LabTestMethod, error) {
	rows, err := q.db.Query(ctx, listLabTestMethodsByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LabTestMethod{}
	for rows.Next() {
		var i LabTestMethod
		if err := rows.Scan(
			&i.ID,
			&i.MethodCode,
			&i.MethodName,
			&i.Description,
			&i.StandardReference,
			&i.StandardOrganization,
			&i.TestType,
			&i.TestCategory,
			&i.Methodology,
			&i.SampleSize,
			&i.SampleUnitID,
			&i.PreparationTime,
			&i.TestDuration,
			&i.RequiredEquipment,
			&i.SpecificationLimits,
			&i.Version,
			&i.EffectiveDate,
			&i.SupersedesMethodID,
			&i.Status,
			&i.ApprovedBy,
			&i.ApprovalDate,
			&i.Attachments,
			&i.Notes,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLabTestMethodsByType = `-- name: ListLabTestMethodsByType :many
SELECT id, method_code, method_name, description, standard_reference, standard_organization, test_type, test_category, methodology, sample_size, sample_unit_id, preparation_time, test_duration, required_equipment, specification_limits, version, effective_date, supersedes_method_id, status, approved_by, approval_date, attachments, notes, is_active, created_at, updated_at FROM lab_test_methods
WHERE test_type = $1 AND is_active = TRUE
ORDER BY method_code
`

func (q *Queries) ListLabTestMethodsByType(ctx context.Context, testType string) ([]LabTestMethod, error) {
	rows, err := q.db.Query(ctx, listLabTestMethodsByType, testType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LabTestMethod{}
	for rows.Next() {
		var i LabTestMethod
		if err := rows.Scan(
			&i.ID,
			&i.MethodCode,
			&i.MethodName,
			&i.Description,
			&i.StandardReference,
			&i.StandardOrganization,
			&i.TestType,
			&i.TestCategory,
			&i.Methodology,
			&i.SampleSize,
			&i.SampleUnitID,
			&i.PreparationTime,
			&i.TestDuration,
			&i.RequiredEquipment,
			&i.SpecificationLimits,
			&i.Version,
			&i.EffectiveDate,
			&i.SupersedesMethodID,
			&i.Status,
			&i.ApprovedBy,
			&i.ApprovalDate,
			&i.Attachments,
			&i.Notes,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLabTestResults = `-- name: ListLabTestResults :many
SELECT 
    ltr.id, ltr.test_assignment_id, ltr.test_date, ltr.analyst_id, ltr.equipment_id, ltr.parameter_name, ltr.result_value, ltr.result_text, ltr.result_unit_id, ltr.specification_min, ltr.specification_max, ltr.specification_target, ltr.is_in_spec, ltr.deviation, ltr.replicate_number, ltr.dilution_factor, ltr.preparation_details, ltr.test_temperature, ltr.test_humidity, ltr.test_conditions, ltr.system_suitability_pass, ltr.blank_value, ltr.reference_standard_value, ltr.raw_data_file, ltr.chromatogram_file, ltr.attachments, ltr.notes, ltr.created_at,
    analyst.full_name as analyst_name,
    le.equipment_code
FROM lab_test_results ltr
LEFT JOIN users analyst ON ltr.analyst_id = analyst.id
LEFT JOIN lab_equipment le ON ltr.equipment_id = le.id
WHERE ltr.test_assignment_id = $1
ORDER BY ltr.replicate_number, ltr.created_at
`

type ListLabTestResultsRow struct {
	ID                     int32              `json:"id"`
	TestAssignmentID       int32              `json:"test_assignment_id"`
	TestDate               pgtype.Timestamptz `json:"test_date"`
	AnalystID              pgtype.Int4        `json:"analyst_id"`
	EquipmentID            pgtype.Int4        `json:"equipment_id"`
	ParameterName          string             `json:"parameter_name"`
	ResultValue            pgtype.Numeric     `json:"result_value"`
	ResultText             pgtype.Text        `json:"result_text"`
	ResultUnitID           pgtype.Int4        `json:"result_unit_id"`
	SpecificationMin       pgtype.Numeric     `json:"specification_min"`
	SpecificationMax       pgtype.Numeric     `json:"specification_max"`
	SpecificationTarget    pgtype.Numeric     `json:"specification_target"`
	IsInSpec               pgtype.Bool        `json:"is_in_spec"`
	Deviation              pgtype.Numeric     `json:"deviation"`
	ReplicateNumber        pgtype.Int4        `json:"replicate_number"`
	DilutionFactor         pgtype.Numeric     `json:"dilution_factor"`
	PreparationDetails     pgtype.Text        `json:"preparation_details"`
	TestTemperature        pgtype.Numeric     `json:"test_temperature"`
	TestHumidity           pgtype.Numeric     `json:"test_humidity"`
	TestConditions         []byte             `json:"test_conditions"`
	SystemSuitabilityPass  pgtype.Bool        `json:"system_suitability_pass"`
	BlankValue             pgtype.Numeric     `json:"blank_value"`
	ReferenceStandardValue pgtype.Numeric     `json:"reference_standard_value"`
	RawDataFile            pgtype.Text        `json:"raw_data_file"`
	ChromatogramFile       pgtype.Text        `json:"chromatogram_file"`
	Attachments            []byte             `json:"attachments"`
	Notes                  pgtype.Text        `json:"notes"`
	CreatedAt              pgtype.Timestamptz `json:"created_at"`
	AnalystName            pgtype.Text        `json:"analyst_name"`
	EquipmentCode          pgtype.Text        `json:"equipment_code"`
}

func (q *Queries) ListLabTestResults(ctx context.Context, testAssignmentID int32) ([]ListLabTestResultsRow, error) {
	rows, err := q.db.Query(ctx, listLabTestResults, testAssignmentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListLabTestResultsRow{}
	for rows.Next() {
		var i ListLabTestResultsRow
		if err := rows.Scan(
			&i.ID,
			&i.TestAssignmentID,
			&i.TestDate,
			&i.AnalystID,
			&i.EquipmentID,
			&i.ParameterName,
			&i.ResultValue,
			&i.ResultText,
			&i.ResultUnitID,
			&i.SpecificationMin,
			&i.SpecificationMax,
			&i.SpecificationTarget,
			&i.IsInSpec,
			&i.Deviation,
			&i.ReplicateNumber,
			&i.DilutionFactor,
			&i.PreparationDetails,
			&i.TestTemperature,
			&i.TestHumidity,
			&i.TestConditions,
			&i.SystemSuitabilityPass,
			&i.BlankValue,
			&i.ReferenceStandardValue,
			&i.RawDataFile,
			&i.ChromatogramFile,
			&i.Attachments,
			&i.Notes,
			&i.CreatedAt,
			&i.AnalystName,
			&i.EquipmentCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLabTestResultsByAnalyst = `-- name: ListLabTestResultsByAnalyst :many
SELECT id, test_assignment_id, test_date, analyst_id, equipment_id, parameter_name, result_value, result_text, result_unit_id, specification_min, specification_max, specification_target, is_in_spec, deviation, replicate_number, dilution_factor, preparation_details, test_temperature, test_humidity, test_conditions, system_suitability_pass, blank_value, reference_standard_value, raw_data_file, chromatogram_file, attachments, notes, created_at FROM lab_test_results
WHERE analyst_id = $1
ORDER BY test_date DESC
LIMIT $2 OFFSET $3
`

type ListLabTestResultsByAnalystParams struct {
	AnalystID pgtype.Int4 `json:"analyst_id"`
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
}

func (q *Queries) ListLabTestResultsByAnalyst(ctx context.Context, arg ListLabTestResultsByAnalystParams) ([]LabTestResult, error) {
	rows, err := q.db.Query(ctx, listLabTestResultsByAnalyst, arg.AnalystID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LabTestResult{}
	for rows.Next() {
		var i LabTestResult
		if err := rows.Scan(
			&i.ID,
			&i.TestAssignmentID,
			&i.TestDate,
			&i.AnalystID,
			&i.EquipmentID,
			&i.ParameterName,
			&i.ResultValue,
			&i.ResultText,
			&i.ResultUnitID,
			&i.SpecificationMin,
			&i.SpecificationMax,
			&i.SpecificationTarget,
			&i.IsInSpec,
			&i.Deviation,
			&i.ReplicateNumber,
			&i.DilutionFactor,
			&i.PreparationDetails,
			&i.TestTemperature,
			&i.TestHumidity,
			&i.TestConditions,
			&i.SystemSuitabilityPass,
			&i.BlankValue,
			&i.ReferenceStandardValue,
			&i.RawDataFile,
			&i.ChromatogramFile,
			&i.Attachments,
			&i.Notes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLabTestResultsOutOfSpec = `-- name: ListLabTestResultsOutOfSpec :many
SELECT 
    ltr.id, ltr.test_assignment_id, ltr.test_date, ltr.analyst_id, ltr.equipment_id, ltr.parameter_name, ltr.result_value, ltr.result_text, ltr.result_unit_id, ltr.specification_min, ltr.specification_max, ltr.specification_target, ltr.is_in_spec, ltr.deviation, ltr.replicate_number, ltr.dilution_factor, ltr.preparation_details, ltr.test_temperature, ltr.test_humidity, ltr.test_conditions, ltr.system_suitability_pass, ltr.blank_value, ltr.reference_standard_value, ltr.raw_data_file, ltr.chromatogram_file, ltr.attachments, ltr.notes, ltr.created_at,
    lta.sample_id,
    ls.sample_number,
    ls.batch_number,
    m.name as material_name
FROM lab_test_results ltr
LEFT JOIN lab_test_assignments lta ON ltr.test_assignment_id = lta.id
LEFT JOIN lab_samples ls ON lta.sample_id = ls.id
LEFT JOIN materials m ON ls.material_id = m.id
WHERE ltr.is_in_spec = FALSE
    AND ltr.test_date >= $1
    AND ltr.test_date <= $2
ORDER BY ltr.test_date DESC
`

type ListLabTestResultsOutOfSpecParams struct {
	TestDate   pgtype.Timestamptz `json:"test_date"`
	TestDate_2 pgtype.Timestamptz `json:"test_date_2"`
}

type ListLabTestResultsOutOfSpecRow struct {
	ID                     int32              `json:"id"`
	TestAssignmentID       int32              `json:"test_assignment_id"`
	TestDate               pgtype.Timestamptz `json:"test_date"`
	AnalystID              pgtype.Int4        `json:"analyst_id"`
	EquipmentID            pgtype.Int4        `json:"equipment_id"`
	ParameterName          string             `json:"parameter_name"`
	ResultValue            pgtype.Numeric     `json:"result_value"`
	ResultText             pgtype.Text        `json:"result_text"`
	ResultUnitID           pgtype.Int4        `json:"result_unit_id"`
	SpecificationMin       pgtype.Numeric     `json:"specification_min"`
	SpecificationMax       pgtype.Numeric     `json:"specification_max"`
	SpecificationTarget    pgtype.Numeric     `json:"specification_target"`
	IsInSpec               pgtype.Bool        `json:"is_in_spec"`
	Deviation              pgtype.Numeric     `json:"deviation"`
	ReplicateNumber        pgtype.Int4        `json:"replicate_number"`
	DilutionFactor         pgtype.Numeric     `json:"dilution_factor"`
	PreparationDetails     pgtype.Text        `json:"preparation_details"`
	TestTemperature        pgtype.Numeric     `json:"test_temperature"`
	TestHumidity           pgtype.Numeric     `json:"test_humidity"`
	TestConditions         []byte             `json:"test_conditions"`
	SystemSuitabilityPass  pgtype.Bool        `json:"system_suitability_pass"`
	BlankValue             pgtype.Numeric     `json:"blank_value"`
	ReferenceStandardValue pgtype.Numeric     `json:"reference_standard_value"`
	RawDataFile            pgtype.Text        `json:"raw_data_file"`
	ChromatogramFile       pgtype.Text        `json:"chromatogram_file"`
	Attachments            []byte             `json:"attachments"`
	Notes                  pgtype.Text        `json:"notes"`
	CreatedAt              pgtype.Timestamptz `json:"created_at"`
	SampleID               pgtype.Int4        `json:"sample_id"`
	SampleNumber           pgtype.Text        `json:"sample_number"`
	BatchNumber            pgtype.Text        `json:"batch_number"`
	MaterialName           pgtype.Text        `json:"material_name"`
}

func (q *Queries) ListLabTestResultsOutOfSpec(ctx context.Context, arg ListLabTestResultsOutOfSpecParams) ([]ListLabTestResultsOutOfSpecRow, error) {
	rows, err := q.db.Query(ctx, listLabTestResultsOutOfSpec, arg.TestDate, arg.TestDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListLabTestResultsOutOfSpecRow{}
	for rows.Next() {
		var i ListLabTestResultsOutOfSpecRow
		if err := rows.Scan(
			&i.ID,
			&i.TestAssignmentID,
			&i.TestDate,
			&i.AnalystID,
			&i.EquipmentID,
			&i.ParameterName,
			&i.ResultValue,
			&i.ResultText,
			&i.ResultUnitID,
			&i.SpecificationMin,
			&i.SpecificationMax,
			&i.SpecificationTarget,
			&i.IsInSpec,
			&i.Deviation,
			&i.ReplicateNumber,
			&i.DilutionFactor,
			&i.PreparationDetails,
			&i.TestTemperature,
			&i.TestHumidity,
			&i.TestConditions,
			&i.SystemSuitabilityPass,
			&i.BlankValue,
			&i.ReferenceStandardValue,
			&i.RawDataFile,
			&i.ChromatogramFile,
			&i.Attachments,
			&i.Notes,
			&i.CreatedAt,
			&i.SampleID,
			&i.SampleNumber,
			&i.BatchNumber,
			&i.MaterialName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOOSInvestigations = `-- name: ListOOSInvestigations :many
SELECT 
    oos.id, oos.oos_number, oos.severity, oos.status,
    ls.sample_number, ls.batch_number,
    m.name as material_name,
    oos.initiated_date,
    inv.full_name as investigator_name,
    oos.created_at
FROM oos_investigations oos
LEFT JOIN lab_samples ls ON oos.sample_id = ls.id
LEFT JOIN materials m ON ls.material_id = m.id
LEFT JOIN users inv ON oos.investigator_id = inv.id
ORDER BY oos.created_at DESC
LIMIT $1 OFFSET $2
`

type ListOOSInvestigationsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListOOSInvestigationsRow struct {
	ID               int32              `json:"id"`
	OosNumber        string             `json:"oos_number"`
	Severity         NullNcrSeverity    `json:"severity"`
	Status           pgtype.Text        `json:"status"`
	SampleNumber     pgtype.Text        `json:"sample_number"`
	BatchNumber      pgtype.Text        `json:"batch_number"`
	MaterialName     pgtype.Text        `json:"material_name"`
	InitiatedDate    pgtype.Timestamptz `json:"initiated_date"`
	InvestigatorName pgtype.Text        `json:"investigator_name"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) ListOOSInvestigations(ctx context.Context, arg ListOOSInvestigationsParams) ([]ListOOSInvestigationsRow, error) {
	rows, err := q.db.Query(ctx, listOOSInvestigations, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOOSInvestigationsRow{}
	for rows.Next() {
		var i ListOOSInvestigationsRow
		if err := rows.Scan(
			&i.ID,
			&i.OosNumber,
			&i.Severity,
			&i.Status,
			&i.SampleNumber,
			&i.BatchNumber,
			&i.MaterialName,
			&i.InitiatedDate,
			&i.InvestigatorName,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOOSInvestigationsByStatus = `-- name: ListOOSInvestigationsByStatus :many
SELECT id, oos_number, test_assignment_id, sample_id, ncr_id, oos_description, severity, phase_1_start_date, phase_1_complete_date, phase_1_findings, lab_error_found, lab_error_description, phase_2_required, phase_2_start_date, phase_2_complete_date, phase_2_findings, root_cause, retest_required, retest_completed, retest_results, final_conclusion, corrective_action, preventive_action, batch_disposition, impact_on_other_batches, initiated_by, initiated_date, investigator_id, reviewed_by, approved_by, status, closed_date, notes, attachments, created_at, updated_at FROM oos_investigations
WHERE status = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListOOSInvestigationsByStatusParams struct {
	Status pgtype.Text `json:"status"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

func (q *Queries) ListOOSInvestigationsByStatus(ctx context.Context, arg ListOOSInvestigationsByStatusParams) ([]OosInvestigation, error) {
	rows, err := q.db.Query(ctx, listOOSInvestigationsByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OosInvestigation{}
	for rows.Next() {
		var i OosInvestigation
		if err := rows.Scan(
			&i.ID,
			&i.OosNumber,
			&i.TestAssignmentID,
			&i.SampleID,
			&i.NcrID,
			&i.OosDescription,
			&i.Severity,
			&i.Phase1StartDate,
			&i.Phase1CompleteDate,
			&i.Phase1Findings,
			&i.LabErrorFound,
			&i.LabErrorDescription,
			&i.Phase2Required,
			&i.Phase2StartDate,
			&i.Phase2CompleteDate,
			&i.Phase2Findings,
			&i.RootCause,
			&i.RetestRequired,
			&i.RetestCompleted,
			&i.RetestResults,
			&i.FinalConclusion,
			&i.CorrectiveAction,
			&i.PreventiveAction,
			&i.BatchDisposition,
			&i.ImpactOnOtherBatches,
			&i.InitiatedBy,
			&i.InitiatedDate,
			&i.InvestigatorID,
			&i.ReviewedBy,
			&i.ApprovedBy,
			&i.Status,
			&i.ClosedDate,
			&i.Notes,
			&i.Attachments,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOpenOOSInvestigations = `-- name: ListOpenOOSInvestigations :many
SELECT id, oos_number, test_assignment_id, sample_id, ncr_id, oos_description, severity, phase_1_start_date, phase_1_complete_date, phase_1_findings, lab_error_found, lab_error_description, phase_2_required, phase_2_start_date, phase_2_complete_date, phase_2_findings, root_cause, retest_required, retest_completed, retest_results, final_conclusion, corrective_action, preventive_action, batch_disposition, impact_on_other_batches, initiated_by, initiated_date, investigator_id, reviewed_by, approved_by, status, closed_date, notes, attachments, created_at, updated_at FROM oos_investigations
WHERE status = 'open'
ORDER BY severity DESC, initiated_date ASC
`

func (q *Queries) ListOpenOOSInvestigations(ctx context.Context) ([]OosInvestigation, error) {
	rows, err := q.db.Query(ctx, listOpenOOSInvestigations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OosInvestigation{}
	for rows.Next() {
		var i OosInvestigation
		if err := rows.Scan(
			&i.ID,
			&i.OosNumber,
			&i.TestAssignmentID,
			&i.SampleID,
			&i.NcrID,
			&i.OosDescription,
			&i.Severity,
			&i.Phase1StartDate,
			&i.Phase1CompleteDate,
			&i.Phase1Findings,
			&i.LabErrorFound,
			&i.LabErrorDescription,
			&i.Phase2Required,
			&i.Phase2StartDate,
			&i.Phase2CompleteDate,
			&i.Phase2Findings,
			&i.RootCause,
			&i.RetestRequired,
			&i.RetestCompleted,
			&i.RetestResults,
			&i.FinalConclusion,
			&i.CorrectiveAction,
			&i.PreventiveAction,
			&i.BatchDisposition,
			&i.ImpactOnOtherBatches,
			&i.InitiatedBy,
			&i.InitiatedDate,
			&i.InvestigatorID,
			&i.ReviewedBy,
			&i.ApprovedBy,
			&i.Status,
			&i.ClosedDate,
			&i.Notes,
			&i.Attachments,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOperationalLabEquipment = `-- name: ListOperationalLabEquipment :many
SELECT id, equipment_code, equipment_name, equipment_type, manufacturer, model_number, serial_number, location, warehouse_id, calibration_frequency_days, last_calibration_date, next_calibration_date, calibration_status, calibration_certificate, last_maintenance_date, next_maintenance_date, maintenance_notes, is_operational, is_qualified, qualification_date, attachments, notes, created_at, updated_at FROM lab_equipment
WHERE is_operational = TRUE AND is_qualified = TRUE
ORDER BY equipment_code
`

func (q *Queries) ListOperationalLabEquipment(ctx context.Context) ([]LabEquipment, error) {
	rows, err := q.db.Query(ctx, listOperationalLabEquipment)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LabEquipment{}
	for rows.Next() {
		var i LabEquipment
		if err := rows.Scan(
			&i.ID,
			&i.EquipmentCode,
			&i.EquipmentName,
			&i.EquipmentType,
			&i.Manufacturer,
			&i.ModelNumber,
			&i.SerialNumber,
			&i.Location,
			&i.WarehouseID,
			&i.CalibrationFrequencyDays,
			&i.LastCalibrationDate,
			&i.NextCalibrationDate,
			&i.CalibrationStatus,
			&i.CalibrationCertificate,
			&i.LastMaintenanceDate,
			&i.NextMaintenanceDate,
			&i.MaintenanceNotes,
			&i.IsOperational,
			&i.IsQualified,
			&i.QualificationDate,
			&i.Attachments,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOverdueLabTestAssignments = `-- name: ListOverdueLabTestAssignments :many
SELECT id, sample_id, test_method_id, priority, requested_date, scheduled_date, due_date, assigned_to, assigned_date, started_date, completed_date, status, is_rush, result_value, result_text, result_unit_id, pass_fail, reviewed_by, review_date, review_notes, is_retest, original_test_id, retest_reason, notes, created_at, updated_at FROM lab_test_assignments
WHERE status IN ('pending', 'in_progress')
    AND due_date < CURRENT_DATE
ORDER BY due_date
`

func (q *Queries) ListOverdueLabTestAssignments(ctx context.Context) ([]LabTestAssignment, error) {
	rows, err := q.db.Query(ctx, listOverdueLabTestAssignments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LabTestAssignment{}
	for rows.Next() {
		var i LabTestAssignment
		if err := rows.Scan(
			&i.ID,
			&i.SampleID,
			&i.TestMethodID,
			&i.Priority,
			&i.RequestedDate,
			&i.ScheduledDate,
			&i.DueDate,
			&i.AssignedTo,
			&i.AssignedDate,
			&i.StartedDate,
			&i.CompletedDate,
			&i.Status,
			&i.IsRush,
			&i.ResultValue,
			&i.ResultText,
			&i.ResultUnitID,
			&i.PassFail,
			&i.ReviewedBy,
			&i.ReviewDate,
			&i.ReviewNotes,
			&i.IsRetest,
			&i.OriginalTestID,
			&i.RetestReason,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingLabTestAssignments = `-- name: ListPendingLabTestAssignments :many
SELECT id, sample_id, test_method_id, priority, requested_date, scheduled_date, due_date, assigned_to, assigned_date, started_date, completed_date, status, is_rush, result_value, result_text, result_unit_id, pass_fail, reviewed_by, review_date, review_notes, is_retest, original_test_id, retest_reason, notes, created_at, updated_at FROM lab_test_assignments
WHERE status IN ('pending', 'in_progress')
ORDER BY is_rush DESC, priority, due_date
LIMIT $1 OFFSET $2
`

type ListPendingLabTestAssignmentsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListPendingLabTestAssignments(ctx context.Context, arg ListPendingLabTestAssignmentsParams) ([]LabTestAssignment, error) {
	rows, err := q.db.Query(ctx, listPendingLabTestAssignments, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LabTestAssignment{}
	for rows.Next() {
		var i LabTestAssignment
		if err := rows.Scan(
			&i.ID,
			&i.SampleID,
			&i.TestMethodID,
			&i.Priority,
			&i.RequestedDate,
			&i.ScheduledDate,
			&i.DueDate,
			&i.AssignedTo,
			&i.AssignedDate,
			&i.StartedDate,
			&i.CompletedDate,
			&i.Status,
			&i.IsRush,
			&i.ResultValue,
			&i.ResultText,
			&i.ResultUnitID,
			&i.PassFail,
			&i.ReviewedBy,
			&i.ReviewDate,
			&i.ReviewNotes,
			&i.IsRetest,
			&i.OriginalTestID,
			&i.RetestReason,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQualifiedAnalystsForMethod = `-- name: ListQualifiedAnalystsForMethod :many
SELECT 
    aq.id, aq.analyst_id, aq.test_method_id, aq.qualification_date, aq.qualified_by, aq.expiry_date, aq.training_completed, aq.training_date, aq.training_hours, aq.assessment_score, aq.assessment_notes, aq.is_active, aq.requalification_required, aq.notes, aq.created_at, aq.updated_at,
    u.full_name as analyst_name,
    u.email as analyst_email
FROM analyst_qualifications aq
LEFT JOIN users u ON aq.analyst_id = u.id
WHERE aq.test_method_id = $1
    AND aq.is_active = TRUE
    AND (aq.expiry_date IS NULL OR aq.expiry_date >= CURRENT_DATE)
ORDER BY u.full_name
`

type ListQualifiedAnalystsForMethodRow struct {
	ID                      int32              `json:"id"`
	AnalystID               int32              `json:"analyst_id"`
	TestMethodID            int32              `json:"test_method_id"`
	QualificationDate       pgtype.Date        `json:"qualification_date"`
	QualifiedBy             pgtype.Int4        `json:"qualified_by"`
	ExpiryDate              pgtype.Date        `json:"expiry_date"`
	TrainingCompleted       pgtype.Bool        `json:"training_completed"`
	TrainingDate            pgtype.Date        `json:"training_date"`
	TrainingHours           pgtype.Numeric     `json:"training_hours"`
	AssessmentScore         pgtype.Numeric     `json:"assessment_score"`
	AssessmentNotes         pgtype.Text        `json:"assessment_notes"`
	IsActive                pgtype.Bool        `json:"is_active"`
	RequalificationRequired pgtype.Bool        `json:"requalification_required"`
	Notes                   pgtype.Text        `json:"notes"`
	CreatedAt               pgtype.Timestamptz `json:"created_at"`
	UpdatedAt               pgtype.Timestamptz `json:"updated_at"`
	AnalystName             pgtype.Text        `json:"analyst_name"`
	AnalystEmail            pgtype.Text        `json:"analyst_email"`
}

func (q *Queries) ListQualifiedAnalystsForMethod(ctx context.Context, testMethodID int32) ([]ListQualifiedAnalystsForMethodRow, error) {
	rows, err := q.db.Query(ctx, listQualifiedAnalystsForMethod, testMethodID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListQualifiedAnalystsForMethodRow{}
	for rows.Next() {
		var i ListQualifiedAnalystsForMethodRow
		if err := rows.Scan(
			&i.ID,
			&i.AnalystID,
			&i.TestMethodID,
			&i.QualificationDate,
			&i.QualifiedBy,
			&i.ExpiryDate,
			&i.TrainingCompleted,
			&i.TrainingDate,
			&i.TrainingHours,
			&i.AssessmentScore,
			&i.AssessmentNotes,
			&i.IsActive,
			&i.RequalificationRequired,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AnalystName,
			&i.AnalystEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStabilitySamplesByStudy = `-- name: ListStabilitySamplesByStudy :many
SELECT 
    stab_s.id, stab_s.stability_study_id, stab_s.lab_sample_id, stab_s.time_point_months, stab_s.scheduled_pull_date, stab_s.actual_pull_date, stab_s.testing_due_date, stab_s.testing_completed, stab_s.testing_completed_date, stab_s.results_summary, stab_s.all_tests_passed, stab_s.notes, stab_s.created_at, stab_s.updated_at,
    ls.sample_number
FROM stability_samples stab_s
LEFT JOIN lab_samples ls ON stab_s.lab_sample_id = ls.id
WHERE stab_s.stability_study_id = $1
ORDER BY stab_s.time_point_months
`

type ListStabilitySamplesByStudyRow struct {
	ID                   int32              `json:"id"`
	StabilityStudyID     int32              `json:"stability_study_id"`
	LabSampleID          pgtype.Int4        `json:"lab_sample_id"`
	TimePointMonths      int32              `json:"time_point_months"`
	ScheduledPullDate    pgtype.Date        `json:"scheduled_pull_date"`
	ActualPullDate       pgtype.Date        `json:"actual_pull_date"`
	TestingDueDate       pgtype.Date        `json:"testing_due_date"`
	TestingCompleted     pgtype.Bool        `json:"testing_completed"`
	TestingCompletedDate pgtype.Date        `json:"testing_completed_date"`
	ResultsSummary       []byte             `json:"results_summary"`
	AllTestsPassed       pgtype.Bool        `json:"all_tests_passed"`
	Notes                pgtype.Text        `json:"notes"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
	SampleNumber         pgtype.Text        `json:"sample_number"`
}

func (q *Queries) ListStabilitySamplesByStudy(ctx context.Context, stabilityStudyID int32) ([]ListStabilitySamplesByStudyRow, error) {
	rows, err := q.db.Query(ctx, listStabilitySamplesByStudy, stabilityStudyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListStabilitySamplesByStudyRow{}
	for rows.Next() {
		var i ListStabilitySamplesByStudyRow
		if err := rows.Scan(
			&i.ID,
			&i.StabilityStudyID,
			&i.LabSampleID,
			&i.TimePointMonths,
			&i.ScheduledPullDate,
			&i.ActualPullDate,
			&i.TestingDueDate,
			&i.TestingCompleted,
			&i.TestingCompletedDate,
			&i.ResultsSummary,
			&i.AllTestsPassed,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SampleNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStabilitySamplesDue = `-- name: ListStabilitySamplesDue :many
SELECT 
    stab_s.id, stab_s.stability_study_id, stab_s.lab_sample_id, stab_s.time_point_months, stab_s.scheduled_pull_date, stab_s.actual_pull_date, stab_s.testing_due_date, stab_s.testing_completed, stab_s.testing_completed_date, stab_s.results_summary, stab_s.all_tests_passed, stab_s.notes, stab_s.created_at, stab_s.updated_at,
    ss.study_number,
    ss.study_name,
    ls.sample_number
FROM stability_samples stab_s
LEFT JOIN stability_studies ss ON stab_s.stability_study_id = ss.id
LEFT JOIN lab_samples ls ON stab_s.lab_sample_id = ls.id
WHERE stab_s.scheduled_pull_date <= $1
    AND stab_s.actual_pull_date IS NULL
ORDER BY stab_s.scheduled_pull_date
`

type ListStabilitySamplesDueRow struct {
	ID                   int32              `json:"id"`
	StabilityStudyID     int32              `json:"stability_study_id"`
	LabSampleID          pgtype.Int4        `json:"lab_sample_id"`
	TimePointMonths      int32              `json:"time_point_months"`
	ScheduledPullDate    pgtype.Date        `json:"scheduled_pull_date"`
	ActualPullDate       pgtype.Date        `json:"actual_pull_date"`
	TestingDueDate       pgtype.Date        `json:"testing_due_date"`
	TestingCompleted     pgtype.Bool        `json:"testing_completed"`
	TestingCompletedDate pgtype.Date        `json:"testing_completed_date"`
	ResultsSummary       []byte             `json:"results_summary"`
	AllTestsPassed       pgtype.Bool        `json:"all_tests_passed"`
	Notes                pgtype.Text        `json:"notes"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
	StudyNumber          pgtype.Text        `json:"study_number"`
	StudyName            pgtype.Text        `json:"study_name"`
	SampleNumber         pgtype.Text        `json:"sample_number"`
}

func (q *Queries) ListStabilitySamplesDue(ctx context.Context, scheduledPullDate pgtype.Date) ([]ListStabilitySamplesDueRow, error) {
	rows, err := q.db.Query(ctx, listStabilitySamplesDue, scheduledPullDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListStabilitySamplesDueRow{}
	for rows.Next() {
		var i ListStabilitySamplesDueRow
		if err := rows.Scan(
			&i.ID,
			&i.StabilityStudyID,
			&i.LabSampleID,
			&i.TimePointMonths,
			&i.ScheduledPullDate,
			&i.ActualPullDate,
			&i.TestingDueDate,
			&i.TestingCompleted,
			&i.TestingCompletedDate,
			&i.ResultsSummary,
			&i.AllTestsPassed,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StudyNumber,
			&i.StudyName,
			&i.SampleNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStabilityStudies = `-- name: ListStabilityStudies :many
SELECT 
    ss.id, ss.study_number, ss.study_name,
    ss.material_id, m.name as material_name,
    ss.batch_number, ss.study_type, ss.storage_condition,
    ss.status, ss.start_date, ss.expected_end_date,
    ss.created_at
FROM stability_studies ss
LEFT JOIN materials m ON ss.material_id = m.id
ORDER BY ss.created_at DESC
LIMIT $1 OFFSET $2
`

type ListStabilityStudiesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListStabilityStudiesRow struct {
	ID               int32              `json:"id"`
	StudyNumber      string             `json:"study_number"`
	StudyName        string             `json:"study_name"`
	MaterialID       int32              `json:"material_id"`
	MaterialName     pgtype.Text        `json:"material_name"`
	BatchNumber      string             `json:"batch_number"`
	StudyType        pgtype.Text        `json:"study_type"`
	StorageCondition string             `json:"storage_condition"`
	Status           pgtype.Text        `json:"status"`
	StartDate        pgtype.Date        `json:"start_date"`
	ExpectedEndDate  pgtype.Date        `json:"expected_end_date"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) ListStabilityStudies(ctx context.Context, arg ListStabilityStudiesParams) ([]ListStabilityStudiesRow, error) {
	rows, err := q.db.Query(ctx, listStabilityStudies, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListStabilityStudiesRow{}
	for rows.Next() {
		var i ListStabilityStudiesRow
		if err := rows.Scan(
			&i.ID,
			&i.StudyNumber,
			&i.StudyName,
			&i.MaterialID,
			&i.MaterialName,
			&i.BatchNumber,
			&i.StudyType,
			&i.StorageCondition,
			&i.Status,
			&i.StartDate,
			&i.ExpectedEndDate,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStabilityStudiesByMaterial = `-- name: ListStabilityStudiesByMaterial :many
SELECT id, study_number, study_name, material_id, batch_number, study_type, storage_condition, study_duration_months, start_date, expected_end_date, actual_end_date, test_schedule, test_methods, status, results_summary, conclusion, shelf_life_recommendation, protocol_approved_by, protocol_approval_date, report_approved_by, report_approval_date, notes, attachments, created_at, updated_at FROM stability_studies
WHERE material_id = $1
ORDER BY start_date DESC
`

func (q *Queries) ListStabilityStudiesByMaterial(ctx context.Context, materialID int32) ([]StabilityStudy, error) {
	rows, err := q.db.Query(ctx, listStabilityStudiesByMaterial, materialID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []StabilityStudy{}
	for rows.Next() {
		var i StabilityStudy
		if err := rows.Scan(
			&i.ID,
			&i.StudyNumber,
			&i.StudyName,
			&i.MaterialID,
			&i.BatchNumber,
			&i.StudyType,
			&i.StorageCondition,
			&i.StudyDurationMonths,
			&i.StartDate,
			&i.ExpectedEndDate,
			&i.ActualEndDate,
			&i.TestSchedule,
			&i.TestMethods,
			&i.Status,
			&i.ResultsSummary,
			&i.Conclusion,
			&i.ShelfLifeRecommendation,
			&i.ProtocolApprovedBy,
			&i.ProtocolApprovalDate,
			&i.ReportApprovedBy,
			&i.ReportApprovalDate,
			&i.Notes,
			&i.Attachments,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStabilityStudiesByStatus = `-- name: ListStabilityStudiesByStatus :many
SELECT id, study_number, study_name, material_id, batch_number, study_type, storage_condition, study_duration_months, start_date, expected_end_date, actual_end_date, test_schedule, test_methods, status, results_summary, conclusion, shelf_life_recommendation, protocol_approved_by, protocol_approval_date, report_approved_by, report_approval_date, notes, attachments, created_at, updated_at FROM stability_studies
WHERE status = $1
ORDER BY start_date DESC
LIMIT $2 OFFSET $3
`

type ListStabilityStudiesByStatusParams struct {
	Status pgtype.Text `json:"status"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

func (q *Queries) ListStabilityStudiesByStatus(ctx context.Context, arg ListStabilityStudiesByStatusParams) ([]StabilityStudy, error) {
	rows, err := q.db.Query(ctx, listStabilityStudiesByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []StabilityStudy{}
	for rows.Next() {
		var i StabilityStudy
		if err := rows.Scan(
			&i.ID,
			&i.StudyNumber,
			&i.StudyName,
			&i.MaterialID,
			&i.BatchNumber,
			&i.StudyType,
			&i.StorageCondition,
			&i.StudyDurationMonths,
			&i.StartDate,
			&i.ExpectedEndDate,
			&i.ActualEndDate,
			&i.TestSchedule,
			&i.TestMethods,
			&i.Status,
			&i.ResultsSummary,
			&i.Conclusion,
			&i.ShelfLifeRecommendation,
			&i.ProtocolApprovedBy,
			&i.ProtocolApprovalDate,
			&i.ReportApprovedBy,
			&i.ReportApprovalDate,
			&i.Notes,
			&i.Attachments,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchLabTestMethods = `-- name: SearchLabTestMethods :many
SELECT id, method_code, method_name, description, standard_reference, standard_organization, test_type, test_category, methodology, sample_size, sample_unit_id, preparation_time, test_duration, required_equipment, specification_limits, version, effective_date, supersedes_method_id, status, approved_by, approval_date, attachments, notes, is_active, created_at, updated_at FROM lab_test_methods
WHERE (method_code ILIKE '%' || $1 || '%' OR method_name ILIKE '%' || $1 || '%')
    AND is_active = TRUE
ORDER BY method_code
LIMIT $2 OFFSET $3
`

type SearchLabTestMethodsParams struct {
	Column1 pgtype.Text `json:"column_1"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

func (q *Queries) SearchLabTestMethods(ctx context.Context, arg SearchLabTestMethodsParams) ([]LabTestMethod, error) {
	rows, err := q.db.Query(ctx, searchLabTestMethods, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LabTestMethod{}
	for rows.Next() {
		var i LabTestMethod
		if err := rows.Scan(
			&i.ID,
			&i.MethodCode,
			&i.MethodName,
			&i.Description,
			&i.StandardReference,
			&i.StandardOrganization,
			&i.TestType,
			&i.TestCategory,
			&i.Methodology,
			&i.SampleSize,
			&i.SampleUnitID,
			&i.PreparationTime,
			&i.TestDuration,
			&i.RequiredEquipment,
			&i.SpecificationLimits,
			&i.Version,
			&i.EffectiveDate,
			&i.SupersedesMethodID,
			&i.Status,
			&i.ApprovedBy,
			&i.ApprovalDate,
			&i.Attachments,
			&i.Notes,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAnalystQualification = `-- name: UpdateAnalystQualification :one
UPDATE analyst_qualifications
SET 
    qualification_date = COALESCE($2, qualification_date),
    expiry_date = COALESCE($3, expiry_date),
    is_active = COALESCE($4, is_active),
    requalification_required = COALESCE($5, requalification_required),
    notes = COALESCE($6, notes)
WHERE id = $1
RETURNING id, analyst_id, test_method_id, qualification_date, qualified_by, expiry_date, training_completed, training_date, training_hours, assessment_score, assessment_notes, is_active, requalification_required, notes, created_at, updated_at
`

type UpdateAnalystQualificationParams struct {
	ID                      int32       `json:"id"`
	QualificationDate       pgtype.Date `json:"qualification_date"`
	ExpiryDate              pgtype.Date `json:"expiry_date"`
	IsActive                pgtype.Bool `json:"is_active"`
	RequalificationRequired pgtype.Bool `json:"requalification_required"`
	Notes                   pgtype.Text `json:"notes"`
}

func (q *Queries) UpdateAnalystQualification(ctx context.Context, arg UpdateAnalystQualificationParams) (AnalystQualification, error) {
	row := q.db.QueryRow(ctx, updateAnalystQualification,
		arg.ID,
		arg.QualificationDate,
		arg.ExpiryDate,
		arg.IsActive,
		arg.RequalificationRequired,
		arg.Notes,
	)
	var i AnalystQualification
	err := row.Scan(
		&i.ID,
		&i.AnalystID,
		&i.TestMethodID,
		&i.QualificationDate,
		&i.QualifiedBy,
		&i.ExpiryDate,
		&i.TrainingCompleted,
		&i.TrainingDate,
		&i.TrainingHours,
		&i.AssessmentScore,
		&i.AssessmentNotes,
		&i.IsActive,
		&i.RequalificationRequired,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCertificateOfAnalysis = `-- name: UpdateCertificateOfAnalysis :one
UPDATE certificates_of_analysis
SET 
    status = COALESCE($2, status),
    issue_date = COALESCE($3, issue_date),
    test_results = COALESCE($4, test_results),
    prepared_by = COALESCE($5, prepared_by),
    prepared_date = COALESCE($6, prepared_date),
    reviewed_by = COALESCE($7, reviewed_by),
    reviewed_date = COALESCE($8, reviewed_date),
    approved_by = COALESCE($9, approved_by),
    approved_date = COALESCE($10, approved_date),
    digital_signature = COALESCE($11, digital_signature),
    signature_timestamp = COALESCE($12, signature_timestamp),
    pdf_file_path = COALESCE($13, pdf_file_path),
    notes = COALESCE($14, notes)
WHERE id = $1
RETURNING id, coa_number, material_id, batch_number, lot_number, quality_inspection_id, manufacture_date, expiry_date, quantity, unit_id, test_results, customer_id, sales_order_id, recipient_name, recipient_address, status, issue_date, prepared_by, prepared_date, reviewed_by, reviewed_date, approved_by, approved_date, digital_signature, signature_timestamp, pdf_file_path, template_used, notes, created_at, updated_at
`

type UpdateCertificateOfAnalysisParams struct {
	ID                 int32              `json:"id"`
	Status             NullCoaStatus      `json:"status"`
	IssueDate          pgtype.Date        `json:"issue_date"`
	TestResults        []byte             `json:"test_results"`
	PreparedBy         pgtype.Int4        `json:"prepared_by"`
	PreparedDate       pgtype.Date        `json:"prepared_date"`
	ReviewedBy         pgtype.Int4        `json:"reviewed_by"`
	ReviewedDate       pgtype.Date        `json:"reviewed_date"`
	ApprovedBy         pgtype.Int4        `json:"approved_by"`
	ApprovedDate       pgtype.Date        `json:"approved_date"`
	DigitalSignature   pgtype.Text        `json:"digital_signature"`
	SignatureTimestamp pgtype.Timestamptz `json:"signature_timestamp"`
	PdfFilePath        pgtype.Text        `json:"pdf_file_path"`
	Notes              pgtype.Text        `json:"notes"`
}

func (q *Queries) UpdateCertificateOfAnalysis(ctx context.Context, arg UpdateCertificateOfAnalysisParams) (CertificatesOfAnalysis, error) {
	row := q.db.QueryRow(ctx, updateCertificateOfAnalysis,
		arg.ID,
		arg.Status,
		arg.IssueDate,
		arg.TestResults,
		arg.PreparedBy,
		arg.PreparedDate,
		arg.ReviewedBy,
		arg.ReviewedDate,
		arg.ApprovedBy,
		arg.ApprovedDate,
		arg.DigitalSignature,
		arg.SignatureTimestamp,
		arg.PdfFilePath,
		arg.Notes,
	)
	var i CertificatesOfAnalysis
	err := row.Scan(
		&i.ID,
		&i.CoaNumber,
		&i.MaterialID,
		&i.BatchNumber,
		&i.LotNumber,
		&i.QualityInspectionID,
		&i.ManufactureDate,
		&i.ExpiryDate,
		&i.Quantity,
		&i.UnitID,
		&i.TestResults,
		&i.CustomerID,
		&i.SalesOrderID,
		&i.RecipientName,
		&i.RecipientAddress,
		&i.Status,
		&i.IssueDate,
		&i.PreparedBy,
		&i.PreparedDate,
		&i.ReviewedBy,
		&i.ReviewedDate,
		&i.ApprovedBy,
		&i.ApprovedDate,
		&i.DigitalSignature,
		&i.SignatureTimestamp,
		&i.PdfFilePath,
		&i.TemplateUsed,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateLabEquipment = `-- name: UpdateLabEquipment :one
UPDATE lab_equipment
SET 
    equipment_name = COALESCE($2, equipment_name),
    location = COALESCE($3, location),
    last_calibration_date = COALESCE($4, last_calibration_date),
    next_calibration_date = COALESCE($5, next_calibration_date),
    calibration_certificate = COALESCE($6, calibration_certificate),
    last_maintenance_date = COALESCE($7, last_maintenance_date),
    next_maintenance_date = COALESCE($8, next_maintenance_date),
    maintenance_notes = COALESCE($9, maintenance_notes),
    is_operational = COALESCE($10, is_operational),
    is_qualified = COALESCE($11, is_qualified),
    notes = COALESCE($12, notes)
WHERE id = $1
RETURNING id, equipment_code, equipment_name, equipment_type, manufacturer, model_number, serial_number, location, warehouse_id, calibration_frequency_days, last_calibration_date, next_calibration_date, calibration_status, calibration_certificate, last_maintenance_date, next_maintenance_date, maintenance_notes, is_operational, is_qualified, qualification_date, attachments, notes, created_at, updated_at
`

type UpdateLabEquipmentParams struct {
	ID                     int32       `json:"id"`
	EquipmentName          pgtype.Text `json:"equipment_name"`
	Location               pgtype.Text `json:"location"`
	LastCalibrationDate    pgtype.Date `json:"last_calibration_date"`
	NextCalibrationDate    pgtype.Date `json:"next_calibration_date"`
	CalibrationCertificate pgtype.Text `json:"calibration_certificate"`
	LastMaintenanceDate    pgtype.Date `json:"last_maintenance_date"`
	NextMaintenanceDate    pgtype.Date `json:"next_maintenance_date"`
	MaintenanceNotes       pgtype.Text `json:"maintenance_notes"`
	IsOperational          pgtype.Bool `json:"is_operational"`
	IsQualified            pgtype.Bool `json:"is_qualified"`
	Notes                  pgtype.Text `json:"notes"`
}

func (q *Queries) UpdateLabEquipment(ctx context.Context, arg UpdateLabEquipmentParams) (LabEquipment, error) {
	row := q.db.QueryRow(ctx, updateLabEquipment,
		arg.ID,
		arg.EquipmentName,
		arg.Location,
		arg.LastCalibrationDate,
		arg.NextCalibrationDate,
		arg.CalibrationCertificate,
		arg.LastMaintenanceDate,
		arg.NextMaintenanceDate,
		arg.MaintenanceNotes,
		arg.IsOperational,
		arg.IsQualified,
		arg.Notes,
	)
	var i LabEquipment
	err := row.Scan(
		&i.ID,
		&i.EquipmentCode,
		&i.EquipmentName,
		&i.EquipmentType,
		&i.Manufacturer,
		&i.ModelNumber,
		&i.SerialNumber,
		&i.Location,
		&i.WarehouseID,
		&i.CalibrationFrequencyDays,
		&i.LastCalibrationDate,
		&i.NextCalibrationDate,
		&i.CalibrationStatus,
		&i.CalibrationCertificate,
		&i.LastMaintenanceDate,
		&i.NextMaintenanceDate,
		&i.MaintenanceNotes,
		&i.IsOperational,
		&i.IsQualified,
		&i.QualificationDate,
		&i.Attachments,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateLabSample = `-- name: UpdateLabSample :one
UPDATE lab_samples
SET 
    sample_status = COALESCE($2, sample_status),
    received_by_lab = COALESCE($3, received_by_lab),
    lab_received_date = COALESCE($4, lab_received_date),
    storage_location = COALESCE($5, storage_location),
    disposed_date = COALESCE($6, disposed_date),
    disposed_by = COALESCE($7, disposed_by),
    disposal_method = COALESCE($8, disposal_method),
    notes = COALESCE($9, notes)
WHERE id = $1
RETURNING id, sample_number, sample_type, sample_status, material_id, batch_number, lot_number, quality_inspection_id, purchase_order_id, stock_transaction_id, sample_quantity, sample_unit_id, container_type, container_count, storage_location, storage_conditions, collected_by, collection_date, collection_method, sampling_plan, received_by_lab, lab_received_date, transferred_to, transfer_date, chain_of_custody, retention_required, retention_period_days, retention_expiry_date, disposed_date, disposed_by, disposal_method, is_external_lab, external_lab_name, external_lab_reference, sent_to_lab_date, expected_results_date, attachments, notes, created_at, updated_at
`

type UpdateLabSampleParams struct {
	ID              int32               `json:"id"`
	SampleStatus    NullLabSampleStatus `json:"sample_status"`
	ReceivedByLab   pgtype.Int4         `json:"received_by_lab"`
	LabReceivedDate pgtype.Timestamptz  `json:"lab_received_date"`
	StorageLocation pgtype.Text         `json:"storage_location"`
	DisposedDate    pgtype.Date         `json:"disposed_date"`
	DisposedBy      pgtype.Int4         `json:"disposed_by"`
	DisposalMethod  pgtype.Text         `json:"disposal_method"`
	Notes           pgtype.Text         `json:"notes"`
}

func (q *Queries) UpdateLabSample(ctx context.Context, arg UpdateLabSampleParams) (LabSample, error) {
	row := q.db.QueryRow(ctx, updateLabSample,
		arg.ID,
		arg.SampleStatus,
		arg.ReceivedByLab,
		arg.LabReceivedDate,
		arg.StorageLocation,
		arg.DisposedDate,
		arg.DisposedBy,
		arg.DisposalMethod,
		arg.Notes,
	)
	var i LabSample
	err := row.Scan(
		&i.ID,
		&i.SampleNumber,
		&i.SampleType,
		&i.SampleStatus,
		&i.MaterialID,
		&i.BatchNumber,
		&i.LotNumber,
		&i.QualityInspectionID,
		&i.PurchaseOrderID,
		&i.StockTransactionID,
		&i.SampleQuantity,
		&i.SampleUnitID,
		&i.ContainerType,
		&i.ContainerCount,
		&i.StorageLocation,
		&i.StorageConditions,
		&i.CollectedBy,
		&i.CollectionDate,
		&i.CollectionMethod,
		&i.SamplingPlan,
		&i.ReceivedByLab,
		&i.LabReceivedDate,
		&i.TransferredTo,
		&i.TransferDate,
		&i.ChainOfCustody,
		&i.RetentionRequired,
		&i.RetentionPeriodDays,
		&i.RetentionExpiryDate,
		&i.DisposedDate,
		&i.DisposedBy,
		&i.DisposalMethod,
		&i.IsExternalLab,
		&i.ExternalLabName,
		&i.ExternalLabReference,
		&i.SentToLabDate,
		&i.ExpectedResultsDate,
		&i.Attachments,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateLabTestAssignment = `-- name: UpdateLabTestAssignment :one
UPDATE lab_test_assignments
SET 
    status = COALESCE($2, status),
    assigned_to = COALESCE($3, assigned_to),
    assigned_date = COALESCE($4, assigned_date),
    scheduled_date = COALESCE($5, scheduled_date),
    due_date = COALESCE($6, due_date),
    started_date = COALESCE($7, started_date),
    completed_date = COALESCE($8, completed_date),
    result_value = COALESCE($9, result_value),
    result_text = COALESCE($10, result_text),
    result_unit_id = COALESCE($11, result_unit_id),
    pass_fail = COALESCE($12, pass_fail),
    reviewed_by = COALESCE($13, reviewed_by),
    review_date = COALESCE($14, review_date),
    review_notes = COALESCE($15, review_notes),
    notes = COALESCE($16, notes)
WHERE id = $1
RETURNING id, sample_id, test_method_id, priority, requested_date, scheduled_date, due_date, assigned_to, assigned_date, started_date, completed_date, status, is_rush, result_value, result_text, result_unit_id, pass_fail, reviewed_by, review_date, review_notes, is_retest, original_test_id, retest_reason, notes, created_at, updated_at
`

type UpdateLabTestAssignmentParams struct {
	ID            int32                `json:"id"`
	Status        NullTestResultStatus `json:"status"`
	AssignedTo    pgtype.Int4          `json:"assigned_to"`
	AssignedDate  pgtype.Timestamptz   `json:"assigned_date"`
	ScheduledDate pgtype.Date          `json:"scheduled_date"`
	DueDate       pgtype.Date          `json:"due_date"`
	StartedDate   pgtype.Timestamptz   `json:"started_date"`
	CompletedDate pgtype.Timestamptz   `json:"completed_date"`
	ResultValue   pgtype.Numeric       `json:"result_value"`
	ResultText    pgtype.Text          `json:"result_text"`
	ResultUnitID  pgtype.Int4          `json:"result_unit_id"`
	PassFail      pgtype.Bool          `json:"pass_fail"`
	ReviewedBy    pgtype.Int4          `json:"reviewed_by"`
	ReviewDate    pgtype.Timestamptz   `json:"review_date"`
	ReviewNotes   pgtype.Text          `json:"review_notes"`
	Notes         pgtype.Text          `json:"notes"`
}

func (q *Queries) UpdateLabTestAssignment(ctx context.Context, arg UpdateLabTestAssignmentParams) (LabTestAssignment, error) {
	row := q.db.QueryRow(ctx, updateLabTestAssignment,
		arg.ID,
		arg.Status,
		arg.AssignedTo,
		arg.AssignedDate,
		arg.ScheduledDate,
		arg.DueDate,
		arg.StartedDate,
		arg.CompletedDate,
		arg.ResultValue,
		arg.ResultText,
		arg.ResultUnitID,
		arg.PassFail,
		arg.ReviewedBy,
		arg.ReviewDate,
		arg.ReviewNotes,
		arg.Notes,
	)
	var i LabTestAssignment
	err := row.Scan(
		&i.ID,
		&i.SampleID,
		&i.TestMethodID,
		&i.Priority,
		&i.RequestedDate,
		&i.ScheduledDate,
		&i.DueDate,
		&i.AssignedTo,
		&i.AssignedDate,
		&i.StartedDate,
		&i.CompletedDate,
		&i.Status,
		&i.IsRush,
		&i.ResultValue,
		&i.ResultText,
		&i.ResultUnitID,
		&i.PassFail,
		&i.ReviewedBy,
		&i.ReviewDate,
		&i.ReviewNotes,
		&i.IsRetest,
		&i.OriginalTestID,
		&i.RetestReason,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateLabTestMethod = `-- name: UpdateLabTestMethod :one
UPDATE lab_test_methods
SET 
    method_name = COALESCE($2, method_name),
    description = COALESCE($3, description),
    standard_reference = COALESCE($4, standard_reference),
    methodology = COALESCE($5, methodology),
    status = COALESCE($6, status),
    approved_by = COALESCE($7, approved_by),
    approval_date = COALESCE($8, approval_date),
    is_active = COALESCE($9, is_active),
    notes = COALESCE($10, notes)
WHERE id = $1
RETURNING id, method_code, method_name, description, standard_reference, standard_organization, test_type, test_category, methodology, sample_size, sample_unit_id, preparation_time, test_duration, required_equipment, specification_limits, version, effective_date, supersedes_method_id, status, approved_by, approval_date, attachments, notes, is_active, created_at, updated_at
`

type UpdateLabTestMethodParams struct {
	ID                int32                `json:"id"`
	MethodName        pgtype.Text          `json:"method_name"`
	Description       pgtype.Text          `json:"description"`
	StandardReference pgtype.Text          `json:"standard_reference"`
	Methodology       pgtype.Text          `json:"methodology"`
	Status            NullTestMethodStatus `json:"status"`
	ApprovedBy        pgtype.Int4          `json:"approved_by"`
	ApprovalDate      pgtype.Date          `json:"approval_date"`
	IsActive          pgtype.Bool          `json:"is_active"`
	Notes             pgtype.Text          `json:"notes"`
}

func (q *Queries) UpdateLabTestMethod(ctx context.Context, arg UpdateLabTestMethodParams) (LabTestMethod, error) {
	row := q.db.QueryRow(ctx, updateLabTestMethod,
		arg.ID,
		arg.MethodName,
		arg.Description,
		arg.StandardReference,
		arg.Methodology,
		arg.Status,
		arg.ApprovedBy,
		arg.ApprovalDate,
		arg.IsActive,
		arg.Notes,
	)
	var i LabTestMethod
	err := row.Scan(
		&i.ID,
		&i.MethodCode,
		&i.MethodName,
		&i.Description,
		&i.StandardReference,
		&i.StandardOrganization,
		&i.TestType,
		&i.TestCategory,
		&i.Methodology,
		&i.SampleSize,
		&i.SampleUnitID,
		&i.PreparationTime,
		&i.TestDuration,
		&i.RequiredEquipment,
		&i.SpecificationLimits,
		&i.Version,
		&i.EffectiveDate,
		&i.SupersedesMethodID,
		&i.Status,
		&i.ApprovedBy,
		&i.ApprovalDate,
		&i.Attachments,
		&i.Notes,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateOOSInvestigation = `-- name: UpdateOOSInvestigation :one
UPDATE oos_investigations
SET 
    status = COALESCE($2, status),
    investigator_id = COALESCE($3, investigator_id),
    phase_1_start_date = COALESCE($4, phase_1_start_date),
    phase_1_complete_date = COALESCE($5, phase_1_complete_date),
    phase_1_findings = COALESCE($6, phase_1_findings),
    lab_error_found = COALESCE($7, lab_error_found),
    lab_error_description = COALESCE($8, lab_error_description),
    phase_2_required = COALESCE($9, phase_2_required),
    phase_2_start_date = COALESCE($10, phase_2_start_date),
    phase_2_complete_date = COALESCE($11, phase_2_complete_date),
    phase_2_findings = COALESCE($12, phase_2_findings),
    root_cause = COALESCE($13, root_cause),
    final_conclusion = COALESCE($14, final_conclusion),
    corrective_action = COALESCE($15, corrective_action),
    preventive_action = COALESCE($16, preventive_action),
    batch_disposition = COALESCE($17, batch_disposition),
    reviewed_by = COALESCE($18, reviewed_by),
    approved_by = COALESCE($19, approved_by),
    closed_date = COALESCE($20, closed_date),
    notes = COALESCE($21, notes)
WHERE id = $1
RETURNING id, oos_number, test_assignment_id, sample_id, ncr_id, oos_description, severity, phase_1_start_date, phase_1_complete_date, phase_1_findings, lab_error_found, lab_error_description, phase_2_required, phase_2_start_date, phase_2_complete_date, phase_2_findings, root_cause, retest_required, retest_completed, retest_results, final_conclusion, corrective_action, preventive_action, batch_disposition, impact_on_other_batches, initiated_by, initiated_date, investigator_id, reviewed_by, approved_by, status, closed_date, notes, attachments, created_at, updated_at
`

type UpdateOOSInvestigationParams struct {
	ID                  int32       `json:"id"`
	Status              pgtype.Text `json:"status"`
	InvestigatorID      pgtype.Int4 `json:"investigator_id"`
	Phase1StartDate     pgtype.Date `json:"phase_1_start_date"`
	Phase1CompleteDate  pgtype.Date `json:"phase_1_complete_date"`
	Phase1Findings      pgtype.Text `json:"phase_1_findings"`
	LabErrorFound       pgtype.Bool `json:"lab_error_found"`
	LabErrorDescription pgtype.Text `json:"lab_error_description"`
	Phase2Required      pgtype.Bool `json:"phase_2_required"`
	Phase2StartDate     pgtype.Date `json:"phase_2_start_date"`
	Phase2CompleteDate  pgtype.Date `json:"phase_2_complete_date"`
	Phase2Findings      pgtype.Text `json:"phase_2_findings"`
	RootCause           pgtype.Text `json:"root_cause"`
	FinalConclusion     pgtype.Text `json:"final_conclusion"`
	CorrectiveAction    pgtype.Text `json:"corrective_action"`
	PreventiveAction    pgtype.Text `json:"preventive_action"`
	BatchDisposition    pgtype.Text `json:"batch_disposition"`
	ReviewedBy          pgtype.Int4 `json:"reviewed_by"`
	ApprovedBy          pgtype.Int4 `json:"approved_by"`
	ClosedDate          pgtype.Date `json:"closed_date"`
	Notes               pgtype.Text `json:"notes"`
}

func (q *Queries) UpdateOOSInvestigation(ctx context.Context, arg UpdateOOSInvestigationParams) (OosInvestigation, error) {
	row := q.db.QueryRow(ctx, updateOOSInvestigation,
		arg.ID,
		arg.Status,
		arg.InvestigatorID,
		arg.Phase1StartDate,
		arg.Phase1CompleteDate,
		arg.Phase1Findings,
		arg.LabErrorFound,
		arg.LabErrorDescription,
		arg.Phase2Required,
		arg.Phase2StartDate,
		arg.Phase2CompleteDate,
		arg.Phase2Findings,
		arg.RootCause,
		arg.FinalConclusion,
		arg.CorrectiveAction,
		arg.PreventiveAction,
		arg.BatchDisposition,
		arg.ReviewedBy,
		arg.ApprovedBy,
		arg.ClosedDate,
		arg.Notes,
	)
	var i OosInvestigation
	err := row.Scan(
		&i.ID,
		&i.OosNumber,
		&i.TestAssignmentID,
		&i.SampleID,
		&i.NcrID,
		&i.OosDescription,
		&i.Severity,
		&i.Phase1StartDate,
		&i.Phase1CompleteDate,
		&i.Phase1Findings,
		&i.LabErrorFound,
		&i.LabErrorDescription,
		&i.Phase2Required,
		&i.Phase2StartDate,
		&i.Phase2CompleteDate,
		&i.Phase2Findings,
		&i.RootCause,
		&i.RetestRequired,
		&i.RetestCompleted,
		&i.RetestResults,
		&i.FinalConclusion,
		&i.CorrectiveAction,
		&i.PreventiveAction,
		&i.BatchDisposition,
		&i.ImpactOnOtherBatches,
		&i.InitiatedBy,
		&i.InitiatedDate,
		&i.InvestigatorID,
		&i.ReviewedBy,
		&i.ApprovedBy,
		&i.Status,
		&i.ClosedDate,
		&i.Notes,
		&i.Attachments,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateStabilitySample = `-- name: UpdateStabilitySample :one
UPDATE stability_samples
SET 
    actual_pull_date = COALESCE($2, actual_pull_date),
    testing_completed = COALESCE($3, testing_completed),
    testing_completed_date = COALESCE($4, testing_completed_date),
    results_summary = COALESCE($5, results_summary),
    all_tests_passed = COALESCE($6, all_tests_passed),
    notes = COALESCE($7, notes)
WHERE id = $1
RETURNING id, stability_study_id, lab_sample_id, time_point_months, scheduled_pull_date, actual_pull_date, testing_due_date, testing_completed, testing_completed_date, results_summary, all_tests_passed, notes, created_at, updated_at
`

type UpdateStabilitySampleParams struct {
	ID                   int32       `json:"id"`
	ActualPullDate       pgtype.Date `json:"actual_pull_date"`
	TestingCompleted     pgtype.Bool `json:"testing_completed"`
	TestingCompletedDate pgtype.Date `json:"testing_completed_date"`
	ResultsSummary       []byte      `json:"results_summary"`
	AllTestsPassed       pgtype.Bool `json:"all_tests_passed"`
	Notes                pgtype.Text `json:"notes"`
}

func (q *Queries) UpdateStabilitySample(ctx context.Context, arg UpdateStabilitySampleParams) (StabilitySample, error) {
	row := q.db.QueryRow(ctx, updateStabilitySample,
		arg.ID,
		arg.ActualPullDate,
		arg.TestingCompleted,
		arg.TestingCompletedDate,
		arg.ResultsSummary,
		arg.AllTestsPassed,
		arg.Notes,
	)
	var i StabilitySample
	err := row.Scan(
		&i.ID,
		&i.StabilityStudyID,
		&i.LabSampleID,
		&i.TimePointMonths,
		&i.ScheduledPullDate,
		&i.ActualPullDate,
		&i.TestingDueDate,
		&i.TestingCompleted,
		&i.TestingCompletedDate,
		&i.ResultsSummary,
		&i.AllTestsPassed,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateStabilityStudy = `-- name: UpdateStabilityStudy :one
UPDATE stability_studies
SET 
    status = COALESCE($2, status),
    actual_end_date = COALESCE($3, actual_end_date),
    results_summary = COALESCE($4, results_summary),
    conclusion = COALESCE($5, conclusion),
    shelf_life_recommendation = COALESCE($6, shelf_life_recommendation),
    report_approved_by = COALESCE($7, report_approved_by),
    report_approval_date = COALESCE($8, report_approval_date),
    notes = COALESCE($9, notes)
WHERE id = $1
RETURNING id, study_number, study_name, material_id, batch_number, study_type, storage_condition, study_duration_months, start_date, expected_end_date, actual_end_date, test_schedule, test_methods, status, results_summary, conclusion, shelf_life_recommendation, protocol_approved_by, protocol_approval_date, report_approved_by, report_approval_date, notes, attachments, created_at, updated_at
`

type UpdateStabilityStudyParams struct {
	ID                      int32       `json:"id"`
	Status                  pgtype.Text `json:"status"`
	ActualEndDate           pgtype.Date `json:"actual_end_date"`
	ResultsSummary          pgtype.Text `json:"results_summary"`
	Conclusion              pgtype.Text `json:"conclusion"`
	ShelfLifeRecommendation pgtype.Int4 `json:"shelf_life_recommendation"`
	ReportApprovedBy        pgtype.Int4 `json:"report_approved_by"`
	ReportApprovalDate      pgtype.Date `json:"report_approval_date"`
	Notes                   pgtype.Text `json:"notes"`
}

func (q *Queries) UpdateStabilityStudy(ctx context.Context, arg UpdateStabilityStudyParams) (StabilityStudy, error) {
	row := q.db.QueryRow(ctx, updateStabilityStudy,
		arg.ID,
		arg.Status,
		arg.ActualEndDate,
		arg.ResultsSummary,
		arg.Conclusion,
		arg.ShelfLifeRecommendation,
		arg.ReportApprovedBy,
		arg.ReportApprovalDate,
		arg.Notes,
	)
	var i StabilityStudy
	err := row.Scan(
		&i.ID,
		&i.StudyNumber,
		&i.StudyName,
		&i.MaterialID,
		&i.BatchNumber,
		&i.StudyType,
		&i.StorageCondition,
		&i.StudyDurationMonths,
		&i.StartDate,
		&i.ExpectedEndDate,
		&i.ActualEndDate,
		&i.TestSchedule,
		&i.TestMethods,
		&i.Status,
		&i.ResultsSummary,
		&i.Conclusion,
		&i.ShelfLifeRecommendation,
		&i.ProtocolApprovedBy,
		&i.ProtocolApprovalDate,
		&i.ReportApprovedBy,
		&i.ReportApprovalDate,
		&i.Notes,
		&i.Attachments,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
