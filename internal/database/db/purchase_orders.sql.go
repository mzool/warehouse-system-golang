// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: purchase_orders.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countPurchaseOrders = `-- name: CountPurchaseOrders :one
SELECT COUNT(*) AS count
FROM purchase_orders
`

func (q *Queries) CountPurchaseOrders(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countPurchaseOrders)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSearchPurchaseOrders = `-- name: CountSearchPurchaseOrders :one
SELECT COUNT(*) AS count
FROM purchase_orders
WHERE 
    ($1::TEXT IS NULL OR 
     order_number ILIKE '%' || $1 || '%' OR 
     status ILIKE '%' || $1 || '%')
`

func (q *Queries) CountSearchPurchaseOrders(ctx context.Context, query pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, countSearchPurchaseOrders, query)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPurchaseOrder = `-- name: CreatePurchaseOrder :one
INSERT INTO purchase_orders (order_number, supplier_id, order_date, expected_delivery_date, status, total_amount, created_by, approved_by, meta)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, order_number, supplier_id, order_date, expected_delivery_date, status, total_amount, created_by, approved_by, meta, created_at, updated_at
`

type CreatePurchaseOrderParams struct {
	OrderNumber          string             `json:"order_number"`
	SupplierID           pgtype.Int4        `json:"supplier_id"`
	OrderDate            pgtype.Timestamptz `json:"order_date"`
	ExpectedDeliveryDate pgtype.Timestamptz `json:"expected_delivery_date"`
	Status               string             `json:"status"`
	TotalAmount          pgtype.Numeric     `json:"total_amount"`
	CreatedBy            pgtype.Int4        `json:"created_by"`
	ApprovedBy           pgtype.Int4        `json:"approved_by"`
	Meta                 []byte             `json:"meta"`
}

func (q *Queries) CreatePurchaseOrder(ctx context.Context, arg CreatePurchaseOrderParams) (PurchaseOrder, error) {
	row := q.db.QueryRow(ctx, createPurchaseOrder,
		arg.OrderNumber,
		arg.SupplierID,
		arg.OrderDate,
		arg.ExpectedDeliveryDate,
		arg.Status,
		arg.TotalAmount,
		arg.CreatedBy,
		arg.ApprovedBy,
		arg.Meta,
	)
	var i PurchaseOrder
	err := row.Scan(
		&i.ID,
		&i.OrderNumber,
		&i.SupplierID,
		&i.OrderDate,
		&i.ExpectedDeliveryDate,
		&i.Status,
		&i.TotalAmount,
		&i.CreatedBy,
		&i.ApprovedBy,
		&i.Meta,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPurchaseOrderItem = `-- name: CreatePurchaseOrderItem :one
INSERT INTO purchase_order_items (purchase_order_id, material_id, quantity, unit_price, total_price, received_quantity)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, purchase_order_id, material_id, quantity, unit_price, total_price, received_quantity, created_at, updated_at
`

type CreatePurchaseOrderItemParams struct {
	PurchaseOrderID  pgtype.Int4    `json:"purchase_order_id"`
	MaterialID       pgtype.Int4    `json:"material_id"`
	Quantity         pgtype.Numeric `json:"quantity"`
	UnitPrice        pgtype.Numeric `json:"unit_price"`
	TotalPrice       pgtype.Numeric `json:"total_price"`
	ReceivedQuantity pgtype.Numeric `json:"received_quantity"`
}

func (q *Queries) CreatePurchaseOrderItem(ctx context.Context, arg CreatePurchaseOrderItemParams) (PurchaseOrderItem, error) {
	row := q.db.QueryRow(ctx, createPurchaseOrderItem,
		arg.PurchaseOrderID,
		arg.MaterialID,
		arg.Quantity,
		arg.UnitPrice,
		arg.TotalPrice,
		arg.ReceivedQuantity,
	)
	var i PurchaseOrderItem
	err := row.Scan(
		&i.ID,
		&i.PurchaseOrderID,
		&i.MaterialID,
		&i.Quantity,
		&i.UnitPrice,
		&i.TotalPrice,
		&i.ReceivedQuantity,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePurchaseOrder = `-- name: DeletePurchaseOrder :exec
DELETE FROM purchase_orders
WHERE id = $1
`

func (q *Queries) DeletePurchaseOrder(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deletePurchaseOrder, id)
	return err
}

const deletePurchaseOrderItem = `-- name: DeletePurchaseOrderItem :exec
DELETE FROM purchase_order_items
WHERE id = $1
`

func (q *Queries) DeletePurchaseOrderItem(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deletePurchaseOrderItem, id)
	return err
}

const getPurchaseOrderByID = `-- name: GetPurchaseOrderByID :one
SELECT id, order_number, supplier_id, order_date, expected_delivery_date, status, total_amount, created_by, approved_by, meta, created_at, updated_at
FROM purchase_orders
WHERE id = $1
`

func (q *Queries) GetPurchaseOrderByID(ctx context.Context, id int32) (PurchaseOrder, error) {
	row := q.db.QueryRow(ctx, getPurchaseOrderByID, id)
	var i PurchaseOrder
	err := row.Scan(
		&i.ID,
		&i.OrderNumber,
		&i.SupplierID,
		&i.OrderDate,
		&i.ExpectedDeliveryDate,
		&i.Status,
		&i.TotalAmount,
		&i.CreatedBy,
		&i.ApprovedBy,
		&i.Meta,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPurchaseOrderByOrderNumber = `-- name: GetPurchaseOrderByOrderNumber :one
SELECT id, order_number, supplier_id, order_date, expected_delivery_date, status, total_amount, created_by, approved_by, meta, created_at, updated_at
FROM purchase_orders
WHERE order_number = $1
`

func (q *Queries) GetPurchaseOrderByOrderNumber(ctx context.Context, orderNumber string) (PurchaseOrder, error) {
	row := q.db.QueryRow(ctx, getPurchaseOrderByOrderNumber, orderNumber)
	var i PurchaseOrder
	err := row.Scan(
		&i.ID,
		&i.OrderNumber,
		&i.SupplierID,
		&i.OrderDate,
		&i.ExpectedDeliveryDate,
		&i.Status,
		&i.TotalAmount,
		&i.CreatedBy,
		&i.ApprovedBy,
		&i.Meta,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPurchaseOrderItemByID = `-- name: GetPurchaseOrderItemByID :one
SELECT id, purchase_order_id, material_id, quantity, unit_price, total_price, received_quantity, created_at, updated_at
FROM purchase_order_items
WHERE id = $1
`

func (q *Queries) GetPurchaseOrderItemByID(ctx context.Context, id int32) (PurchaseOrderItem, error) {
	row := q.db.QueryRow(ctx, getPurchaseOrderItemByID, id)
	var i PurchaseOrderItem
	err := row.Scan(
		&i.ID,
		&i.PurchaseOrderID,
		&i.MaterialID,
		&i.Quantity,
		&i.UnitPrice,
		&i.TotalPrice,
		&i.ReceivedQuantity,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listPurchaseOrderItems = `-- name: ListPurchaseOrderItems :many
SELECT id, purchase_order_id, material_id, quantity, unit_price, total_price, received_quantity, created_at, updated_at
FROM purchase_order_items
WHERE purchase_order_id = $1
ORDER BY id
`

func (q *Queries) ListPurchaseOrderItems(ctx context.Context, purchaseOrderID pgtype.Int4) ([]PurchaseOrderItem, error) {
	rows, err := q.db.Query(ctx, listPurchaseOrderItems, purchaseOrderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PurchaseOrderItem{}
	for rows.Next() {
		var i PurchaseOrderItem
		if err := rows.Scan(
			&i.ID,
			&i.PurchaseOrderID,
			&i.MaterialID,
			&i.Quantity,
			&i.UnitPrice,
			&i.TotalPrice,
			&i.ReceivedQuantity,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPurchaseOrders = `-- name: ListPurchaseOrders :many
SELECT id, order_number, supplier_id, order_date, expected_delivery_date, status, total_amount, created_by, approved_by, meta, created_at, updated_at
FROM purchase_orders
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListPurchaseOrdersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListPurchaseOrders(ctx context.Context, arg ListPurchaseOrdersParams) ([]PurchaseOrder, error) {
	rows, err := q.db.Query(ctx, listPurchaseOrders, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PurchaseOrder{}
	for rows.Next() {
		var i PurchaseOrder
		if err := rows.Scan(
			&i.ID,
			&i.OrderNumber,
			&i.SupplierID,
			&i.OrderDate,
			&i.ExpectedDeliveryDate,
			&i.Status,
			&i.TotalAmount,
			&i.CreatedBy,
			&i.ApprovedBy,
			&i.Meta,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPurchaseOrdersByStatus = `-- name: ListPurchaseOrdersByStatus :many
SELECT id, order_number, supplier_id, order_date, expected_delivery_date, status, total_amount, created_by, approved_by, meta, created_at, updated_at
FROM purchase_orders
WHERE status = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListPurchaseOrdersByStatusParams struct {
	Status string `json:"status"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) ListPurchaseOrdersByStatus(ctx context.Context, arg ListPurchaseOrdersByStatusParams) ([]PurchaseOrder, error) {
	rows, err := q.db.Query(ctx, listPurchaseOrdersByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PurchaseOrder{}
	for rows.Next() {
		var i PurchaseOrder
		if err := rows.Scan(
			&i.ID,
			&i.OrderNumber,
			&i.SupplierID,
			&i.OrderDate,
			&i.ExpectedDeliveryDate,
			&i.Status,
			&i.TotalAmount,
			&i.CreatedBy,
			&i.ApprovedBy,
			&i.Meta,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPurchaseOrdersBySupplier = `-- name: ListPurchaseOrdersBySupplier :many
SELECT id, order_number, supplier_id, order_date, expected_delivery_date, status, total_amount, created_by, approved_by, meta, created_at, updated_at
FROM purchase_orders
WHERE supplier_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListPurchaseOrdersBySupplierParams struct {
	SupplierID pgtype.Int4 `json:"supplier_id"`
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
}

func (q *Queries) ListPurchaseOrdersBySupplier(ctx context.Context, arg ListPurchaseOrdersBySupplierParams) ([]PurchaseOrder, error) {
	rows, err := q.db.Query(ctx, listPurchaseOrdersBySupplier, arg.SupplierID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PurchaseOrder{}
	for rows.Next() {
		var i PurchaseOrder
		if err := rows.Scan(
			&i.ID,
			&i.OrderNumber,
			&i.SupplierID,
			&i.OrderDate,
			&i.ExpectedDeliveryDate,
			&i.Status,
			&i.TotalAmount,
			&i.CreatedBy,
			&i.ApprovedBy,
			&i.Meta,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchPurchaseOrders = `-- name: SearchPurchaseOrders :many
SELECT id, order_number, supplier_id, order_date, expected_delivery_date, status, total_amount, created_by, approved_by, meta, created_at, updated_at
FROM purchase_orders
WHERE 
    ($3::TEXT IS NULL OR 
     order_number ILIKE '%' || $3 || '%' OR 
     status ILIKE '%' || $3 || '%')
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type SearchPurchaseOrdersParams struct {
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
	Query  pgtype.Text `json:"query"`
}

func (q *Queries) SearchPurchaseOrders(ctx context.Context, arg SearchPurchaseOrdersParams) ([]PurchaseOrder, error) {
	rows, err := q.db.Query(ctx, searchPurchaseOrders, arg.Limit, arg.Offset, arg.Query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PurchaseOrder{}
	for rows.Next() {
		var i PurchaseOrder
		if err := rows.Scan(
			&i.ID,
			&i.OrderNumber,
			&i.SupplierID,
			&i.OrderDate,
			&i.ExpectedDeliveryDate,
			&i.Status,
			&i.TotalAmount,
			&i.CreatedBy,
			&i.ApprovedBy,
			&i.Meta,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePurchaseOrder = `-- name: UpdatePurchaseOrder :one
UPDATE purchase_orders
SET
    order_number = COALESCE(NULLIF($2, ''), order_number),
    supplier_id = COALESCE($3, supplier_id),
    order_date = COALESCE($4, order_date),
    expected_delivery_date = COALESCE($5, expected_delivery_date),
    status = COALESCE(NULLIF($6, ''), status),
    total_amount = COALESCE($7, total_amount),
    approved_by = COALESCE($8, approved_by),
    meta = COALESCE($9, meta),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, order_number, supplier_id, order_date, expected_delivery_date, status, total_amount, created_by, approved_by, meta, created_at, updated_at
`

type UpdatePurchaseOrderParams struct {
	ID                   int32              `json:"id"`
	Column2              interface{}        `json:"column_2"`
	SupplierID           pgtype.Int4        `json:"supplier_id"`
	OrderDate            pgtype.Timestamptz `json:"order_date"`
	ExpectedDeliveryDate pgtype.Timestamptz `json:"expected_delivery_date"`
	Column6              interface{}        `json:"column_6"`
	TotalAmount          pgtype.Numeric     `json:"total_amount"`
	ApprovedBy           pgtype.Int4        `json:"approved_by"`
	Meta                 []byte             `json:"meta"`
}

func (q *Queries) UpdatePurchaseOrder(ctx context.Context, arg UpdatePurchaseOrderParams) (PurchaseOrder, error) {
	row := q.db.QueryRow(ctx, updatePurchaseOrder,
		arg.ID,
		arg.Column2,
		arg.SupplierID,
		arg.OrderDate,
		arg.ExpectedDeliveryDate,
		arg.Column6,
		arg.TotalAmount,
		arg.ApprovedBy,
		arg.Meta,
	)
	var i PurchaseOrder
	err := row.Scan(
		&i.ID,
		&i.OrderNumber,
		&i.SupplierID,
		&i.OrderDate,
		&i.ExpectedDeliveryDate,
		&i.Status,
		&i.TotalAmount,
		&i.CreatedBy,
		&i.ApprovedBy,
		&i.Meta,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePurchaseOrderItem = `-- name: UpdatePurchaseOrderItem :one
UPDATE purchase_order_items
SET
    material_id = COALESCE($2, material_id),
    quantity = COALESCE($3, quantity),
    unit_price = COALESCE($4, unit_price),
    total_price = COALESCE($5, total_price),
    received_quantity = COALESCE($6, received_quantity),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, purchase_order_id, material_id, quantity, unit_price, total_price, received_quantity, created_at, updated_at
`

type UpdatePurchaseOrderItemParams struct {
	ID               int32          `json:"id"`
	MaterialID       pgtype.Int4    `json:"material_id"`
	Quantity         pgtype.Numeric `json:"quantity"`
	UnitPrice        pgtype.Numeric `json:"unit_price"`
	TotalPrice       pgtype.Numeric `json:"total_price"`
	ReceivedQuantity pgtype.Numeric `json:"received_quantity"`
}

func (q *Queries) UpdatePurchaseOrderItem(ctx context.Context, arg UpdatePurchaseOrderItemParams) (PurchaseOrderItem, error) {
	row := q.db.QueryRow(ctx, updatePurchaseOrderItem,
		arg.ID,
		arg.MaterialID,
		arg.Quantity,
		arg.UnitPrice,
		arg.TotalPrice,
		arg.ReceivedQuantity,
	)
	var i PurchaseOrderItem
	err := row.Scan(
		&i.ID,
		&i.PurchaseOrderID,
		&i.MaterialID,
		&i.Quantity,
		&i.UnitPrice,
		&i.TotalPrice,
		&i.ReceivedQuantity,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePurchaseOrderItemReceivedQuantity = `-- name: UpdatePurchaseOrderItemReceivedQuantity :one
UPDATE purchase_order_items
SET
    received_quantity = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, purchase_order_id, material_id, quantity, unit_price, total_price, received_quantity, created_at, updated_at
`

type UpdatePurchaseOrderItemReceivedQuantityParams struct {
	ID               int32          `json:"id"`
	ReceivedQuantity pgtype.Numeric `json:"received_quantity"`
}

func (q *Queries) UpdatePurchaseOrderItemReceivedQuantity(ctx context.Context, arg UpdatePurchaseOrderItemReceivedQuantityParams) (PurchaseOrderItem, error) {
	row := q.db.QueryRow(ctx, updatePurchaseOrderItemReceivedQuantity, arg.ID, arg.ReceivedQuantity)
	var i PurchaseOrderItem
	err := row.Scan(
		&i.ID,
		&i.PurchaseOrderID,
		&i.MaterialID,
		&i.Quantity,
		&i.UnitPrice,
		&i.TotalPrice,
		&i.ReceivedQuantity,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
