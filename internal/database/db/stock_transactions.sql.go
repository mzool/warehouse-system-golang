// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: stock_transactions.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkOpeningStockExists = `-- name: CheckOpeningStockExists :one
SELECT EXISTS(
    SELECT 1
    FROM batches
    WHERE material_id = $1
      AND batch_number = $1 || '/' || EXTRACT(YEAR FROM CURRENT_TIMESTAMP)::TEXT || '/open'
) AS exists
`

func (q *Queries) CheckOpeningStockExists(ctx context.Context, materialID pgtype.Int4) (bool, error) {
	row := q.db.QueryRow(ctx, checkOpeningStockExists, materialID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createBatch = `-- name: CreateBatch :one
INSERT INTO batches (
    material_id, supplier_id, warehouse_id, movement_id,
    unit_price, batch_number, manufacture_date, expiry_date,
    start_quantity, current_quantity, notes, meta
) VALUES (
    $1, $2, $3, $4,
    $5, $6, $7, $8,
    $9, $10, $11, $12
)
RETURNING id, material_id, supplier_id, warehouse_id, movement_id,
    unit_price, batch_number, manufacture_date, expiry_date,
    start_quantity, current_quantity, notes, meta, created_at, updated_at
`

type CreateBatchParams struct {
	MaterialID      pgtype.Int4    `json:"material_id"`
	SupplierID      pgtype.Int4    `json:"supplier_id"`
	WarehouseID     pgtype.Int4    `json:"warehouse_id"`
	MovementID      pgtype.Int4    `json:"movement_id"`
	UnitPrice       pgtype.Numeric `json:"unit_price"`
	BatchNumber     string         `json:"batch_number"`
	ManufactureDate pgtype.Date    `json:"manufacture_date"`
	ExpiryDate      pgtype.Date    `json:"expiry_date"`
	StartQuantity   pgtype.Numeric `json:"start_quantity"`
	CurrentQuantity pgtype.Numeric `json:"current_quantity"`
	Notes           pgtype.Text    `json:"notes"`
	Meta            []byte         `json:"meta"`
}

func (q *Queries) CreateBatch(ctx context.Context, arg CreateBatchParams) (Batch, error) {
	row := q.db.QueryRow(ctx, createBatch,
		arg.MaterialID,
		arg.SupplierID,
		arg.WarehouseID,
		arg.MovementID,
		arg.UnitPrice,
		arg.BatchNumber,
		arg.ManufactureDate,
		arg.ExpiryDate,
		arg.StartQuantity,
		arg.CurrentQuantity,
		arg.Notes,
		arg.Meta,
	)
	var i Batch
	err := row.Scan(
		&i.ID,
		&i.MaterialID,
		&i.SupplierID,
		&i.WarehouseID,
		&i.MovementID,
		&i.UnitPrice,
		&i.BatchNumber,
		&i.ManufactureDate,
		&i.ExpiryDate,
		&i.StartQuantity,
		&i.CurrentQuantity,
		&i.Notes,
		&i.Meta,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createStockMovement = `-- name: CreateStockMovement :one

INSERT INTO stock_movements (
    material_id, from_warehouse_id, to_warehouse_id,
    quantity, stock_direction, movement_type,
    reference, performed_by, movement_date, notes
) VALUES (
    $1, $2, $3,
    $4, $5, $6,
    $7, $8, $9, $10
)
RETURNING id, material_id, from_warehouse_id, to_warehouse_id,
    quantity, stock_direction, movement_type,
    reference, performed_by, movement_date, notes, created_at, updated_at
`

type CreateStockMovementParams struct {
	MaterialID      pgtype.Int4        `json:"material_id"`
	FromWarehouseID pgtype.Int4        `json:"from_warehouse_id"`
	ToWarehouseID   pgtype.Int4        `json:"to_warehouse_id"`
	Quantity        pgtype.Numeric     `json:"quantity"`
	StockDirection  StockDirection     `json:"stock_direction"`
	MovementType    StockMovementType  `json:"movement_type"`
	Reference       pgtype.Text        `json:"reference"`
	PerformedBy     pgtype.Int4        `json:"performed_by"`
	MovementDate    pgtype.Timestamptz `json:"movement_date"`
	Notes           pgtype.Text        `json:"notes"`
}

// =====================================================
// STOCK MOVEMENT QUERIES
// =====================================================
func (q *Queries) CreateStockMovement(ctx context.Context, arg CreateStockMovementParams) (StockMovement, error) {
	row := q.db.QueryRow(ctx, createStockMovement,
		arg.MaterialID,
		arg.FromWarehouseID,
		arg.ToWarehouseID,
		arg.Quantity,
		arg.StockDirection,
		arg.MovementType,
		arg.Reference,
		arg.PerformedBy,
		arg.MovementDate,
		arg.Notes,
	)
	var i StockMovement
	err := row.Scan(
		&i.ID,
		&i.MaterialID,
		&i.FromWarehouseID,
		&i.ToWarehouseID,
		&i.Quantity,
		&i.StockDirection,
		&i.MovementType,
		&i.Reference,
		&i.PerformedBy,
		&i.MovementDate,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAvailableBatchesForMaterial = `-- name: GetAvailableBatchesForMaterial :many

SELECT 
    b.id,
    b.batch_number,
    b.current_quantity,
    b.unit_price,
    b.manufacture_date,
    b.expiry_date,
    w.name as warehouse_name,
    s.name as supplier_name
FROM batches b
LEFT JOIN warehouses w ON b.warehouse_id = w.id
LEFT JOIN suppliers s ON b.supplier_id = s.id
WHERE b.material_id = $1
  AND b.warehouse_id = $2
  AND b.current_quantity > 0
ORDER BY b.created_at ASC
`

type GetAvailableBatchesForMaterialParams struct {
	MaterialID  pgtype.Int4 `json:"material_id"`
	WarehouseID pgtype.Int4 `json:"warehouse_id"`
}

type GetAvailableBatchesForMaterialRow struct {
	ID              int32          `json:"id"`
	BatchNumber     string         `json:"batch_number"`
	CurrentQuantity pgtype.Numeric `json:"current_quantity"`
	UnitPrice       pgtype.Numeric `json:"unit_price"`
	ManufactureDate pgtype.Date    `json:"manufacture_date"`
	ExpiryDate      pgtype.Date    `json:"expiry_date"`
	WarehouseName   pgtype.Text    `json:"warehouse_name"`
	SupplierName    pgtype.Text    `json:"supplier_name"`
}

// =====================================================
// BATCH ALLOCATION QUERIES (for manual selection)
// =====================================================
func (q *Queries) GetAvailableBatchesForMaterial(ctx context.Context, arg GetAvailableBatchesForMaterialParams) ([]GetAvailableBatchesForMaterialRow, error) {
	rows, err := q.db.Query(ctx, getAvailableBatchesForMaterial, arg.MaterialID, arg.WarehouseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAvailableBatchesForMaterialRow{}
	for rows.Next() {
		var i GetAvailableBatchesForMaterialRow
		if err := rows.Scan(
			&i.ID,
			&i.BatchNumber,
			&i.CurrentQuantity,
			&i.UnitPrice,
			&i.ManufactureDate,
			&i.ExpiryDate,
			&i.WarehouseName,
			&i.SupplierName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBatchByID = `-- name: GetBatchByID :one
SELECT id, material_id, supplier_id, warehouse_id, movement_id,
    unit_price, batch_number, manufacture_date, expiry_date,
    start_quantity, current_quantity, notes, meta, created_at, updated_at
FROM batches
WHERE id = $1
`

func (q *Queries) GetBatchByID(ctx context.Context, id int32) (Batch, error) {
	row := q.db.QueryRow(ctx, getBatchByID, id)
	var i Batch
	err := row.Scan(
		&i.ID,
		&i.MaterialID,
		&i.SupplierID,
		&i.WarehouseID,
		&i.MovementID,
		&i.UnitPrice,
		&i.BatchNumber,
		&i.ManufactureDate,
		&i.ExpiryDate,
		&i.StartQuantity,
		&i.CurrentQuantity,
		&i.Notes,
		&i.Meta,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getBatchesByIDs = `-- name: GetBatchesByIDs :many
SELECT id, material_id, supplier_id, warehouse_id, movement_id,
    unit_price, batch_number, manufacture_date, expiry_date,
    start_quantity, current_quantity, notes, meta, created_at, updated_at
FROM batches
WHERE id = ANY($1::int[])
`

func (q *Queries) GetBatchesByIDs(ctx context.Context, dollar_1 []int32) ([]Batch, error) {
	rows, err := q.db.Query(ctx, getBatchesByIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Batch{}
	for rows.Next() {
		var i Batch
		if err := rows.Scan(
			&i.ID,
			&i.MaterialID,
			&i.SupplierID,
			&i.WarehouseID,
			&i.MovementID,
			&i.UnitPrice,
			&i.BatchNumber,
			&i.ManufactureDate,
			&i.ExpiryDate,
			&i.StartQuantity,
			&i.CurrentQuantity,
			&i.Notes,
			&i.Meta,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBatchesByWarehouseAndMaterial = `-- name: GetBatchesByWarehouseAndMaterial :many
SELECT id, material_id, supplier_id, warehouse_id, movement_id,
    unit_price, batch_number, manufacture_date, expiry_date,
    start_quantity, current_quantity, notes, meta, created_at, updated_at
FROM batches
WHERE warehouse_id = $1
  AND material_id = $2
  AND current_quantity > 0
ORDER BY created_at ASC
`

type GetBatchesByWarehouseAndMaterialParams struct {
	WarehouseID pgtype.Int4 `json:"warehouse_id"`
	MaterialID  pgtype.Int4 `json:"material_id"`
}

func (q *Queries) GetBatchesByWarehouseAndMaterial(ctx context.Context, arg GetBatchesByWarehouseAndMaterialParams) ([]Batch, error) {
	rows, err := q.db.Query(ctx, getBatchesByWarehouseAndMaterial, arg.WarehouseID, arg.MaterialID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Batch{}
	for rows.Next() {
		var i Batch
		if err := rows.Scan(
			&i.ID,
			&i.MaterialID,
			&i.SupplierID,
			&i.WarehouseID,
			&i.MovementID,
			&i.UnitPrice,
			&i.BatchNumber,
			&i.ManufactureDate,
			&i.ExpiryDate,
			&i.StartQuantity,
			&i.CurrentQuantity,
			&i.Notes,
			&i.Meta,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBatchesByWarehouseAndMaterialLIFO = `-- name: GetBatchesByWarehouseAndMaterialLIFO :many
SELECT id, material_id, supplier_id, warehouse_id, movement_id,
    unit_price, batch_number, manufacture_date, expiry_date,
    start_quantity, current_quantity, notes, meta, created_at, updated_at
FROM batches
WHERE warehouse_id = $1
  AND material_id = $2
  AND current_quantity > 0
ORDER BY created_at DESC
`

type GetBatchesByWarehouseAndMaterialLIFOParams struct {
	WarehouseID pgtype.Int4 `json:"warehouse_id"`
	MaterialID  pgtype.Int4 `json:"material_id"`
}

func (q *Queries) GetBatchesByWarehouseAndMaterialLIFO(ctx context.Context, arg GetBatchesByWarehouseAndMaterialLIFOParams) ([]Batch, error) {
	rows, err := q.db.Query(ctx, getBatchesByWarehouseAndMaterialLIFO, arg.WarehouseID, arg.MaterialID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Batch{}
	for rows.Next() {
		var i Batch
		if err := rows.Scan(
			&i.ID,
			&i.MaterialID,
			&i.SupplierID,
			&i.WarehouseID,
			&i.MovementID,
			&i.UnitPrice,
			&i.BatchNumber,
			&i.ManufactureDate,
			&i.ExpiryDate,
			&i.StartQuantity,
			&i.CurrentQuantity,
			&i.Notes,
			&i.Meta,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCurrentStockLevel = `-- name: GetCurrentStockLevel :one

SELECT 
    COALESCE(SUM(b.current_quantity), 0) as total_quantity,
    COUNT(DISTINCT b.id) as batch_count
FROM batches b
WHERE b.material_id = $1
  AND b.warehouse_id = $2
  AND b.current_quantity > 0
`

type GetCurrentStockLevelParams struct {
	MaterialID  pgtype.Int4 `json:"material_id"`
	WarehouseID pgtype.Int4 `json:"warehouse_id"`
}

type GetCurrentStockLevelRow struct {
	TotalQuantity interface{} `json:"total_quantity"`
	BatchCount    int64       `json:"batch_count"`
}

// =====================================================
// STOCK LEVEL QUERIES
// =====================================================
func (q *Queries) GetCurrentStockLevel(ctx context.Context, arg GetCurrentStockLevelParams) (GetCurrentStockLevelRow, error) {
	row := q.db.QueryRow(ctx, getCurrentStockLevel, arg.MaterialID, arg.WarehouseID)
	var i GetCurrentStockLevelRow
	err := row.Scan(&i.TotalQuantity, &i.BatchCount)
	return i, err
}

const getLastBatchNumberForMaterial = `-- name: GetLastBatchNumberForMaterial :one

SELECT batch_number
FROM batches
WHERE material_id = $1
  AND batch_number LIKE $1 || '/' || EXTRACT(YEAR FROM CURRENT_TIMESTAMP)::TEXT || '/%'
ORDER BY created_at DESC
LIMIT 1
`

// =====================================================
// BATCH QUERIES
// =====================================================
func (q *Queries) GetLastBatchNumberForMaterial(ctx context.Context, materialID pgtype.Int4) (string, error) {
	row := q.db.QueryRow(ctx, getLastBatchNumberForMaterial, materialID)
	var batch_number string
	err := row.Scan(&batch_number)
	return batch_number, err
}

const getMaterialValuationMethod = `-- name: GetMaterialValuationMethod :one

SELECT COALESCE(m.valuation, w.valuation) as valuation_method
FROM materials m
CROSS JOIN warehouses w
WHERE m.id = $1 AND w.id = $2
`

type GetMaterialValuationMethodParams struct {
	ID   int32 `json:"id"`
	ID_2 int32 `json:"id_2"`
}

// =====================================================
// VALUATION METHOD QUERIES
// =====================================================
func (q *Queries) GetMaterialValuationMethod(ctx context.Context, arg GetMaterialValuationMethodParams) (ValuationMethod, error) {
	row := q.db.QueryRow(ctx, getMaterialValuationMethod, arg.ID, arg.ID_2)
	var valuation_method ValuationMethod
	err := row.Scan(&valuation_method)
	return valuation_method, err
}

const getSaleOrderItemsWithBatches = `-- name: GetSaleOrderItemsWithBatches :many

SELECT 
    soi.id as order_item_id,
    soi.material_id,
    soi.quantity,
    soi.shipped_quantity,
    sm.id as movement_id,
    sm.from_warehouse_id,
    b.id as batch_id,
    b.batch_number,
    b.current_quantity as batch_quantity
FROM sales_order_items soi
LEFT JOIN stock_movements sm ON sm.reference = 'SO-' || soi.sales_order_id::TEXT
    AND sm.material_id = soi.material_id
    AND sm.movement_type = 'SALE'
LEFT JOIN batches b ON b.movement_id = sm.id
WHERE soi.sales_order_id = $1
`

type GetSaleOrderItemsWithBatchesRow struct {
	OrderItemID     int32          `json:"order_item_id"`
	MaterialID      pgtype.Int4    `json:"material_id"`
	Quantity        pgtype.Numeric `json:"quantity"`
	ShippedQuantity pgtype.Numeric `json:"shipped_quantity"`
	MovementID      pgtype.Int4    `json:"movement_id"`
	FromWarehouseID pgtype.Int4    `json:"from_warehouse_id"`
	BatchID         pgtype.Int4    `json:"batch_id"`
	BatchNumber     pgtype.Text    `json:"batch_number"`
	BatchQuantity   pgtype.Numeric `json:"batch_quantity"`
}

// =====================================================
// TRANSACTION-SPECIFIC QUERIES
// =====================================================
func (q *Queries) GetSaleOrderItemsWithBatches(ctx context.Context, salesOrderID pgtype.Int4) ([]GetSaleOrderItemsWithBatchesRow, error) {
	rows, err := q.db.Query(ctx, getSaleOrderItemsWithBatches, salesOrderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSaleOrderItemsWithBatchesRow{}
	for rows.Next() {
		var i GetSaleOrderItemsWithBatchesRow
		if err := rows.Scan(
			&i.OrderItemID,
			&i.MaterialID,
			&i.Quantity,
			&i.ShippedQuantity,
			&i.MovementID,
			&i.FromWarehouseID,
			&i.BatchID,
			&i.BatchNumber,
			&i.BatchQuantity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStockLevelsByMaterial = `-- name: GetStockLevelsByMaterial :many
SELECT 
    m.id as material_id,
    m.name as material_name,
    m.code as material_code,
    w.id as warehouse_id,
    w.name as warehouse_name,
    COALESCE(SUM(b.current_quantity), 0) as total_quantity,
    COUNT(DISTINCT b.id) as batch_count,
    MIN(b.unit_price) as min_unit_price,
    MAX(b.unit_price) as max_unit_price,
    AVG(b.unit_price) as avg_unit_price
FROM materials m
LEFT JOIN batches b ON b.material_id = m.id AND b.current_quantity > 0
LEFT JOIN warehouses w ON b.warehouse_id = w.id
WHERE m.id = $1
GROUP BY m.id, m.name, m.code, w.id, w.name
ORDER BY w.name
`

type GetStockLevelsByMaterialRow struct {
	MaterialID    int32       `json:"material_id"`
	MaterialName  string      `json:"material_name"`
	MaterialCode  string      `json:"material_code"`
	WarehouseID   pgtype.Int4 `json:"warehouse_id"`
	WarehouseName pgtype.Text `json:"warehouse_name"`
	TotalQuantity interface{} `json:"total_quantity"`
	BatchCount    int64       `json:"batch_count"`
	MinUnitPrice  interface{} `json:"min_unit_price"`
	MaxUnitPrice  interface{} `json:"max_unit_price"`
	AvgUnitPrice  float64     `json:"avg_unit_price"`
}

func (q *Queries) GetStockLevelsByMaterial(ctx context.Context, id int32) ([]GetStockLevelsByMaterialRow, error) {
	rows, err := q.db.Query(ctx, getStockLevelsByMaterial, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetStockLevelsByMaterialRow{}
	for rows.Next() {
		var i GetStockLevelsByMaterialRow
		if err := rows.Scan(
			&i.MaterialID,
			&i.MaterialName,
			&i.MaterialCode,
			&i.WarehouseID,
			&i.WarehouseName,
			&i.TotalQuantity,
			&i.BatchCount,
			&i.MinUnitPrice,
			&i.MaxUnitPrice,
			&i.AvgUnitPrice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStockLevelsByWarehouse = `-- name: GetStockLevelsByWarehouse :many
SELECT 
    w.id as warehouse_id,
    w.name as warehouse_name,
    m.id as material_id,
    m.name as material_name,
    m.code as material_code,
    COALESCE(SUM(b.current_quantity), 0) as total_quantity,
    COUNT(DISTINCT b.id) as batch_count
FROM warehouses w
CROSS JOIN materials m
LEFT JOIN batches b ON b.warehouse_id = w.id AND b.material_id = m.id AND b.current_quantity > 0
WHERE m.is_active = TRUE
GROUP BY w.id, w.name, m.id, m.name, m.code
HAVING COALESCE(SUM(b.current_quantity), 0) > 0
ORDER BY w.name, m.name
`

type GetStockLevelsByWarehouseRow struct {
	WarehouseID   int32       `json:"warehouse_id"`
	WarehouseName string      `json:"warehouse_name"`
	MaterialID    int32       `json:"material_id"`
	MaterialName  string      `json:"material_name"`
	MaterialCode  string      `json:"material_code"`
	TotalQuantity interface{} `json:"total_quantity"`
	BatchCount    int64       `json:"batch_count"`
}

func (q *Queries) GetStockLevelsByWarehouse(ctx context.Context) ([]GetStockLevelsByWarehouseRow, error) {
	rows, err := q.db.Query(ctx, getStockLevelsByWarehouse)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetStockLevelsByWarehouseRow{}
	for rows.Next() {
		var i GetStockLevelsByWarehouseRow
		if err := rows.Scan(
			&i.WarehouseID,
			&i.WarehouseName,
			&i.MaterialID,
			&i.MaterialName,
			&i.MaterialCode,
			&i.TotalQuantity,
			&i.BatchCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStockMovementByID = `-- name: GetStockMovementByID :one
SELECT id, material_id, from_warehouse_id, to_warehouse_id,
    quantity, stock_direction, movement_type,
    reference, performed_by, movement_date, notes, created_at, updated_at
FROM stock_movements
WHERE id = $1
`

func (q *Queries) GetStockMovementByID(ctx context.Context, id int32) (StockMovement, error) {
	row := q.db.QueryRow(ctx, getStockMovementByID, id)
	var i StockMovement
	err := row.Scan(
		&i.ID,
		&i.MaterialID,
		&i.FromWarehouseID,
		&i.ToWarehouseID,
		&i.Quantity,
		&i.StockDirection,
		&i.MovementType,
		&i.Reference,
		&i.PerformedBy,
		&i.MovementDate,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getStockMovementHistory = `-- name: GetStockMovementHistory :many
SELECT sm.id, sm.material_id, sm.from_warehouse_id, sm.to_warehouse_id,
    sm.quantity, sm.stock_direction, sm.movement_type,
    sm.reference, sm.performed_by, sm.movement_date, sm.notes,
    sm.created_at, sm.updated_at,
    m.name as material_name,
    u.username as performed_by_username
FROM stock_movements sm
LEFT JOIN materials m ON sm.material_id = m.id
LEFT JOIN users u ON sm.performed_by = u.id
WHERE sm.material_id = $1
ORDER BY sm.movement_date DESC
LIMIT $2 OFFSET $3
`

type GetStockMovementHistoryParams struct {
	MaterialID pgtype.Int4 `json:"material_id"`
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
}

type GetStockMovementHistoryRow struct {
	ID                  int32              `json:"id"`
	MaterialID          pgtype.Int4        `json:"material_id"`
	FromWarehouseID     pgtype.Int4        `json:"from_warehouse_id"`
	ToWarehouseID       pgtype.Int4        `json:"to_warehouse_id"`
	Quantity            pgtype.Numeric     `json:"quantity"`
	StockDirection      StockDirection     `json:"stock_direction"`
	MovementType        StockMovementType  `json:"movement_type"`
	Reference           pgtype.Text        `json:"reference"`
	PerformedBy         pgtype.Int4        `json:"performed_by"`
	MovementDate        pgtype.Timestamptz `json:"movement_date"`
	Notes               pgtype.Text        `json:"notes"`
	CreatedAt           pgtype.Timestamptz `json:"created_at"`
	UpdatedAt           pgtype.Timestamptz `json:"updated_at"`
	MaterialName        pgtype.Text        `json:"material_name"`
	PerformedByUsername pgtype.Text        `json:"performed_by_username"`
}

func (q *Queries) GetStockMovementHistory(ctx context.Context, arg GetStockMovementHistoryParams) ([]GetStockMovementHistoryRow, error) {
	rows, err := q.db.Query(ctx, getStockMovementHistory, arg.MaterialID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetStockMovementHistoryRow{}
	for rows.Next() {
		var i GetStockMovementHistoryRow
		if err := rows.Scan(
			&i.ID,
			&i.MaterialID,
			&i.FromWarehouseID,
			&i.ToWarehouseID,
			&i.Quantity,
			&i.StockDirection,
			&i.MovementType,
			&i.Reference,
			&i.PerformedBy,
			&i.MovementDate,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MaterialName,
			&i.PerformedByUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStockMovementsByReference = `-- name: GetStockMovementsByReference :many
SELECT id, material_id, from_warehouse_id, to_warehouse_id,
    quantity, stock_direction, movement_type,
    reference, performed_by, movement_date, notes, created_at, updated_at
FROM stock_movements
WHERE reference = $1
ORDER BY movement_date DESC
`

func (q *Queries) GetStockMovementsByReference(ctx context.Context, reference pgtype.Text) ([]StockMovement, error) {
	rows, err := q.db.Query(ctx, getStockMovementsByReference, reference)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []StockMovement{}
	for rows.Next() {
		var i StockMovement
		if err := rows.Scan(
			&i.ID,
			&i.MaterialID,
			&i.FromWarehouseID,
			&i.ToWarehouseID,
			&i.Quantity,
			&i.StockDirection,
			&i.MovementType,
			&i.Reference,
			&i.PerformedBy,
			&i.MovementDate,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransferOutMovementDetails = `-- name: GetTransferOutMovementDetails :one
SELECT sm.id, sm.material_id, sm.from_warehouse_id, sm.to_warehouse_id,
    sm.quantity, sm.stock_direction, sm.movement_type,
    sm.reference, sm.performed_by, sm.movement_date, sm.notes,
    sm.created_at, sm.updated_at
FROM stock_movements sm
WHERE sm.id = $1
  AND sm.movement_type = 'TRANSFER_OUT'
`

func (q *Queries) GetTransferOutMovementDetails(ctx context.Context, id int32) (StockMovement, error) {
	row := q.db.QueryRow(ctx, getTransferOutMovementDetails, id)
	var i StockMovement
	err := row.Scan(
		&i.ID,
		&i.MaterialID,
		&i.FromWarehouseID,
		&i.ToWarehouseID,
		&i.Quantity,
		&i.StockDirection,
		&i.MovementType,
		&i.Reference,
		&i.PerformedBy,
		&i.MovementDate,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWarehouseStockMovements = `-- name: GetWarehouseStockMovements :many
SELECT sm.id, sm.material_id, sm.from_warehouse_id, sm.to_warehouse_id,
    sm.quantity, sm.stock_direction, sm.movement_type,
    sm.reference, sm.performed_by, sm.movement_date, sm.notes,
    sm.created_at, sm.updated_at,
    m.name as material_name,
    u.username as performed_by_username
FROM stock_movements sm
LEFT JOIN materials m ON sm.material_id = m.id
LEFT JOIN users u ON sm.performed_by = u.id
WHERE (sm.from_warehouse_id = $1 OR sm.to_warehouse_id = $1)
ORDER BY sm.movement_date DESC
LIMIT $2 OFFSET $3
`

type GetWarehouseStockMovementsParams struct {
	FromWarehouseID pgtype.Int4 `json:"from_warehouse_id"`
	Limit           int32       `json:"limit"`
	Offset          int32       `json:"offset"`
}

type GetWarehouseStockMovementsRow struct {
	ID                  int32              `json:"id"`
	MaterialID          pgtype.Int4        `json:"material_id"`
	FromWarehouseID     pgtype.Int4        `json:"from_warehouse_id"`
	ToWarehouseID       pgtype.Int4        `json:"to_warehouse_id"`
	Quantity            pgtype.Numeric     `json:"quantity"`
	StockDirection      StockDirection     `json:"stock_direction"`
	MovementType        StockMovementType  `json:"movement_type"`
	Reference           pgtype.Text        `json:"reference"`
	PerformedBy         pgtype.Int4        `json:"performed_by"`
	MovementDate        pgtype.Timestamptz `json:"movement_date"`
	Notes               pgtype.Text        `json:"notes"`
	CreatedAt           pgtype.Timestamptz `json:"created_at"`
	UpdatedAt           pgtype.Timestamptz `json:"updated_at"`
	MaterialName        pgtype.Text        `json:"material_name"`
	PerformedByUsername pgtype.Text        `json:"performed_by_username"`
}

func (q *Queries) GetWarehouseStockMovements(ctx context.Context, arg GetWarehouseStockMovementsParams) ([]GetWarehouseStockMovementsRow, error) {
	rows, err := q.db.Query(ctx, getWarehouseStockMovements, arg.FromWarehouseID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetWarehouseStockMovementsRow{}
	for rows.Next() {
		var i GetWarehouseStockMovementsRow
		if err := rows.Scan(
			&i.ID,
			&i.MaterialID,
			&i.FromWarehouseID,
			&i.ToWarehouseID,
			&i.Quantity,
			&i.StockDirection,
			&i.MovementType,
			&i.Reference,
			&i.PerformedBy,
			&i.MovementDate,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MaterialName,
			&i.PerformedByUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBatchQuantity = `-- name: UpdateBatchQuantity :one
UPDATE batches
SET current_quantity = current_quantity + $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, material_id, supplier_id, warehouse_id, movement_id,
    unit_price, batch_number, manufacture_date, expiry_date,
    start_quantity, current_quantity, notes, meta, created_at, updated_at
`

type UpdateBatchQuantityParams struct {
	ID              int32          `json:"id"`
	CurrentQuantity pgtype.Numeric `json:"current_quantity"`
}

func (q *Queries) UpdateBatchQuantity(ctx context.Context, arg UpdateBatchQuantityParams) (Batch, error) {
	row := q.db.QueryRow(ctx, updateBatchQuantity, arg.ID, arg.CurrentQuantity)
	var i Batch
	err := row.Scan(
		&i.ID,
		&i.MaterialID,
		&i.SupplierID,
		&i.WarehouseID,
		&i.MovementID,
		&i.UnitPrice,
		&i.BatchNumber,
		&i.ManufactureDate,
		&i.ExpiryDate,
		&i.StartQuantity,
		&i.CurrentQuantity,
		&i.Notes,
		&i.Meta,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
