// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: quality_inspections.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

type BulkCreateQualityInspectionResultsParams struct {
	InspectionID  int32          `json:"inspection_id"`
	CriteriaID    pgtype.Int4    `json:"criteria_id"`
	CriteriaName  string         `json:"criteria_name"`
	MeasuredValue pgtype.Numeric `json:"measured_value"`
	TextValue     pgtype.Text    `json:"text_value"`
	IsPassed      pgtype.Bool    `json:"is_passed"`
	Deviation     pgtype.Numeric `json:"deviation"`
	SampleNumber  pgtype.Int4    `json:"sample_number"`
	Notes         pgtype.Text    `json:"notes"`
}

const countNonConformanceReportsByStatus = `-- name: CountNonConformanceReportsByStatus :one
SELECT COUNT(*) FROM non_conformance_reports
WHERE status = $1
`

func (q *Queries) CountNonConformanceReportsByStatus(ctx context.Context, status NullNcrStatus) (int64, error) {
	row := q.db.QueryRow(ctx, countNonConformanceReportsByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countQualityInspectionsByStatus = `-- name: CountQualityInspectionsByStatus :one
SELECT COUNT(*) FROM quality_inspections
WHERE inspection_status = $1
`

func (q *Queries) CountQualityInspectionsByStatus(ctx context.Context, inspectionStatus NullQualityInspectionStatus) (int64, error) {
	row := q.db.QueryRow(ctx, countQualityInspectionsByStatus, inspectionStatus)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createMaterialQualitySpec = `-- name: CreateMaterialQualitySpec :one

INSERT INTO material_quality_specs (
    material_id, criteria_id, is_required,
    custom_tolerance_min, custom_tolerance_max
) VALUES (
    $1, $2, $3, $4, $5
)
RETURNING id, material_id, criteria_id, is_required, custom_tolerance_min, custom_tolerance_max, created_at, updated_at
`

type CreateMaterialQualitySpecParams struct {
	MaterialID         int32          `json:"material_id"`
	CriteriaID         int32          `json:"criteria_id"`
	IsRequired         pgtype.Bool    `json:"is_required"`
	CustomToleranceMin pgtype.Numeric `json:"custom_tolerance_min"`
	CustomToleranceMax pgtype.Numeric `json:"custom_tolerance_max"`
}

// ============================================================================
// MATERIAL QUALITY SPECS
// ============================================================================
func (q *Queries) CreateMaterialQualitySpec(ctx context.Context, arg CreateMaterialQualitySpecParams) (MaterialQualitySpec, error) {
	row := q.db.QueryRow(ctx, createMaterialQualitySpec,
		arg.MaterialID,
		arg.CriteriaID,
		arg.IsRequired,
		arg.CustomToleranceMin,
		arg.CustomToleranceMax,
	)
	var i MaterialQualitySpec
	err := row.Scan(
		&i.ID,
		&i.MaterialID,
		&i.CriteriaID,
		&i.IsRequired,
		&i.CustomToleranceMin,
		&i.CustomToleranceMax,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createNonConformanceReport = `-- name: CreateNonConformanceReport :one

INSERT INTO non_conformance_reports (
    ncr_number, title, description, ncr_type, severity, status,
    material_id, batch_number, quantity_affected, unit_id,
    inspection_id, supplier_id, customer_id,
    purchase_order_id, sales_order_id,
    reported_by, reported_date, notes, attachments
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19
)
RETURNING id, ncr_number, title, description, ncr_type, severity, status, material_id, batch_number, quantity_affected, unit_id, inspection_id, supplier_id, customer_id, purchase_order_id, sales_order_id, root_cause, root_cause_analysis_by, root_cause_date, corrective_action, preventive_action, action_assigned_to, action_due_date, action_completed_date, disposition, cost_impact, reported_by, reported_date, closed_by, closed_date, attachments, notes, created_at, updated_at
`

type CreateNonConformanceReportParams struct {
	NcrNumber        string             `json:"ncr_number"`
	Title            string             `json:"title"`
	Description      string             `json:"description"`
	NcrType          NcrType            `json:"ncr_type"`
	Severity         NcrSeverity        `json:"severity"`
	Status           NullNcrStatus      `json:"status"`
	MaterialID       pgtype.Int4        `json:"material_id"`
	BatchNumber      pgtype.Text        `json:"batch_number"`
	QuantityAffected pgtype.Numeric     `json:"quantity_affected"`
	UnitID           pgtype.Int4        `json:"unit_id"`
	InspectionID     pgtype.Int4        `json:"inspection_id"`
	SupplierID       pgtype.Int4        `json:"supplier_id"`
	CustomerID       pgtype.Int4        `json:"customer_id"`
	PurchaseOrderID  pgtype.Int4        `json:"purchase_order_id"`
	SalesOrderID     pgtype.Int4        `json:"sales_order_id"`
	ReportedBy       pgtype.Int4        `json:"reported_by"`
	ReportedDate     pgtype.Timestamptz `json:"reported_date"`
	Notes            pgtype.Text        `json:"notes"`
	Attachments      []byte             `json:"attachments"`
}

// ============================================================================
// NON-CONFORMANCE REPORTS (NCR)
// ============================================================================
func (q *Queries) CreateNonConformanceReport(ctx context.Context, arg CreateNonConformanceReportParams) (NonConformanceReport, error) {
	row := q.db.QueryRow(ctx, createNonConformanceReport,
		arg.NcrNumber,
		arg.Title,
		arg.Description,
		arg.NcrType,
		arg.Severity,
		arg.Status,
		arg.MaterialID,
		arg.BatchNumber,
		arg.QuantityAffected,
		arg.UnitID,
		arg.InspectionID,
		arg.SupplierID,
		arg.CustomerID,
		arg.PurchaseOrderID,
		arg.SalesOrderID,
		arg.ReportedBy,
		arg.ReportedDate,
		arg.Notes,
		arg.Attachments,
	)
	var i NonConformanceReport
	err := row.Scan(
		&i.ID,
		&i.NcrNumber,
		&i.Title,
		&i.Description,
		&i.NcrType,
		&i.Severity,
		&i.Status,
		&i.MaterialID,
		&i.BatchNumber,
		&i.QuantityAffected,
		&i.UnitID,
		&i.InspectionID,
		&i.SupplierID,
		&i.CustomerID,
		&i.PurchaseOrderID,
		&i.SalesOrderID,
		&i.RootCause,
		&i.RootCauseAnalysisBy,
		&i.RootCauseDate,
		&i.CorrectiveAction,
		&i.PreventiveAction,
		&i.ActionAssignedTo,
		&i.ActionDueDate,
		&i.ActionCompletedDate,
		&i.Disposition,
		&i.CostImpact,
		&i.ReportedBy,
		&i.ReportedDate,
		&i.ClosedBy,
		&i.ClosedDate,
		&i.Attachments,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createQualityHold = `-- name: CreateQualityHold :one

INSERT INTO quality_holds (
    hold_number, material_id, warehouse_id, batch_number, lot_number,
    quantity, unit_id, quality_status, hold_reason,
    inspection_id, ncr_id, placed_by, placed_date, expected_release_date
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14
)
RETURNING id, hold_number, material_id, warehouse_id, batch_number, lot_number, quantity, unit_id, quality_status, hold_reason, inspection_id, ncr_id, placed_by, placed_date, expected_release_date, is_released, released_by, released_date, release_notes, created_at, updated_at
`

type CreateQualityHoldParams struct {
	HoldNumber          string             `json:"hold_number"`
	MaterialID          int32              `json:"material_id"`
	WarehouseID         pgtype.Int4        `json:"warehouse_id"`
	BatchNumber         pgtype.Text        `json:"batch_number"`
	LotNumber           pgtype.Text        `json:"lot_number"`
	Quantity            pgtype.Numeric     `json:"quantity"`
	UnitID              pgtype.Int4        `json:"unit_id"`
	QualityStatus       QualityStatus      `json:"quality_status"`
	HoldReason          string             `json:"hold_reason"`
	InspectionID        pgtype.Int4        `json:"inspection_id"`
	NcrID               pgtype.Int4        `json:"ncr_id"`
	PlacedBy            pgtype.Int4        `json:"placed_by"`
	PlacedDate          pgtype.Timestamptz `json:"placed_date"`
	ExpectedReleaseDate pgtype.Date        `json:"expected_release_date"`
}

// ============================================================================
// QUALITY HOLDS
// ============================================================================
func (q *Queries) CreateQualityHold(ctx context.Context, arg CreateQualityHoldParams) (QualityHold, error) {
	row := q.db.QueryRow(ctx, createQualityHold,
		arg.HoldNumber,
		arg.MaterialID,
		arg.WarehouseID,
		arg.BatchNumber,
		arg.LotNumber,
		arg.Quantity,
		arg.UnitID,
		arg.QualityStatus,
		arg.HoldReason,
		arg.InspectionID,
		arg.NcrID,
		arg.PlacedBy,
		arg.PlacedDate,
		arg.ExpectedReleaseDate,
	)
	var i QualityHold
	err := row.Scan(
		&i.ID,
		&i.HoldNumber,
		&i.MaterialID,
		&i.WarehouseID,
		&i.BatchNumber,
		&i.LotNumber,
		&i.Quantity,
		&i.UnitID,
		&i.QualityStatus,
		&i.HoldReason,
		&i.InspectionID,
		&i.NcrID,
		&i.PlacedBy,
		&i.PlacedDate,
		&i.ExpectedReleaseDate,
		&i.IsReleased,
		&i.ReleasedBy,
		&i.ReleasedDate,
		&i.ReleaseNotes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createQualityInspection = `-- name: CreateQualityInspection :one

INSERT INTO quality_inspections (
    inspection_number, inspection_type, inspection_status,
    material_id, batch_number, lot_number, quantity, unit_id,
    purchase_order_id, sales_order_id, stock_movement_id, supplier_id,
    inspection_date, inspector_id, notes, attachments
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16
)
RETURNING id, inspection_number, inspection_type, inspection_status, material_id, batch_number, lot_number, quantity, unit_id, purchase_order_id, sales_order_id, stock_movement_id, supplier_id, inspection_date, inspector_id, approved_by_id, quantity_passed, quantity_failed, quantity_on_hold, final_decision, decision_date, notes, attachments, created_at, updated_at
`

type CreateQualityInspectionParams struct {
	InspectionNumber string                      `json:"inspection_number"`
	InspectionType   QualityInspectionType       `json:"inspection_type"`
	InspectionStatus NullQualityInspectionStatus `json:"inspection_status"`
	MaterialID       pgtype.Int4                 `json:"material_id"`
	BatchNumber      pgtype.Text                 `json:"batch_number"`
	LotNumber        pgtype.Text                 `json:"lot_number"`
	Quantity         pgtype.Numeric              `json:"quantity"`
	UnitID           pgtype.Int4                 `json:"unit_id"`
	PurchaseOrderID  pgtype.Int4                 `json:"purchase_order_id"`
	SalesOrderID     pgtype.Int4                 `json:"sales_order_id"`
	StockMovementID  pgtype.Int4                 `json:"stock_movement_id"`
	SupplierID       pgtype.Int4                 `json:"supplier_id"`
	InspectionDate   pgtype.Timestamptz          `json:"inspection_date"`
	InspectorID      pgtype.Int4                 `json:"inspector_id"`
	Notes            pgtype.Text                 `json:"notes"`
	Attachments      []byte                      `json:"attachments"`
}

// ============================================================================
// QUALITY INSPECTIONS
// ============================================================================
func (q *Queries) CreateQualityInspection(ctx context.Context, arg CreateQualityInspectionParams) (QualityInspection, error) {
	row := q.db.QueryRow(ctx, createQualityInspection,
		arg.InspectionNumber,
		arg.InspectionType,
		arg.InspectionStatus,
		arg.MaterialID,
		arg.BatchNumber,
		arg.LotNumber,
		arg.Quantity,
		arg.UnitID,
		arg.PurchaseOrderID,
		arg.SalesOrderID,
		arg.StockMovementID,
		arg.SupplierID,
		arg.InspectionDate,
		arg.InspectorID,
		arg.Notes,
		arg.Attachments,
	)
	var i QualityInspection
	err := row.Scan(
		&i.ID,
		&i.InspectionNumber,
		&i.InspectionType,
		&i.InspectionStatus,
		&i.MaterialID,
		&i.BatchNumber,
		&i.LotNumber,
		&i.Quantity,
		&i.UnitID,
		&i.PurchaseOrderID,
		&i.SalesOrderID,
		&i.StockMovementID,
		&i.SupplierID,
		&i.InspectionDate,
		&i.InspectorID,
		&i.ApprovedByID,
		&i.QuantityPassed,
		&i.QuantityFailed,
		&i.QuantityOnHold,
		&i.FinalDecision,
		&i.DecisionDate,
		&i.Notes,
		&i.Attachments,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createQualityInspectionCriteria = `-- name: CreateQualityInspectionCriteria :one

INSERT INTO quality_inspection_criteria (
    name, description, criteria_type, specification,
    unit_id, tolerance_min, tolerance_max, is_critical, is_active
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
)
RETURNING id, name, description, criteria_type, specification, unit_id, tolerance_min, tolerance_max, is_critical, is_active, created_at, updated_at
`

type CreateQualityInspectionCriteriaParams struct {
	Name          string         `json:"name"`
	Description   pgtype.Text    `json:"description"`
	CriteriaType  string         `json:"criteria_type"`
	Specification pgtype.Text    `json:"specification"`
	UnitID        pgtype.Int4    `json:"unit_id"`
	ToleranceMin  pgtype.Numeric `json:"tolerance_min"`
	ToleranceMax  pgtype.Numeric `json:"tolerance_max"`
	IsCritical    pgtype.Bool    `json:"is_critical"`
	IsActive      pgtype.Bool    `json:"is_active"`
}

// ============================================================================
// QUALITY INSPECTION CRITERIA
// ============================================================================
func (q *Queries) CreateQualityInspectionCriteria(ctx context.Context, arg CreateQualityInspectionCriteriaParams) (QualityInspectionCriterium, error) {
	row := q.db.QueryRow(ctx, createQualityInspectionCriteria,
		arg.Name,
		arg.Description,
		arg.CriteriaType,
		arg.Specification,
		arg.UnitID,
		arg.ToleranceMin,
		arg.ToleranceMax,
		arg.IsCritical,
		arg.IsActive,
	)
	var i QualityInspectionCriterium
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CriteriaType,
		&i.Specification,
		&i.UnitID,
		&i.ToleranceMin,
		&i.ToleranceMax,
		&i.IsCritical,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createQualityInspectionResult = `-- name: CreateQualityInspectionResult :one

INSERT INTO quality_inspection_results (
    inspection_id, criteria_id, criteria_name,
    measured_value, text_value, is_passed,
    deviation, sample_number, notes, photo_urls
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
)
RETURNING id, inspection_id, criteria_id, criteria_name, measured_value, text_value, is_passed, deviation, sample_number, notes, photo_urls, created_at
`

type CreateQualityInspectionResultParams struct {
	InspectionID  int32          `json:"inspection_id"`
	CriteriaID    pgtype.Int4    `json:"criteria_id"`
	CriteriaName  string         `json:"criteria_name"`
	MeasuredValue pgtype.Numeric `json:"measured_value"`
	TextValue     pgtype.Text    `json:"text_value"`
	IsPassed      pgtype.Bool    `json:"is_passed"`
	Deviation     pgtype.Numeric `json:"deviation"`
	SampleNumber  pgtype.Int4    `json:"sample_number"`
	Notes         pgtype.Text    `json:"notes"`
	PhotoUrls     []byte         `json:"photo_urls"`
}

// ============================================================================
// QUALITY INSPECTION RESULTS
// ============================================================================
func (q *Queries) CreateQualityInspectionResult(ctx context.Context, arg CreateQualityInspectionResultParams) (QualityInspectionResult, error) {
	row := q.db.QueryRow(ctx, createQualityInspectionResult,
		arg.InspectionID,
		arg.CriteriaID,
		arg.CriteriaName,
		arg.MeasuredValue,
		arg.TextValue,
		arg.IsPassed,
		arg.Deviation,
		arg.SampleNumber,
		arg.Notes,
		arg.PhotoUrls,
	)
	var i QualityInspectionResult
	err := row.Scan(
		&i.ID,
		&i.InspectionID,
		&i.CriteriaID,
		&i.CriteriaName,
		&i.MeasuredValue,
		&i.TextValue,
		&i.IsPassed,
		&i.Deviation,
		&i.SampleNumber,
		&i.Notes,
		&i.PhotoUrls,
		&i.CreatedAt,
	)
	return i, err
}

const createSupplierQualityRating = `-- name: CreateSupplierQualityRating :one

INSERT INTO supplier_quality_ratings (
    supplier_id, period_start, period_end,
    total_inspections, passed_inspections, failed_inspections,
    total_quantity_received, quantity_rejected,
    total_defects, critical_defects, major_defects, minor_defects,
    ncr_count, quality_score, defect_rate, rejection_rate,
    rating, notes, calculated_by, calculation_date
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20
)
RETURNING id, supplier_id, period_start, period_end, total_inspections, passed_inspections, failed_inspections, total_quantity_received, quantity_rejected, total_defects, critical_defects, major_defects, minor_defects, ncr_count, quality_score, defect_rate, rejection_rate, rating, notes, calculated_by, calculation_date, created_at, updated_at
`

type CreateSupplierQualityRatingParams struct {
	SupplierID            int32              `json:"supplier_id"`
	PeriodStart           pgtype.Date        `json:"period_start"`
	PeriodEnd             pgtype.Date        `json:"period_end"`
	TotalInspections      pgtype.Int4        `json:"total_inspections"`
	PassedInspections     pgtype.Int4        `json:"passed_inspections"`
	FailedInspections     pgtype.Int4        `json:"failed_inspections"`
	TotalQuantityReceived pgtype.Numeric     `json:"total_quantity_received"`
	QuantityRejected      pgtype.Numeric     `json:"quantity_rejected"`
	TotalDefects          pgtype.Int4        `json:"total_defects"`
	CriticalDefects       pgtype.Int4        `json:"critical_defects"`
	MajorDefects          pgtype.Int4        `json:"major_defects"`
	MinorDefects          pgtype.Int4        `json:"minor_defects"`
	NcrCount              pgtype.Int4        `json:"ncr_count"`
	QualityScore          pgtype.Numeric     `json:"quality_score"`
	DefectRate            pgtype.Numeric     `json:"defect_rate"`
	RejectionRate         pgtype.Numeric     `json:"rejection_rate"`
	Rating                pgtype.Text        `json:"rating"`
	Notes                 pgtype.Text        `json:"notes"`
	CalculatedBy          pgtype.Int4        `json:"calculated_by"`
	CalculationDate       pgtype.Timestamptz `json:"calculation_date"`
}

// ============================================================================
// SUPPLIER QUALITY RATINGS
// ============================================================================
func (q *Queries) CreateSupplierQualityRating(ctx context.Context, arg CreateSupplierQualityRatingParams) (SupplierQualityRating, error) {
	row := q.db.QueryRow(ctx, createSupplierQualityRating,
		arg.SupplierID,
		arg.PeriodStart,
		arg.PeriodEnd,
		arg.TotalInspections,
		arg.PassedInspections,
		arg.FailedInspections,
		arg.TotalQuantityReceived,
		arg.QuantityRejected,
		arg.TotalDefects,
		arg.CriticalDefects,
		arg.MajorDefects,
		arg.MinorDefects,
		arg.NcrCount,
		arg.QualityScore,
		arg.DefectRate,
		arg.RejectionRate,
		arg.Rating,
		arg.Notes,
		arg.CalculatedBy,
		arg.CalculationDate,
	)
	var i SupplierQualityRating
	err := row.Scan(
		&i.ID,
		&i.SupplierID,
		&i.PeriodStart,
		&i.PeriodEnd,
		&i.TotalInspections,
		&i.PassedInspections,
		&i.FailedInspections,
		&i.TotalQuantityReceived,
		&i.QuantityRejected,
		&i.TotalDefects,
		&i.CriticalDefects,
		&i.MajorDefects,
		&i.MinorDefects,
		&i.NcrCount,
		&i.QualityScore,
		&i.DefectRate,
		&i.RejectionRate,
		&i.Rating,
		&i.Notes,
		&i.CalculatedBy,
		&i.CalculationDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteMaterialQualitySpec = `-- name: DeleteMaterialQualitySpec :exec
DELETE FROM material_quality_specs
WHERE id = $1
`

func (q *Queries) DeleteMaterialQualitySpec(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteMaterialQualitySpec, id)
	return err
}

const deleteMaterialQualitySpecsByMaterial = `-- name: DeleteMaterialQualitySpecsByMaterial :exec
DELETE FROM material_quality_specs
WHERE material_id = $1
`

func (q *Queries) DeleteMaterialQualitySpecsByMaterial(ctx context.Context, materialID int32) error {
	_, err := q.db.Exec(ctx, deleteMaterialQualitySpecsByMaterial, materialID)
	return err
}

const deleteNonConformanceReport = `-- name: DeleteNonConformanceReport :exec
DELETE FROM non_conformance_reports
WHERE id = $1
`

func (q *Queries) DeleteNonConformanceReport(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteNonConformanceReport, id)
	return err
}

const deleteQualityHold = `-- name: DeleteQualityHold :exec
DELETE FROM quality_holds
WHERE id = $1
`

func (q *Queries) DeleteQualityHold(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteQualityHold, id)
	return err
}

const deleteQualityInspection = `-- name: DeleteQualityInspection :exec
DELETE FROM quality_inspections
WHERE id = $1
`

func (q *Queries) DeleteQualityInspection(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteQualityInspection, id)
	return err
}

const deleteQualityInspectionCriteria = `-- name: DeleteQualityInspectionCriteria :exec
DELETE FROM quality_inspection_criteria
WHERE id = $1
`

func (q *Queries) DeleteQualityInspectionCriteria(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteQualityInspectionCriteria, id)
	return err
}

const deleteQualityInspectionResult = `-- name: DeleteQualityInspectionResult :exec
DELETE FROM quality_inspection_results
WHERE id = $1
`

func (q *Queries) DeleteQualityInspectionResult(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteQualityInspectionResult, id)
	return err
}

const deleteSupplierQualityRating = `-- name: DeleteSupplierQualityRating :exec
DELETE FROM supplier_quality_ratings
WHERE id = $1
`

func (q *Queries) DeleteSupplierQualityRating(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteSupplierQualityRating, id)
	return err
}

const getInspectionStatsByMaterial = `-- name: GetInspectionStatsByMaterial :one
SELECT 
    COUNT(*) as total_inspections,
    COUNT(CASE WHEN inspection_status = 'passed' THEN 1 END) as passed_count,
    COUNT(CASE WHEN inspection_status = 'failed' THEN 1 END) as failed_count,
    ROUND(
        CASE 
            WHEN COUNT(*) > 0 
            THEN (COUNT(CASE WHEN inspection_status = 'passed' THEN 1 END)::DECIMAL / COUNT(*) * 100)
            ELSE 0 
        END, 
    2) as pass_rate
FROM quality_inspections
WHERE material_id = $1
`

type GetInspectionStatsByMaterialRow struct {
	TotalInspections int64          `json:"total_inspections"`
	PassedCount      int64          `json:"passed_count"`
	FailedCount      int64          `json:"failed_count"`
	PassRate         pgtype.Numeric `json:"pass_rate"`
}

func (q *Queries) GetInspectionStatsByMaterial(ctx context.Context, materialID pgtype.Int4) (GetInspectionStatsByMaterialRow, error) {
	row := q.db.QueryRow(ctx, getInspectionStatsByMaterial, materialID)
	var i GetInspectionStatsByMaterialRow
	err := row.Scan(
		&i.TotalInspections,
		&i.PassedCount,
		&i.FailedCount,
		&i.PassRate,
	)
	return i, err
}

const getLatestSupplierQualityRating = `-- name: GetLatestSupplierQualityRating :one
SELECT id, supplier_id, period_start, period_end, total_inspections, passed_inspections, failed_inspections, total_quantity_received, quantity_rejected, total_defects, critical_defects, major_defects, minor_defects, ncr_count, quality_score, defect_rate, rejection_rate, rating, notes, calculated_by, calculation_date, created_at, updated_at FROM supplier_quality_ratings
WHERE supplier_id = $1
ORDER BY period_end DESC
LIMIT 1
`

func (q *Queries) GetLatestSupplierQualityRating(ctx context.Context, supplierID int32) (SupplierQualityRating, error) {
	row := q.db.QueryRow(ctx, getLatestSupplierQualityRating, supplierID)
	var i SupplierQualityRating
	err := row.Scan(
		&i.ID,
		&i.SupplierID,
		&i.PeriodStart,
		&i.PeriodEnd,
		&i.TotalInspections,
		&i.PassedInspections,
		&i.FailedInspections,
		&i.TotalQuantityReceived,
		&i.QuantityRejected,
		&i.TotalDefects,
		&i.CriticalDefects,
		&i.MajorDefects,
		&i.MinorDefects,
		&i.NcrCount,
		&i.QualityScore,
		&i.DefectRate,
		&i.RejectionRate,
		&i.Rating,
		&i.Notes,
		&i.CalculatedBy,
		&i.CalculationDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMaterialQualitySpecByID = `-- name: GetMaterialQualitySpecByID :one
SELECT id, material_id, criteria_id, is_required, custom_tolerance_min, custom_tolerance_max, created_at, updated_at FROM material_quality_specs
WHERE id = $1
`

func (q *Queries) GetMaterialQualitySpecByID(ctx context.Context, id int32) (MaterialQualitySpec, error) {
	row := q.db.QueryRow(ctx, getMaterialQualitySpecByID, id)
	var i MaterialQualitySpec
	err := row.Scan(
		&i.ID,
		&i.MaterialID,
		&i.CriteriaID,
		&i.IsRequired,
		&i.CustomToleranceMin,
		&i.CustomToleranceMax,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getNonConformanceReportByID = `-- name: GetNonConformanceReportByID :one
SELECT 
    ncr.id, ncr.ncr_number, ncr.title, ncr.description, ncr.ncr_type, ncr.severity, ncr.status, ncr.material_id, ncr.batch_number, ncr.quantity_affected, ncr.unit_id, ncr.inspection_id, ncr.supplier_id, ncr.customer_id, ncr.purchase_order_id, ncr.sales_order_id, ncr.root_cause, ncr.root_cause_analysis_by, ncr.root_cause_date, ncr.corrective_action, ncr.preventive_action, ncr.action_assigned_to, ncr.action_due_date, ncr.action_completed_date, ncr.disposition, ncr.cost_impact, ncr.reported_by, ncr.reported_date, ncr.closed_by, ncr.closed_date, ncr.attachments, ncr.notes, ncr.created_at, ncr.updated_at,
    m.name as material_name,
    m.sku as material_sku,
    sup.name as supplier_name,
    cust.name as customer_name,
    rep.full_name as reported_by_name,
    assigned.full_name as action_assigned_to_name
FROM non_conformance_reports ncr
LEFT JOIN materials m ON ncr.material_id = m.id
LEFT JOIN suppliers sup ON ncr.supplier_id = sup.id
LEFT JOIN customers cust ON ncr.customer_id = cust.id
LEFT JOIN users rep ON ncr.reported_by = rep.id
LEFT JOIN users assigned ON ncr.action_assigned_to = assigned.id
WHERE ncr.id = $1
`

type GetNonConformanceReportByIDRow struct {
	ID                   int32              `json:"id"`
	NcrNumber            string             `json:"ncr_number"`
	Title                string             `json:"title"`
	Description          string             `json:"description"`
	NcrType              NcrType            `json:"ncr_type"`
	Severity             NcrSeverity        `json:"severity"`
	Status               NullNcrStatus      `json:"status"`
	MaterialID           pgtype.Int4        `json:"material_id"`
	BatchNumber          pgtype.Text        `json:"batch_number"`
	QuantityAffected     pgtype.Numeric     `json:"quantity_affected"`
	UnitID               pgtype.Int4        `json:"unit_id"`
	InspectionID         pgtype.Int4        `json:"inspection_id"`
	SupplierID           pgtype.Int4        `json:"supplier_id"`
	CustomerID           pgtype.Int4        `json:"customer_id"`
	PurchaseOrderID      pgtype.Int4        `json:"purchase_order_id"`
	SalesOrderID         pgtype.Int4        `json:"sales_order_id"`
	RootCause            pgtype.Text        `json:"root_cause"`
	RootCauseAnalysisBy  pgtype.Int4        `json:"root_cause_analysis_by"`
	RootCauseDate        pgtype.Timestamptz `json:"root_cause_date"`
	CorrectiveAction     pgtype.Text        `json:"corrective_action"`
	PreventiveAction     pgtype.Text        `json:"preventive_action"`
	ActionAssignedTo     pgtype.Int4        `json:"action_assigned_to"`
	ActionDueDate        pgtype.Date        `json:"action_due_date"`
	ActionCompletedDate  pgtype.Date        `json:"action_completed_date"`
	Disposition          pgtype.Text        `json:"disposition"`
	CostImpact           pgtype.Numeric     `json:"cost_impact"`
	ReportedBy           pgtype.Int4        `json:"reported_by"`
	ReportedDate         pgtype.Timestamptz `json:"reported_date"`
	ClosedBy             pgtype.Int4        `json:"closed_by"`
	ClosedDate           pgtype.Timestamptz `json:"closed_date"`
	Attachments          []byte             `json:"attachments"`
	Notes                pgtype.Text        `json:"notes"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
	MaterialName         pgtype.Text        `json:"material_name"`
	MaterialSku          pgtype.Text        `json:"material_sku"`
	SupplierName         pgtype.Text        `json:"supplier_name"`
	CustomerName         pgtype.Text        `json:"customer_name"`
	ReportedByName       pgtype.Text        `json:"reported_by_name"`
	ActionAssignedToName pgtype.Text        `json:"action_assigned_to_name"`
}

func (q *Queries) GetNonConformanceReportByID(ctx context.Context, id int32) (GetNonConformanceReportByIDRow, error) {
	row := q.db.QueryRow(ctx, getNonConformanceReportByID, id)
	var i GetNonConformanceReportByIDRow
	err := row.Scan(
		&i.ID,
		&i.NcrNumber,
		&i.Title,
		&i.Description,
		&i.NcrType,
		&i.Severity,
		&i.Status,
		&i.MaterialID,
		&i.BatchNumber,
		&i.QuantityAffected,
		&i.UnitID,
		&i.InspectionID,
		&i.SupplierID,
		&i.CustomerID,
		&i.PurchaseOrderID,
		&i.SalesOrderID,
		&i.RootCause,
		&i.RootCauseAnalysisBy,
		&i.RootCauseDate,
		&i.CorrectiveAction,
		&i.PreventiveAction,
		&i.ActionAssignedTo,
		&i.ActionDueDate,
		&i.ActionCompletedDate,
		&i.Disposition,
		&i.CostImpact,
		&i.ReportedBy,
		&i.ReportedDate,
		&i.ClosedBy,
		&i.ClosedDate,
		&i.Attachments,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MaterialName,
		&i.MaterialSku,
		&i.SupplierName,
		&i.CustomerName,
		&i.ReportedByName,
		&i.ActionAssignedToName,
	)
	return i, err
}

const getNonConformanceReportByNumber = `-- name: GetNonConformanceReportByNumber :one
SELECT id, ncr_number, title, description, ncr_type, severity, status, material_id, batch_number, quantity_affected, unit_id, inspection_id, supplier_id, customer_id, purchase_order_id, sales_order_id, root_cause, root_cause_analysis_by, root_cause_date, corrective_action, preventive_action, action_assigned_to, action_due_date, action_completed_date, disposition, cost_impact, reported_by, reported_date, closed_by, closed_date, attachments, notes, created_at, updated_at FROM non_conformance_reports
WHERE ncr_number = $1
`

func (q *Queries) GetNonConformanceReportByNumber(ctx context.Context, ncrNumber string) (NonConformanceReport, error) {
	row := q.db.QueryRow(ctx, getNonConformanceReportByNumber, ncrNumber)
	var i NonConformanceReport
	err := row.Scan(
		&i.ID,
		&i.NcrNumber,
		&i.Title,
		&i.Description,
		&i.NcrType,
		&i.Severity,
		&i.Status,
		&i.MaterialID,
		&i.BatchNumber,
		&i.QuantityAffected,
		&i.UnitID,
		&i.InspectionID,
		&i.SupplierID,
		&i.CustomerID,
		&i.PurchaseOrderID,
		&i.SalesOrderID,
		&i.RootCause,
		&i.RootCauseAnalysisBy,
		&i.RootCauseDate,
		&i.CorrectiveAction,
		&i.PreventiveAction,
		&i.ActionAssignedTo,
		&i.ActionDueDate,
		&i.ActionCompletedDate,
		&i.Disposition,
		&i.CostImpact,
		&i.ReportedBy,
		&i.ReportedDate,
		&i.ClosedBy,
		&i.ClosedDate,
		&i.Attachments,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getQualityDashboardStats = `-- name: GetQualityDashboardStats :one

SELECT 
    (SELECT COUNT(*) FROM quality_inspections WHERE inspection_status = 'pending') as pending_inspections,
    (SELECT COUNT(*) FROM quality_inspections WHERE inspection_status = 'in_progress') as in_progress_inspections,
    (SELECT COUNT(*) FROM quality_holds WHERE is_released = FALSE) as active_holds,
    (SELECT COUNT(*) FROM non_conformance_reports WHERE status IN ('open', 'investigating', 'action_required', 'in_progress')) as open_ncrs,
    (SELECT COUNT(*) FROM non_conformance_reports WHERE status IN ('open', 'investigating', 'action_required', 'in_progress') AND action_due_date < CURRENT_DATE) as overdue_ncrs
`

type GetQualityDashboardStatsRow struct {
	PendingInspections    int64 `json:"pending_inspections"`
	InProgressInspections int64 `json:"in_progress_inspections"`
	ActiveHolds           int64 `json:"active_holds"`
	OpenNcrs              int64 `json:"open_ncrs"`
	OverdueNcrs           int64 `json:"overdue_ncrs"`
}

// ============================================================================
// STATISTICS & REPORTS
// ============================================================================
func (q *Queries) GetQualityDashboardStats(ctx context.Context) (GetQualityDashboardStatsRow, error) {
	row := q.db.QueryRow(ctx, getQualityDashboardStats)
	var i GetQualityDashboardStatsRow
	err := row.Scan(
		&i.PendingInspections,
		&i.InProgressInspections,
		&i.ActiveHolds,
		&i.OpenNcrs,
		&i.OverdueNcrs,
	)
	return i, err
}

const getQualityHoldByID = `-- name: GetQualityHoldByID :one
SELECT 
    qh.id, qh.hold_number, qh.material_id, qh.warehouse_id, qh.batch_number, qh.lot_number, qh.quantity, qh.unit_id, qh.quality_status, qh.hold_reason, qh.inspection_id, qh.ncr_id, qh.placed_by, qh.placed_date, qh.expected_release_date, qh.is_released, qh.released_by, qh.released_date, qh.release_notes, qh.created_at, qh.updated_at,
    m.name as material_name,
    m.sku as material_sku,
    w.name as warehouse_name,
    u.abbreviation as unit_abbreviation,
    placed.full_name as placed_by_name,
    released.full_name as released_by_name
FROM quality_holds qh
LEFT JOIN materials m ON qh.material_id = m.id
LEFT JOIN warehouses w ON qh.warehouse_id = w.id
LEFT JOIN measure_units u ON qh.unit_id = u.id
LEFT JOIN users placed ON qh.placed_by = placed.id
LEFT JOIN users released ON qh.released_by = released.id
WHERE qh.id = $1
`

type GetQualityHoldByIDRow struct {
	ID                  int32              `json:"id"`
	HoldNumber          string             `json:"hold_number"`
	MaterialID          int32              `json:"material_id"`
	WarehouseID         pgtype.Int4        `json:"warehouse_id"`
	BatchNumber         pgtype.Text        `json:"batch_number"`
	LotNumber           pgtype.Text        `json:"lot_number"`
	Quantity            pgtype.Numeric     `json:"quantity"`
	UnitID              pgtype.Int4        `json:"unit_id"`
	QualityStatus       QualityStatus      `json:"quality_status"`
	HoldReason          string             `json:"hold_reason"`
	InspectionID        pgtype.Int4        `json:"inspection_id"`
	NcrID               pgtype.Int4        `json:"ncr_id"`
	PlacedBy            pgtype.Int4        `json:"placed_by"`
	PlacedDate          pgtype.Timestamptz `json:"placed_date"`
	ExpectedReleaseDate pgtype.Date        `json:"expected_release_date"`
	IsReleased          pgtype.Bool        `json:"is_released"`
	ReleasedBy          pgtype.Int4        `json:"released_by"`
	ReleasedDate        pgtype.Timestamptz `json:"released_date"`
	ReleaseNotes        pgtype.Text        `json:"release_notes"`
	CreatedAt           pgtype.Timestamptz `json:"created_at"`
	UpdatedAt           pgtype.Timestamptz `json:"updated_at"`
	MaterialName        pgtype.Text        `json:"material_name"`
	MaterialSku         pgtype.Text        `json:"material_sku"`
	WarehouseName       pgtype.Text        `json:"warehouse_name"`
	UnitAbbreviation    pgtype.Text        `json:"unit_abbreviation"`
	PlacedByName        pgtype.Text        `json:"placed_by_name"`
	ReleasedByName      pgtype.Text        `json:"released_by_name"`
}

func (q *Queries) GetQualityHoldByID(ctx context.Context, id int32) (GetQualityHoldByIDRow, error) {
	row := q.db.QueryRow(ctx, getQualityHoldByID, id)
	var i GetQualityHoldByIDRow
	err := row.Scan(
		&i.ID,
		&i.HoldNumber,
		&i.MaterialID,
		&i.WarehouseID,
		&i.BatchNumber,
		&i.LotNumber,
		&i.Quantity,
		&i.UnitID,
		&i.QualityStatus,
		&i.HoldReason,
		&i.InspectionID,
		&i.NcrID,
		&i.PlacedBy,
		&i.PlacedDate,
		&i.ExpectedReleaseDate,
		&i.IsReleased,
		&i.ReleasedBy,
		&i.ReleasedDate,
		&i.ReleaseNotes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MaterialName,
		&i.MaterialSku,
		&i.WarehouseName,
		&i.UnitAbbreviation,
		&i.PlacedByName,
		&i.ReleasedByName,
	)
	return i, err
}

const getQualityHoldByNumber = `-- name: GetQualityHoldByNumber :one
SELECT id, hold_number, material_id, warehouse_id, batch_number, lot_number, quantity, unit_id, quality_status, hold_reason, inspection_id, ncr_id, placed_by, placed_date, expected_release_date, is_released, released_by, released_date, release_notes, created_at, updated_at FROM quality_holds
WHERE hold_number = $1
`

func (q *Queries) GetQualityHoldByNumber(ctx context.Context, holdNumber string) (QualityHold, error) {
	row := q.db.QueryRow(ctx, getQualityHoldByNumber, holdNumber)
	var i QualityHold
	err := row.Scan(
		&i.ID,
		&i.HoldNumber,
		&i.MaterialID,
		&i.WarehouseID,
		&i.BatchNumber,
		&i.LotNumber,
		&i.Quantity,
		&i.UnitID,
		&i.QualityStatus,
		&i.HoldReason,
		&i.InspectionID,
		&i.NcrID,
		&i.PlacedBy,
		&i.PlacedDate,
		&i.ExpectedReleaseDate,
		&i.IsReleased,
		&i.ReleasedBy,
		&i.ReleasedDate,
		&i.ReleaseNotes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getQualityInspectionByID = `-- name: GetQualityInspectionByID :one
SELECT 
    qi.id, qi.inspection_number, qi.inspection_type, qi.inspection_status, qi.material_id, qi.batch_number, qi.lot_number, qi.quantity, qi.unit_id, qi.purchase_order_id, qi.sales_order_id, qi.stock_movement_id, qi.supplier_id, qi.inspection_date, qi.inspector_id, qi.approved_by_id, qi.quantity_passed, qi.quantity_failed, qi.quantity_on_hold, qi.final_decision, qi.decision_date, qi.notes, qi.attachments, qi.created_at, qi.updated_at,
    m.name as material_name,
    m.sku as material_sku,
    u.abbreviation as unit_abbreviation,
    sup.name as supplier_name,
    insp.full_name as inspector_name,
    app.full_name as approved_by_name
FROM quality_inspections qi
LEFT JOIN materials m ON qi.material_id = m.id
LEFT JOIN measure_units u ON qi.unit_id = u.id
LEFT JOIN suppliers sup ON qi.supplier_id = sup.id
LEFT JOIN users insp ON qi.inspector_id = insp.id
LEFT JOIN users app ON qi.approved_by_id = app.id
WHERE qi.id = $1
`

type GetQualityInspectionByIDRow struct {
	ID               int32                       `json:"id"`
	InspectionNumber string                      `json:"inspection_number"`
	InspectionType   QualityInspectionType       `json:"inspection_type"`
	InspectionStatus NullQualityInspectionStatus `json:"inspection_status"`
	MaterialID       pgtype.Int4                 `json:"material_id"`
	BatchNumber      pgtype.Text                 `json:"batch_number"`
	LotNumber        pgtype.Text                 `json:"lot_number"`
	Quantity         pgtype.Numeric              `json:"quantity"`
	UnitID           pgtype.Int4                 `json:"unit_id"`
	PurchaseOrderID  pgtype.Int4                 `json:"purchase_order_id"`
	SalesOrderID     pgtype.Int4                 `json:"sales_order_id"`
	StockMovementID  pgtype.Int4                 `json:"stock_movement_id"`
	SupplierID       pgtype.Int4                 `json:"supplier_id"`
	InspectionDate   pgtype.Timestamptz          `json:"inspection_date"`
	InspectorID      pgtype.Int4                 `json:"inspector_id"`
	ApprovedByID     pgtype.Int4                 `json:"approved_by_id"`
	QuantityPassed   pgtype.Numeric              `json:"quantity_passed"`
	QuantityFailed   pgtype.Numeric              `json:"quantity_failed"`
	QuantityOnHold   pgtype.Numeric              `json:"quantity_on_hold"`
	FinalDecision    NullQualityStatus           `json:"final_decision"`
	DecisionDate     pgtype.Timestamptz          `json:"decision_date"`
	Notes            pgtype.Text                 `json:"notes"`
	Attachments      []byte                      `json:"attachments"`
	CreatedAt        pgtype.Timestamptz          `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz          `json:"updated_at"`
	MaterialName     pgtype.Text                 `json:"material_name"`
	MaterialSku      pgtype.Text                 `json:"material_sku"`
	UnitAbbreviation pgtype.Text                 `json:"unit_abbreviation"`
	SupplierName     pgtype.Text                 `json:"supplier_name"`
	InspectorName    pgtype.Text                 `json:"inspector_name"`
	ApprovedByName   pgtype.Text                 `json:"approved_by_name"`
}

func (q *Queries) GetQualityInspectionByID(ctx context.Context, id int32) (GetQualityInspectionByIDRow, error) {
	row := q.db.QueryRow(ctx, getQualityInspectionByID, id)
	var i GetQualityInspectionByIDRow
	err := row.Scan(
		&i.ID,
		&i.InspectionNumber,
		&i.InspectionType,
		&i.InspectionStatus,
		&i.MaterialID,
		&i.BatchNumber,
		&i.LotNumber,
		&i.Quantity,
		&i.UnitID,
		&i.PurchaseOrderID,
		&i.SalesOrderID,
		&i.StockMovementID,
		&i.SupplierID,
		&i.InspectionDate,
		&i.InspectorID,
		&i.ApprovedByID,
		&i.QuantityPassed,
		&i.QuantityFailed,
		&i.QuantityOnHold,
		&i.FinalDecision,
		&i.DecisionDate,
		&i.Notes,
		&i.Attachments,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MaterialName,
		&i.MaterialSku,
		&i.UnitAbbreviation,
		&i.SupplierName,
		&i.InspectorName,
		&i.ApprovedByName,
	)
	return i, err
}

const getQualityInspectionByNumber = `-- name: GetQualityInspectionByNumber :one
SELECT id, inspection_number, inspection_type, inspection_status, material_id, batch_number, lot_number, quantity, unit_id, purchase_order_id, sales_order_id, stock_movement_id, supplier_id, inspection_date, inspector_id, approved_by_id, quantity_passed, quantity_failed, quantity_on_hold, final_decision, decision_date, notes, attachments, created_at, updated_at FROM quality_inspections
WHERE inspection_number = $1
`

func (q *Queries) GetQualityInspectionByNumber(ctx context.Context, inspectionNumber string) (QualityInspection, error) {
	row := q.db.QueryRow(ctx, getQualityInspectionByNumber, inspectionNumber)
	var i QualityInspection
	err := row.Scan(
		&i.ID,
		&i.InspectionNumber,
		&i.InspectionType,
		&i.InspectionStatus,
		&i.MaterialID,
		&i.BatchNumber,
		&i.LotNumber,
		&i.Quantity,
		&i.UnitID,
		&i.PurchaseOrderID,
		&i.SalesOrderID,
		&i.StockMovementID,
		&i.SupplierID,
		&i.InspectionDate,
		&i.InspectorID,
		&i.ApprovedByID,
		&i.QuantityPassed,
		&i.QuantityFailed,
		&i.QuantityOnHold,
		&i.FinalDecision,
		&i.DecisionDate,
		&i.Notes,
		&i.Attachments,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getQualityInspectionCriteriaByID = `-- name: GetQualityInspectionCriteriaByID :one
SELECT id, name, description, criteria_type, specification, unit_id, tolerance_min, tolerance_max, is_critical, is_active, created_at, updated_at FROM quality_inspection_criteria
WHERE id = $1
`

func (q *Queries) GetQualityInspectionCriteriaByID(ctx context.Context, id int32) (QualityInspectionCriterium, error) {
	row := q.db.QueryRow(ctx, getQualityInspectionCriteriaByID, id)
	var i QualityInspectionCriterium
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CriteriaType,
		&i.Specification,
		&i.UnitID,
		&i.ToleranceMin,
		&i.ToleranceMax,
		&i.IsCritical,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getQualityInspectionResultByID = `-- name: GetQualityInspectionResultByID :one
SELECT id, inspection_id, criteria_id, criteria_name, measured_value, text_value, is_passed, deviation, sample_number, notes, photo_urls, created_at FROM quality_inspection_results
WHERE id = $1
`

func (q *Queries) GetQualityInspectionResultByID(ctx context.Context, id int32) (QualityInspectionResult, error) {
	row := q.db.QueryRow(ctx, getQualityInspectionResultByID, id)
	var i QualityInspectionResult
	err := row.Scan(
		&i.ID,
		&i.InspectionID,
		&i.CriteriaID,
		&i.CriteriaName,
		&i.MeasuredValue,
		&i.TextValue,
		&i.IsPassed,
		&i.Deviation,
		&i.SampleNumber,
		&i.Notes,
		&i.PhotoUrls,
		&i.CreatedAt,
	)
	return i, err
}

const getQualityInspectionTrends = `-- name: GetQualityInspectionTrends :many
SELECT 
    DATE_TRUNC('month', inspection_date) as month,
    COUNT(*) as total_inspections,
    COUNT(CASE WHEN inspection_status = 'passed' THEN 1 END) as passed,
    COUNT(CASE WHEN inspection_status = 'failed' THEN 1 END) as failed,
    ROUND(
        CASE 
            WHEN COUNT(*) > 0 
            THEN (COUNT(CASE WHEN inspection_status = 'passed' THEN 1 END)::DECIMAL / COUNT(*) * 100)
            ELSE 0 
        END, 
    2) as pass_rate
FROM quality_inspections
WHERE inspection_date >= $1 AND inspection_date <= $2
GROUP BY DATE_TRUNC('month', inspection_date)
ORDER BY month
`

type GetQualityInspectionTrendsParams struct {
	InspectionDate   pgtype.Timestamptz `json:"inspection_date"`
	InspectionDate_2 pgtype.Timestamptz `json:"inspection_date_2"`
}

type GetQualityInspectionTrendsRow struct {
	Month            pgtype.Interval `json:"month"`
	TotalInspections int64           `json:"total_inspections"`
	Passed           int64           `json:"passed"`
	Failed           int64           `json:"failed"`
	PassRate         pgtype.Numeric  `json:"pass_rate"`
}

func (q *Queries) GetQualityInspectionTrends(ctx context.Context, arg GetQualityInspectionTrendsParams) ([]GetQualityInspectionTrendsRow, error) {
	rows, err := q.db.Query(ctx, getQualityInspectionTrends, arg.InspectionDate, arg.InspectionDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetQualityInspectionTrendsRow{}
	for rows.Next() {
		var i GetQualityInspectionTrendsRow
		if err := rows.Scan(
			&i.Month,
			&i.TotalInspections,
			&i.Passed,
			&i.Failed,
			&i.PassRate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSupplierQualityRatingByID = `-- name: GetSupplierQualityRatingByID :one
SELECT 
    sqr.id, sqr.supplier_id, sqr.period_start, sqr.period_end, sqr.total_inspections, sqr.passed_inspections, sqr.failed_inspections, sqr.total_quantity_received, sqr.quantity_rejected, sqr.total_defects, sqr.critical_defects, sqr.major_defects, sqr.minor_defects, sqr.ncr_count, sqr.quality_score, sqr.defect_rate, sqr.rejection_rate, sqr.rating, sqr.notes, sqr.calculated_by, sqr.calculation_date, sqr.created_at, sqr.updated_at,
    s.name as supplier_name,
    u.full_name as calculated_by_name
FROM supplier_quality_ratings sqr
LEFT JOIN suppliers s ON sqr.supplier_id = s.id
LEFT JOIN users u ON sqr.calculated_by = u.id
WHERE sqr.id = $1
`

type GetSupplierQualityRatingByIDRow struct {
	ID                    int32              `json:"id"`
	SupplierID            int32              `json:"supplier_id"`
	PeriodStart           pgtype.Date        `json:"period_start"`
	PeriodEnd             pgtype.Date        `json:"period_end"`
	TotalInspections      pgtype.Int4        `json:"total_inspections"`
	PassedInspections     pgtype.Int4        `json:"passed_inspections"`
	FailedInspections     pgtype.Int4        `json:"failed_inspections"`
	TotalQuantityReceived pgtype.Numeric     `json:"total_quantity_received"`
	QuantityRejected      pgtype.Numeric     `json:"quantity_rejected"`
	TotalDefects          pgtype.Int4        `json:"total_defects"`
	CriticalDefects       pgtype.Int4        `json:"critical_defects"`
	MajorDefects          pgtype.Int4        `json:"major_defects"`
	MinorDefects          pgtype.Int4        `json:"minor_defects"`
	NcrCount              pgtype.Int4        `json:"ncr_count"`
	QualityScore          pgtype.Numeric     `json:"quality_score"`
	DefectRate            pgtype.Numeric     `json:"defect_rate"`
	RejectionRate         pgtype.Numeric     `json:"rejection_rate"`
	Rating                pgtype.Text        `json:"rating"`
	Notes                 pgtype.Text        `json:"notes"`
	CalculatedBy          pgtype.Int4        `json:"calculated_by"`
	CalculationDate       pgtype.Timestamptz `json:"calculation_date"`
	CreatedAt             pgtype.Timestamptz `json:"created_at"`
	UpdatedAt             pgtype.Timestamptz `json:"updated_at"`
	SupplierName          pgtype.Text        `json:"supplier_name"`
	CalculatedByName      pgtype.Text        `json:"calculated_by_name"`
}

func (q *Queries) GetSupplierQualityRatingByID(ctx context.Context, id int32) (GetSupplierQualityRatingByIDRow, error) {
	row := q.db.QueryRow(ctx, getSupplierQualityRatingByID, id)
	var i GetSupplierQualityRatingByIDRow
	err := row.Scan(
		&i.ID,
		&i.SupplierID,
		&i.PeriodStart,
		&i.PeriodEnd,
		&i.TotalInspections,
		&i.PassedInspections,
		&i.FailedInspections,
		&i.TotalQuantityReceived,
		&i.QuantityRejected,
		&i.TotalDefects,
		&i.CriticalDefects,
		&i.MajorDefects,
		&i.MinorDefects,
		&i.NcrCount,
		&i.QualityScore,
		&i.DefectRate,
		&i.RejectionRate,
		&i.Rating,
		&i.Notes,
		&i.CalculatedBy,
		&i.CalculationDate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SupplierName,
		&i.CalculatedByName,
	)
	return i, err
}

const getTopDefectiveMaterials = `-- name: GetTopDefectiveMaterials :many
SELECT 
    m.id,
    m.name,
    m.sku,
    COUNT(DISTINCT qi.id) as total_inspections,
    COUNT(DISTINCT CASE WHEN qi.inspection_status = 'failed' THEN qi.id END) as failed_inspections,
    COUNT(DISTINCT ncr.id) as ncr_count,
    ROUND(
        CASE 
            WHEN COUNT(DISTINCT qi.id) > 0 
            THEN (COUNT(DISTINCT CASE WHEN qi.inspection_status = 'failed' THEN qi.id END)::DECIMAL / COUNT(DISTINCT qi.id) * 100)
            ELSE 0 
        END, 
    2) as failure_rate
FROM materials m
LEFT JOIN quality_inspections qi ON m.id = qi.material_id
LEFT JOIN non_conformance_reports ncr ON m.id = ncr.material_id
GROUP BY m.id, m.name, m.sku
HAVING COUNT(DISTINCT qi.id) > 0
ORDER BY failure_rate DESC, ncr_count DESC
LIMIT $1
`

type GetTopDefectiveMaterialsRow struct {
	ID                int32          `json:"id"`
	Name              string         `json:"name"`
	Sku               string         `json:"sku"`
	TotalInspections  int64          `json:"total_inspections"`
	FailedInspections int64          `json:"failed_inspections"`
	NcrCount          int64          `json:"ncr_count"`
	FailureRate       pgtype.Numeric `json:"failure_rate"`
}

func (q *Queries) GetTopDefectiveMaterials(ctx context.Context, limit int32) ([]GetTopDefectiveMaterialsRow, error) {
	rows, err := q.db.Query(ctx, getTopDefectiveMaterials, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTopDefectiveMaterialsRow{}
	for rows.Next() {
		var i GetTopDefectiveMaterialsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Sku,
			&i.TotalInspections,
			&i.FailedInspections,
			&i.NcrCount,
			&i.FailureRate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveQualityHolds = `-- name: ListActiveQualityHolds :many
SELECT id, hold_number, material_id, warehouse_id, batch_number, lot_number, quantity, unit_id, quality_status, hold_reason, inspection_id, ncr_id, placed_by, placed_date, expected_release_date, is_released, released_by, released_date, release_notes, created_at, updated_at FROM quality_holds
WHERE is_released = FALSE
ORDER BY placed_date DESC
LIMIT $1 OFFSET $2
`

type ListActiveQualityHoldsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListActiveQualityHolds(ctx context.Context, arg ListActiveQualityHoldsParams) ([]QualityHold, error) {
	rows, err := q.db.Query(ctx, listActiveQualityHolds, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QualityHold{}
	for rows.Next() {
		var i QualityHold
		if err := rows.Scan(
			&i.ID,
			&i.HoldNumber,
			&i.MaterialID,
			&i.WarehouseID,
			&i.BatchNumber,
			&i.LotNumber,
			&i.Quantity,
			&i.UnitID,
			&i.QualityStatus,
			&i.HoldReason,
			&i.InspectionID,
			&i.NcrID,
			&i.PlacedBy,
			&i.PlacedDate,
			&i.ExpectedReleaseDate,
			&i.IsReleased,
			&i.ReleasedBy,
			&i.ReleasedDate,
			&i.ReleaseNotes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllQualityInspectionCriteria = `-- name: ListAllQualityInspectionCriteria :many
SELECT id, name, description, criteria_type, specification, unit_id, tolerance_min, tolerance_max, is_critical, is_active, created_at, updated_at FROM quality_inspection_criteria
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListAllQualityInspectionCriteriaParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListAllQualityInspectionCriteria(ctx context.Context, arg ListAllQualityInspectionCriteriaParams) ([]QualityInspectionCriterium, error) {
	rows, err := q.db.Query(ctx, listAllQualityInspectionCriteria, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QualityInspectionCriterium{}
	for rows.Next() {
		var i QualityInspectionCriterium
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CriteriaType,
			&i.Specification,
			&i.UnitID,
			&i.ToleranceMin,
			&i.ToleranceMax,
			&i.IsCritical,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFailedInspectionResults = `-- name: ListFailedInspectionResults :many
SELECT id, inspection_id, criteria_id, criteria_name, measured_value, text_value, is_passed, deviation, sample_number, notes, photo_urls, created_at FROM quality_inspection_results
WHERE inspection_id = $1 AND is_passed = FALSE
ORDER BY created_at
`

func (q *Queries) ListFailedInspectionResults(ctx context.Context, inspectionID int32) ([]QualityInspectionResult, error) {
	rows, err := q.db.Query(ctx, listFailedInspectionResults, inspectionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QualityInspectionResult{}
	for rows.Next() {
		var i QualityInspectionResult
		if err := rows.Scan(
			&i.ID,
			&i.InspectionID,
			&i.CriteriaID,
			&i.CriteriaName,
			&i.MeasuredValue,
			&i.TextValue,
			&i.IsPassed,
			&i.Deviation,
			&i.SampleNumber,
			&i.Notes,
			&i.PhotoUrls,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMaterialQualitySpecs = `-- name: ListMaterialQualitySpecs :many
SELECT 
    mqs.id, mqs.material_id, mqs.criteria_id, mqs.is_required, mqs.custom_tolerance_min, mqs.custom_tolerance_max, mqs.created_at, mqs.updated_at,
    m.name as material_name,
    qic.name as criteria_name,
    qic.criteria_type,
    qic.is_critical
FROM material_quality_specs mqs
LEFT JOIN materials m ON mqs.material_id = m.id
LEFT JOIN quality_inspection_criteria qic ON mqs.criteria_id = qic.id
WHERE mqs.material_id = $1
`

type ListMaterialQualitySpecsRow struct {
	ID                 int32              `json:"id"`
	MaterialID         int32              `json:"material_id"`
	CriteriaID         int32              `json:"criteria_id"`
	IsRequired         pgtype.Bool        `json:"is_required"`
	CustomToleranceMin pgtype.Numeric     `json:"custom_tolerance_min"`
	CustomToleranceMax pgtype.Numeric     `json:"custom_tolerance_max"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	MaterialName       pgtype.Text        `json:"material_name"`
	CriteriaName       pgtype.Text        `json:"criteria_name"`
	CriteriaType       pgtype.Text        `json:"criteria_type"`
	IsCritical         pgtype.Bool        `json:"is_critical"`
}

func (q *Queries) ListMaterialQualitySpecs(ctx context.Context, materialID int32) ([]ListMaterialQualitySpecsRow, error) {
	rows, err := q.db.Query(ctx, listMaterialQualitySpecs, materialID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListMaterialQualitySpecsRow{}
	for rows.Next() {
		var i ListMaterialQualitySpecsRow
		if err := rows.Scan(
			&i.ID,
			&i.MaterialID,
			&i.CriteriaID,
			&i.IsRequired,
			&i.CustomToleranceMin,
			&i.CustomToleranceMax,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MaterialName,
			&i.CriteriaName,
			&i.CriteriaType,
			&i.IsCritical,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNonConformanceReports = `-- name: ListNonConformanceReports :many
SELECT 
    ncr.id, ncr.ncr_number, ncr.title, ncr.ncr_type, ncr.severity, ncr.status,
    ncr.material_id, m.name as material_name,
    ncr.batch_number, ncr.quantity_affected,
    ncr.reported_date, ncr.action_due_date,
    rep.full_name as reported_by_name,
    assigned.full_name as action_assigned_to_name
FROM non_conformance_reports ncr
LEFT JOIN materials m ON ncr.material_id = m.id
LEFT JOIN users rep ON ncr.reported_by = rep.id
LEFT JOIN users assigned ON ncr.action_assigned_to = assigned.id
ORDER BY ncr.reported_date DESC
LIMIT $1 OFFSET $2
`

type ListNonConformanceReportsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListNonConformanceReportsRow struct {
	ID                   int32              `json:"id"`
	NcrNumber            string             `json:"ncr_number"`
	Title                string             `json:"title"`
	NcrType              NcrType            `json:"ncr_type"`
	Severity             NcrSeverity        `json:"severity"`
	Status               NullNcrStatus      `json:"status"`
	MaterialID           pgtype.Int4        `json:"material_id"`
	MaterialName         pgtype.Text        `json:"material_name"`
	BatchNumber          pgtype.Text        `json:"batch_number"`
	QuantityAffected     pgtype.Numeric     `json:"quantity_affected"`
	ReportedDate         pgtype.Timestamptz `json:"reported_date"`
	ActionDueDate        pgtype.Date        `json:"action_due_date"`
	ReportedByName       pgtype.Text        `json:"reported_by_name"`
	ActionAssignedToName pgtype.Text        `json:"action_assigned_to_name"`
}

func (q *Queries) ListNonConformanceReports(ctx context.Context, arg ListNonConformanceReportsParams) ([]ListNonConformanceReportsRow, error) {
	rows, err := q.db.Query(ctx, listNonConformanceReports, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListNonConformanceReportsRow{}
	for rows.Next() {
		var i ListNonConformanceReportsRow
		if err := rows.Scan(
			&i.ID,
			&i.NcrNumber,
			&i.Title,
			&i.NcrType,
			&i.Severity,
			&i.Status,
			&i.MaterialID,
			&i.MaterialName,
			&i.BatchNumber,
			&i.QuantityAffected,
			&i.ReportedDate,
			&i.ActionDueDate,
			&i.ReportedByName,
			&i.ActionAssignedToName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNonConformanceReportsByMaterial = `-- name: ListNonConformanceReportsByMaterial :many
SELECT id, ncr_number, title, description, ncr_type, severity, status, material_id, batch_number, quantity_affected, unit_id, inspection_id, supplier_id, customer_id, purchase_order_id, sales_order_id, root_cause, root_cause_analysis_by, root_cause_date, corrective_action, preventive_action, action_assigned_to, action_due_date, action_completed_date, disposition, cost_impact, reported_by, reported_date, closed_by, closed_date, attachments, notes, created_at, updated_at FROM non_conformance_reports
WHERE material_id = $1
ORDER BY reported_date DESC
`

func (q *Queries) ListNonConformanceReportsByMaterial(ctx context.Context, materialID pgtype.Int4) ([]NonConformanceReport, error) {
	rows, err := q.db.Query(ctx, listNonConformanceReportsByMaterial, materialID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []NonConformanceReport{}
	for rows.Next() {
		var i NonConformanceReport
		if err := rows.Scan(
			&i.ID,
			&i.NcrNumber,
			&i.Title,
			&i.Description,
			&i.NcrType,
			&i.Severity,
			&i.Status,
			&i.MaterialID,
			&i.BatchNumber,
			&i.QuantityAffected,
			&i.UnitID,
			&i.InspectionID,
			&i.SupplierID,
			&i.CustomerID,
			&i.PurchaseOrderID,
			&i.SalesOrderID,
			&i.RootCause,
			&i.RootCauseAnalysisBy,
			&i.RootCauseDate,
			&i.CorrectiveAction,
			&i.PreventiveAction,
			&i.ActionAssignedTo,
			&i.ActionDueDate,
			&i.ActionCompletedDate,
			&i.Disposition,
			&i.CostImpact,
			&i.ReportedBy,
			&i.ReportedDate,
			&i.ClosedBy,
			&i.ClosedDate,
			&i.Attachments,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNonConformanceReportsBySeverity = `-- name: ListNonConformanceReportsBySeverity :many
SELECT id, ncr_number, title, description, ncr_type, severity, status, material_id, batch_number, quantity_affected, unit_id, inspection_id, supplier_id, customer_id, purchase_order_id, sales_order_id, root_cause, root_cause_analysis_by, root_cause_date, corrective_action, preventive_action, action_assigned_to, action_due_date, action_completed_date, disposition, cost_impact, reported_by, reported_date, closed_by, closed_date, attachments, notes, created_at, updated_at FROM non_conformance_reports
WHERE severity = $1
ORDER BY reported_date DESC
LIMIT $2 OFFSET $3
`

type ListNonConformanceReportsBySeverityParams struct {
	Severity NcrSeverity `json:"severity"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

func (q *Queries) ListNonConformanceReportsBySeverity(ctx context.Context, arg ListNonConformanceReportsBySeverityParams) ([]NonConformanceReport, error) {
	rows, err := q.db.Query(ctx, listNonConformanceReportsBySeverity, arg.Severity, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []NonConformanceReport{}
	for rows.Next() {
		var i NonConformanceReport
		if err := rows.Scan(
			&i.ID,
			&i.NcrNumber,
			&i.Title,
			&i.Description,
			&i.NcrType,
			&i.Severity,
			&i.Status,
			&i.MaterialID,
			&i.BatchNumber,
			&i.QuantityAffected,
			&i.UnitID,
			&i.InspectionID,
			&i.SupplierID,
			&i.CustomerID,
			&i.PurchaseOrderID,
			&i.SalesOrderID,
			&i.RootCause,
			&i.RootCauseAnalysisBy,
			&i.RootCauseDate,
			&i.CorrectiveAction,
			&i.PreventiveAction,
			&i.ActionAssignedTo,
			&i.ActionDueDate,
			&i.ActionCompletedDate,
			&i.Disposition,
			&i.CostImpact,
			&i.ReportedBy,
			&i.ReportedDate,
			&i.ClosedBy,
			&i.ClosedDate,
			&i.Attachments,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNonConformanceReportsByStatus = `-- name: ListNonConformanceReportsByStatus :many
SELECT id, ncr_number, title, description, ncr_type, severity, status, material_id, batch_number, quantity_affected, unit_id, inspection_id, supplier_id, customer_id, purchase_order_id, sales_order_id, root_cause, root_cause_analysis_by, root_cause_date, corrective_action, preventive_action, action_assigned_to, action_due_date, action_completed_date, disposition, cost_impact, reported_by, reported_date, closed_by, closed_date, attachments, notes, created_at, updated_at FROM non_conformance_reports
WHERE status = $1
ORDER BY reported_date DESC
LIMIT $2 OFFSET $3
`

type ListNonConformanceReportsByStatusParams struct {
	Status NullNcrStatus `json:"status"`
	Limit  int32         `json:"limit"`
	Offset int32         `json:"offset"`
}

func (q *Queries) ListNonConformanceReportsByStatus(ctx context.Context, arg ListNonConformanceReportsByStatusParams) ([]NonConformanceReport, error) {
	rows, err := q.db.Query(ctx, listNonConformanceReportsByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []NonConformanceReport{}
	for rows.Next() {
		var i NonConformanceReport
		if err := rows.Scan(
			&i.ID,
			&i.NcrNumber,
			&i.Title,
			&i.Description,
			&i.NcrType,
			&i.Severity,
			&i.Status,
			&i.MaterialID,
			&i.BatchNumber,
			&i.QuantityAffected,
			&i.UnitID,
			&i.InspectionID,
			&i.SupplierID,
			&i.CustomerID,
			&i.PurchaseOrderID,
			&i.SalesOrderID,
			&i.RootCause,
			&i.RootCauseAnalysisBy,
			&i.RootCauseDate,
			&i.CorrectiveAction,
			&i.PreventiveAction,
			&i.ActionAssignedTo,
			&i.ActionDueDate,
			&i.ActionCompletedDate,
			&i.Disposition,
			&i.CostImpact,
			&i.ReportedBy,
			&i.ReportedDate,
			&i.ClosedBy,
			&i.ClosedDate,
			&i.Attachments,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNonConformanceReportsBySupplier = `-- name: ListNonConformanceReportsBySupplier :many
SELECT id, ncr_number, title, description, ncr_type, severity, status, material_id, batch_number, quantity_affected, unit_id, inspection_id, supplier_id, customer_id, purchase_order_id, sales_order_id, root_cause, root_cause_analysis_by, root_cause_date, corrective_action, preventive_action, action_assigned_to, action_due_date, action_completed_date, disposition, cost_impact, reported_by, reported_date, closed_by, closed_date, attachments, notes, created_at, updated_at FROM non_conformance_reports
WHERE supplier_id = $1
ORDER BY reported_date DESC
`

func (q *Queries) ListNonConformanceReportsBySupplier(ctx context.Context, supplierID pgtype.Int4) ([]NonConformanceReport, error) {
	rows, err := q.db.Query(ctx, listNonConformanceReportsBySupplier, supplierID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []NonConformanceReport{}
	for rows.Next() {
		var i NonConformanceReport
		if err := rows.Scan(
			&i.ID,
			&i.NcrNumber,
			&i.Title,
			&i.Description,
			&i.NcrType,
			&i.Severity,
			&i.Status,
			&i.MaterialID,
			&i.BatchNumber,
			&i.QuantityAffected,
			&i.UnitID,
			&i.InspectionID,
			&i.SupplierID,
			&i.CustomerID,
			&i.PurchaseOrderID,
			&i.SalesOrderID,
			&i.RootCause,
			&i.RootCauseAnalysisBy,
			&i.RootCauseDate,
			&i.CorrectiveAction,
			&i.PreventiveAction,
			&i.ActionAssignedTo,
			&i.ActionDueDate,
			&i.ActionCompletedDate,
			&i.Disposition,
			&i.CostImpact,
			&i.ReportedBy,
			&i.ReportedDate,
			&i.ClosedBy,
			&i.ClosedDate,
			&i.Attachments,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNonConformanceReportsByType = `-- name: ListNonConformanceReportsByType :many
SELECT id, ncr_number, title, description, ncr_type, severity, status, material_id, batch_number, quantity_affected, unit_id, inspection_id, supplier_id, customer_id, purchase_order_id, sales_order_id, root_cause, root_cause_analysis_by, root_cause_date, corrective_action, preventive_action, action_assigned_to, action_due_date, action_completed_date, disposition, cost_impact, reported_by, reported_date, closed_by, closed_date, attachments, notes, created_at, updated_at FROM non_conformance_reports
WHERE ncr_type = $1
ORDER BY reported_date DESC
LIMIT $2 OFFSET $3
`

type ListNonConformanceReportsByTypeParams struct {
	NcrType NcrType `json:"ncr_type"`
	Limit   int32   `json:"limit"`
	Offset  int32   `json:"offset"`
}

func (q *Queries) ListNonConformanceReportsByType(ctx context.Context, arg ListNonConformanceReportsByTypeParams) ([]NonConformanceReport, error) {
	rows, err := q.db.Query(ctx, listNonConformanceReportsByType, arg.NcrType, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []NonConformanceReport{}
	for rows.Next() {
		var i NonConformanceReport
		if err := rows.Scan(
			&i.ID,
			&i.NcrNumber,
			&i.Title,
			&i.Description,
			&i.NcrType,
			&i.Severity,
			&i.Status,
			&i.MaterialID,
			&i.BatchNumber,
			&i.QuantityAffected,
			&i.UnitID,
			&i.InspectionID,
			&i.SupplierID,
			&i.CustomerID,
			&i.PurchaseOrderID,
			&i.SalesOrderID,
			&i.RootCause,
			&i.RootCauseAnalysisBy,
			&i.RootCauseDate,
			&i.CorrectiveAction,
			&i.PreventiveAction,
			&i.ActionAssignedTo,
			&i.ActionDueDate,
			&i.ActionCompletedDate,
			&i.Disposition,
			&i.CostImpact,
			&i.ReportedBy,
			&i.ReportedDate,
			&i.ClosedBy,
			&i.ClosedDate,
			&i.Attachments,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOpenNonConformanceReports = `-- name: ListOpenNonConformanceReports :many
SELECT id, ncr_number, title, description, ncr_type, severity, status, material_id, batch_number, quantity_affected, unit_id, inspection_id, supplier_id, customer_id, purchase_order_id, sales_order_id, root_cause, root_cause_analysis_by, root_cause_date, corrective_action, preventive_action, action_assigned_to, action_due_date, action_completed_date, disposition, cost_impact, reported_by, reported_date, closed_by, closed_date, attachments, notes, created_at, updated_at FROM non_conformance_reports
WHERE status IN ('open', 'investigating', 'action_required', 'in_progress')
ORDER BY severity DESC, reported_date ASC
LIMIT $1 OFFSET $2
`

type ListOpenNonConformanceReportsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListOpenNonConformanceReports(ctx context.Context, arg ListOpenNonConformanceReportsParams) ([]NonConformanceReport, error) {
	rows, err := q.db.Query(ctx, listOpenNonConformanceReports, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []NonConformanceReport{}
	for rows.Next() {
		var i NonConformanceReport
		if err := rows.Scan(
			&i.ID,
			&i.NcrNumber,
			&i.Title,
			&i.Description,
			&i.NcrType,
			&i.Severity,
			&i.Status,
			&i.MaterialID,
			&i.BatchNumber,
			&i.QuantityAffected,
			&i.UnitID,
			&i.InspectionID,
			&i.SupplierID,
			&i.CustomerID,
			&i.PurchaseOrderID,
			&i.SalesOrderID,
			&i.RootCause,
			&i.RootCauseAnalysisBy,
			&i.RootCauseDate,
			&i.CorrectiveAction,
			&i.PreventiveAction,
			&i.ActionAssignedTo,
			&i.ActionDueDate,
			&i.ActionCompletedDate,
			&i.Disposition,
			&i.CostImpact,
			&i.ReportedBy,
			&i.ReportedDate,
			&i.ClosedBy,
			&i.ClosedDate,
			&i.Attachments,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOverdueNCRActions = `-- name: ListOverdueNCRActions :many
SELECT id, ncr_number, title, description, ncr_type, severity, status, material_id, batch_number, quantity_affected, unit_id, inspection_id, supplier_id, customer_id, purchase_order_id, sales_order_id, root_cause, root_cause_analysis_by, root_cause_date, corrective_action, preventive_action, action_assigned_to, action_due_date, action_completed_date, disposition, cost_impact, reported_by, reported_date, closed_by, closed_date, attachments, notes, created_at, updated_at FROM non_conformance_reports
WHERE status IN ('open', 'investigating', 'action_required', 'in_progress')
    AND action_due_date < CURRENT_DATE
ORDER BY action_due_date ASC
`

func (q *Queries) ListOverdueNCRActions(ctx context.Context) ([]NonConformanceReport, error) {
	rows, err := q.db.Query(ctx, listOverdueNCRActions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []NonConformanceReport{}
	for rows.Next() {
		var i NonConformanceReport
		if err := rows.Scan(
			&i.ID,
			&i.NcrNumber,
			&i.Title,
			&i.Description,
			&i.NcrType,
			&i.Severity,
			&i.Status,
			&i.MaterialID,
			&i.BatchNumber,
			&i.QuantityAffected,
			&i.UnitID,
			&i.InspectionID,
			&i.SupplierID,
			&i.CustomerID,
			&i.PurchaseOrderID,
			&i.SalesOrderID,
			&i.RootCause,
			&i.RootCauseAnalysisBy,
			&i.RootCauseDate,
			&i.CorrectiveAction,
			&i.PreventiveAction,
			&i.ActionAssignedTo,
			&i.ActionDueDate,
			&i.ActionCompletedDate,
			&i.Disposition,
			&i.CostImpact,
			&i.ReportedBy,
			&i.ReportedDate,
			&i.ClosedBy,
			&i.ClosedDate,
			&i.Attachments,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingInspections = `-- name: ListPendingInspections :many
SELECT id, inspection_number, inspection_type, inspection_status, material_id, batch_number, lot_number, quantity, unit_id, purchase_order_id, sales_order_id, stock_movement_id, supplier_id, inspection_date, inspector_id, approved_by_id, quantity_passed, quantity_failed, quantity_on_hold, final_decision, decision_date, notes, attachments, created_at, updated_at FROM quality_inspections
WHERE inspection_status IN ('pending', 'in_progress')
ORDER BY inspection_date ASC, created_at ASC
LIMIT $1 OFFSET $2
`

type ListPendingInspectionsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListPendingInspections(ctx context.Context, arg ListPendingInspectionsParams) ([]QualityInspection, error) {
	rows, err := q.db.Query(ctx, listPendingInspections, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QualityInspection{}
	for rows.Next() {
		var i QualityInspection
		if err := rows.Scan(
			&i.ID,
			&i.InspectionNumber,
			&i.InspectionType,
			&i.InspectionStatus,
			&i.MaterialID,
			&i.BatchNumber,
			&i.LotNumber,
			&i.Quantity,
			&i.UnitID,
			&i.PurchaseOrderID,
			&i.SalesOrderID,
			&i.StockMovementID,
			&i.SupplierID,
			&i.InspectionDate,
			&i.InspectorID,
			&i.ApprovedByID,
			&i.QuantityPassed,
			&i.QuantityFailed,
			&i.QuantityOnHold,
			&i.FinalDecision,
			&i.DecisionDate,
			&i.Notes,
			&i.Attachments,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQualityHolds = `-- name: ListQualityHolds :many
SELECT 
    qh.id, qh.hold_number, qh.quality_status,
    qh.material_id, m.name as material_name, m.sku as material_sku,
    qh.batch_number, qh.quantity, u.abbreviation as unit_abbreviation,
    w.name as warehouse_name,
    qh.hold_reason, qh.placed_date, qh.expected_release_date,
    qh.is_released, qh.released_date,
    placed.full_name as placed_by_name
FROM quality_holds qh
LEFT JOIN materials m ON qh.material_id = m.id
LEFT JOIN warehouses w ON qh.warehouse_id = w.id
LEFT JOIN measure_units u ON qh.unit_id = u.id
LEFT JOIN users placed ON qh.placed_by = placed.id
ORDER BY qh.placed_date DESC
LIMIT $1 OFFSET $2
`

type ListQualityHoldsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListQualityHoldsRow struct {
	ID                  int32              `json:"id"`
	HoldNumber          string             `json:"hold_number"`
	QualityStatus       QualityStatus      `json:"quality_status"`
	MaterialID          int32              `json:"material_id"`
	MaterialName        pgtype.Text        `json:"material_name"`
	MaterialSku         pgtype.Text        `json:"material_sku"`
	BatchNumber         pgtype.Text        `json:"batch_number"`
	Quantity            pgtype.Numeric     `json:"quantity"`
	UnitAbbreviation    pgtype.Text        `json:"unit_abbreviation"`
	WarehouseName       pgtype.Text        `json:"warehouse_name"`
	HoldReason          string             `json:"hold_reason"`
	PlacedDate          pgtype.Timestamptz `json:"placed_date"`
	ExpectedReleaseDate pgtype.Date        `json:"expected_release_date"`
	IsReleased          pgtype.Bool        `json:"is_released"`
	ReleasedDate        pgtype.Timestamptz `json:"released_date"`
	PlacedByName        pgtype.Text        `json:"placed_by_name"`
}

func (q *Queries) ListQualityHolds(ctx context.Context, arg ListQualityHoldsParams) ([]ListQualityHoldsRow, error) {
	rows, err := q.db.Query(ctx, listQualityHolds, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListQualityHoldsRow{}
	for rows.Next() {
		var i ListQualityHoldsRow
		if err := rows.Scan(
			&i.ID,
			&i.HoldNumber,
			&i.QualityStatus,
			&i.MaterialID,
			&i.MaterialName,
			&i.MaterialSku,
			&i.BatchNumber,
			&i.Quantity,
			&i.UnitAbbreviation,
			&i.WarehouseName,
			&i.HoldReason,
			&i.PlacedDate,
			&i.ExpectedReleaseDate,
			&i.IsReleased,
			&i.ReleasedDate,
			&i.PlacedByName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQualityHoldsByBatch = `-- name: ListQualityHoldsByBatch :many
SELECT id, hold_number, material_id, warehouse_id, batch_number, lot_number, quantity, unit_id, quality_status, hold_reason, inspection_id, ncr_id, placed_by, placed_date, expected_release_date, is_released, released_by, released_date, release_notes, created_at, updated_at FROM quality_holds
WHERE batch_number = $1
ORDER BY placed_date DESC
`

func (q *Queries) ListQualityHoldsByBatch(ctx context.Context, batchNumber pgtype.Text) ([]QualityHold, error) {
	rows, err := q.db.Query(ctx, listQualityHoldsByBatch, batchNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QualityHold{}
	for rows.Next() {
		var i QualityHold
		if err := rows.Scan(
			&i.ID,
			&i.HoldNumber,
			&i.MaterialID,
			&i.WarehouseID,
			&i.BatchNumber,
			&i.LotNumber,
			&i.Quantity,
			&i.UnitID,
			&i.QualityStatus,
			&i.HoldReason,
			&i.InspectionID,
			&i.NcrID,
			&i.PlacedBy,
			&i.PlacedDate,
			&i.ExpectedReleaseDate,
			&i.IsReleased,
			&i.ReleasedBy,
			&i.ReleasedDate,
			&i.ReleaseNotes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQualityHoldsByMaterial = `-- name: ListQualityHoldsByMaterial :many
SELECT id, hold_number, material_id, warehouse_id, batch_number, lot_number, quantity, unit_id, quality_status, hold_reason, inspection_id, ncr_id, placed_by, placed_date, expected_release_date, is_released, released_by, released_date, release_notes, created_at, updated_at FROM quality_holds
WHERE material_id = $1
ORDER BY placed_date DESC
`

func (q *Queries) ListQualityHoldsByMaterial(ctx context.Context, materialID int32) ([]QualityHold, error) {
	rows, err := q.db.Query(ctx, listQualityHoldsByMaterial, materialID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QualityHold{}
	for rows.Next() {
		var i QualityHold
		if err := rows.Scan(
			&i.ID,
			&i.HoldNumber,
			&i.MaterialID,
			&i.WarehouseID,
			&i.BatchNumber,
			&i.LotNumber,
			&i.Quantity,
			&i.UnitID,
			&i.QualityStatus,
			&i.HoldReason,
			&i.InspectionID,
			&i.NcrID,
			&i.PlacedBy,
			&i.PlacedDate,
			&i.ExpectedReleaseDate,
			&i.IsReleased,
			&i.ReleasedBy,
			&i.ReleasedDate,
			&i.ReleaseNotes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQualityHoldsByStatus = `-- name: ListQualityHoldsByStatus :many
SELECT id, hold_number, material_id, warehouse_id, batch_number, lot_number, quantity, unit_id, quality_status, hold_reason, inspection_id, ncr_id, placed_by, placed_date, expected_release_date, is_released, released_by, released_date, release_notes, created_at, updated_at FROM quality_holds
WHERE quality_status = $1 AND is_released = FALSE
ORDER BY placed_date DESC
LIMIT $2 OFFSET $3
`

type ListQualityHoldsByStatusParams struct {
	QualityStatus QualityStatus `json:"quality_status"`
	Limit         int32         `json:"limit"`
	Offset        int32         `json:"offset"`
}

func (q *Queries) ListQualityHoldsByStatus(ctx context.Context, arg ListQualityHoldsByStatusParams) ([]QualityHold, error) {
	rows, err := q.db.Query(ctx, listQualityHoldsByStatus, arg.QualityStatus, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QualityHold{}
	for rows.Next() {
		var i QualityHold
		if err := rows.Scan(
			&i.ID,
			&i.HoldNumber,
			&i.MaterialID,
			&i.WarehouseID,
			&i.BatchNumber,
			&i.LotNumber,
			&i.Quantity,
			&i.UnitID,
			&i.QualityStatus,
			&i.HoldReason,
			&i.InspectionID,
			&i.NcrID,
			&i.PlacedBy,
			&i.PlacedDate,
			&i.ExpectedReleaseDate,
			&i.IsReleased,
			&i.ReleasedBy,
			&i.ReleasedDate,
			&i.ReleaseNotes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQualityInspectionCriteria = `-- name: ListQualityInspectionCriteria :many
SELECT id, name, description, criteria_type, specification, unit_id, tolerance_min, tolerance_max, is_critical, is_active, created_at, updated_at FROM quality_inspection_criteria
WHERE is_active = TRUE
ORDER BY name
`

func (q *Queries) ListQualityInspectionCriteria(ctx context.Context) ([]QualityInspectionCriterium, error) {
	rows, err := q.db.Query(ctx, listQualityInspectionCriteria)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QualityInspectionCriterium{}
	for rows.Next() {
		var i QualityInspectionCriterium
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CriteriaType,
			&i.Specification,
			&i.UnitID,
			&i.ToleranceMin,
			&i.ToleranceMax,
			&i.IsCritical,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQualityInspectionResults = `-- name: ListQualityInspectionResults :many
SELECT 
    qir.id, qir.inspection_id, qir.criteria_id, qir.criteria_name, qir.measured_value, qir.text_value, qir.is_passed, qir.deviation, qir.sample_number, qir.notes, qir.photo_urls, qir.created_at,
    qic.name as criteria_name,
    qic.criteria_type,
    qic.tolerance_min,
    qic.tolerance_max,
    qic.is_critical
FROM quality_inspection_results qir
LEFT JOIN quality_inspection_criteria qic ON qir.criteria_id = qic.id
WHERE qir.inspection_id = $1
ORDER BY qir.created_at
`

type ListQualityInspectionResultsRow struct {
	ID             int32              `json:"id"`
	InspectionID   int32              `json:"inspection_id"`
	CriteriaID     pgtype.Int4        `json:"criteria_id"`
	CriteriaName   string             `json:"criteria_name"`
	MeasuredValue  pgtype.Numeric     `json:"measured_value"`
	TextValue      pgtype.Text        `json:"text_value"`
	IsPassed       pgtype.Bool        `json:"is_passed"`
	Deviation      pgtype.Numeric     `json:"deviation"`
	SampleNumber   pgtype.Int4        `json:"sample_number"`
	Notes          pgtype.Text        `json:"notes"`
	PhotoUrls      []byte             `json:"photo_urls"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	CriteriaName_2 pgtype.Text        `json:"criteria_name_2"`
	CriteriaType   pgtype.Text        `json:"criteria_type"`
	ToleranceMin   pgtype.Numeric     `json:"tolerance_min"`
	ToleranceMax   pgtype.Numeric     `json:"tolerance_max"`
	IsCritical     pgtype.Bool        `json:"is_critical"`
}

func (q *Queries) ListQualityInspectionResults(ctx context.Context, inspectionID int32) ([]ListQualityInspectionResultsRow, error) {
	rows, err := q.db.Query(ctx, listQualityInspectionResults, inspectionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListQualityInspectionResultsRow{}
	for rows.Next() {
		var i ListQualityInspectionResultsRow
		if err := rows.Scan(
			&i.ID,
			&i.InspectionID,
			&i.CriteriaID,
			&i.CriteriaName,
			&i.MeasuredValue,
			&i.TextValue,
			&i.IsPassed,
			&i.Deviation,
			&i.SampleNumber,
			&i.Notes,
			&i.PhotoUrls,
			&i.CreatedAt,
			&i.CriteriaName_2,
			&i.CriteriaType,
			&i.ToleranceMin,
			&i.ToleranceMax,
			&i.IsCritical,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQualityInspections = `-- name: ListQualityInspections :many
SELECT 
    qi.id, qi.inspection_number, qi.inspection_type, qi.inspection_status,
    qi.material_id, m.name as material_name, m.sku as material_sku,
    qi.batch_number, qi.quantity, u.abbreviation as unit_abbreviation,
    qi.inspection_date, qi.final_decision,
    sup.name as supplier_name,
    insp.full_name as inspector_name,
    qi.created_at
FROM quality_inspections qi
LEFT JOIN materials m ON qi.material_id = m.id
LEFT JOIN measure_units u ON qi.unit_id = u.id
LEFT JOIN suppliers sup ON qi.supplier_id = sup.id
LEFT JOIN users insp ON qi.inspector_id = insp.id
ORDER BY qi.created_at DESC
LIMIT $1 OFFSET $2
`

type ListQualityInspectionsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListQualityInspectionsRow struct {
	ID               int32                       `json:"id"`
	InspectionNumber string                      `json:"inspection_number"`
	InspectionType   QualityInspectionType       `json:"inspection_type"`
	InspectionStatus NullQualityInspectionStatus `json:"inspection_status"`
	MaterialID       pgtype.Int4                 `json:"material_id"`
	MaterialName     pgtype.Text                 `json:"material_name"`
	MaterialSku      pgtype.Text                 `json:"material_sku"`
	BatchNumber      pgtype.Text                 `json:"batch_number"`
	Quantity         pgtype.Numeric              `json:"quantity"`
	UnitAbbreviation pgtype.Text                 `json:"unit_abbreviation"`
	InspectionDate   pgtype.Timestamptz          `json:"inspection_date"`
	FinalDecision    NullQualityStatus           `json:"final_decision"`
	SupplierName     pgtype.Text                 `json:"supplier_name"`
	InspectorName    pgtype.Text                 `json:"inspector_name"`
	CreatedAt        pgtype.Timestamptz          `json:"created_at"`
}

func (q *Queries) ListQualityInspections(ctx context.Context, arg ListQualityInspectionsParams) ([]ListQualityInspectionsRow, error) {
	rows, err := q.db.Query(ctx, listQualityInspections, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListQualityInspectionsRow{}
	for rows.Next() {
		var i ListQualityInspectionsRow
		if err := rows.Scan(
			&i.ID,
			&i.InspectionNumber,
			&i.InspectionType,
			&i.InspectionStatus,
			&i.MaterialID,
			&i.MaterialName,
			&i.MaterialSku,
			&i.BatchNumber,
			&i.Quantity,
			&i.UnitAbbreviation,
			&i.InspectionDate,
			&i.FinalDecision,
			&i.SupplierName,
			&i.InspectorName,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQualityInspectionsByBatch = `-- name: ListQualityInspectionsByBatch :many
SELECT id, inspection_number, inspection_type, inspection_status, material_id, batch_number, lot_number, quantity, unit_id, purchase_order_id, sales_order_id, stock_movement_id, supplier_id, inspection_date, inspector_id, approved_by_id, quantity_passed, quantity_failed, quantity_on_hold, final_decision, decision_date, notes, attachments, created_at, updated_at FROM quality_inspections
WHERE batch_number = $1
ORDER BY created_at DESC
`

func (q *Queries) ListQualityInspectionsByBatch(ctx context.Context, batchNumber pgtype.Text) ([]QualityInspection, error) {
	rows, err := q.db.Query(ctx, listQualityInspectionsByBatch, batchNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QualityInspection{}
	for rows.Next() {
		var i QualityInspection
		if err := rows.Scan(
			&i.ID,
			&i.InspectionNumber,
			&i.InspectionType,
			&i.InspectionStatus,
			&i.MaterialID,
			&i.BatchNumber,
			&i.LotNumber,
			&i.Quantity,
			&i.UnitID,
			&i.PurchaseOrderID,
			&i.SalesOrderID,
			&i.StockMovementID,
			&i.SupplierID,
			&i.InspectionDate,
			&i.InspectorID,
			&i.ApprovedByID,
			&i.QuantityPassed,
			&i.QuantityFailed,
			&i.QuantityOnHold,
			&i.FinalDecision,
			&i.DecisionDate,
			&i.Notes,
			&i.Attachments,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQualityInspectionsByMaterial = `-- name: ListQualityInspectionsByMaterial :many
SELECT id, inspection_number, inspection_type, inspection_status, material_id, batch_number, lot_number, quantity, unit_id, purchase_order_id, sales_order_id, stock_movement_id, supplier_id, inspection_date, inspector_id, approved_by_id, quantity_passed, quantity_failed, quantity_on_hold, final_decision, decision_date, notes, attachments, created_at, updated_at FROM quality_inspections
WHERE material_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListQualityInspectionsByMaterialParams struct {
	MaterialID pgtype.Int4 `json:"material_id"`
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
}

func (q *Queries) ListQualityInspectionsByMaterial(ctx context.Context, arg ListQualityInspectionsByMaterialParams) ([]QualityInspection, error) {
	rows, err := q.db.Query(ctx, listQualityInspectionsByMaterial, arg.MaterialID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QualityInspection{}
	for rows.Next() {
		var i QualityInspection
		if err := rows.Scan(
			&i.ID,
			&i.InspectionNumber,
			&i.InspectionType,
			&i.InspectionStatus,
			&i.MaterialID,
			&i.BatchNumber,
			&i.LotNumber,
			&i.Quantity,
			&i.UnitID,
			&i.PurchaseOrderID,
			&i.SalesOrderID,
			&i.StockMovementID,
			&i.SupplierID,
			&i.InspectionDate,
			&i.InspectorID,
			&i.ApprovedByID,
			&i.QuantityPassed,
			&i.QuantityFailed,
			&i.QuantityOnHold,
			&i.FinalDecision,
			&i.DecisionDate,
			&i.Notes,
			&i.Attachments,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQualityInspectionsByStatus = `-- name: ListQualityInspectionsByStatus :many
SELECT id, inspection_number, inspection_type, inspection_status, material_id, batch_number, lot_number, quantity, unit_id, purchase_order_id, sales_order_id, stock_movement_id, supplier_id, inspection_date, inspector_id, approved_by_id, quantity_passed, quantity_failed, quantity_on_hold, final_decision, decision_date, notes, attachments, created_at, updated_at FROM quality_inspections
WHERE inspection_status = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListQualityInspectionsByStatusParams struct {
	InspectionStatus NullQualityInspectionStatus `json:"inspection_status"`
	Limit            int32                       `json:"limit"`
	Offset           int32                       `json:"offset"`
}

func (q *Queries) ListQualityInspectionsByStatus(ctx context.Context, arg ListQualityInspectionsByStatusParams) ([]QualityInspection, error) {
	rows, err := q.db.Query(ctx, listQualityInspectionsByStatus, arg.InspectionStatus, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QualityInspection{}
	for rows.Next() {
		var i QualityInspection
		if err := rows.Scan(
			&i.ID,
			&i.InspectionNumber,
			&i.InspectionType,
			&i.InspectionStatus,
			&i.MaterialID,
			&i.BatchNumber,
			&i.LotNumber,
			&i.Quantity,
			&i.UnitID,
			&i.PurchaseOrderID,
			&i.SalesOrderID,
			&i.StockMovementID,
			&i.SupplierID,
			&i.InspectionDate,
			&i.InspectorID,
			&i.ApprovedByID,
			&i.QuantityPassed,
			&i.QuantityFailed,
			&i.QuantityOnHold,
			&i.FinalDecision,
			&i.DecisionDate,
			&i.Notes,
			&i.Attachments,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQualityInspectionsBySupplier = `-- name: ListQualityInspectionsBySupplier :many
SELECT id, inspection_number, inspection_type, inspection_status, material_id, batch_number, lot_number, quantity, unit_id, purchase_order_id, sales_order_id, stock_movement_id, supplier_id, inspection_date, inspector_id, approved_by_id, quantity_passed, quantity_failed, quantity_on_hold, final_decision, decision_date, notes, attachments, created_at, updated_at FROM quality_inspections
WHERE supplier_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListQualityInspectionsBySupplierParams struct {
	SupplierID pgtype.Int4 `json:"supplier_id"`
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
}

func (q *Queries) ListQualityInspectionsBySupplier(ctx context.Context, arg ListQualityInspectionsBySupplierParams) ([]QualityInspection, error) {
	rows, err := q.db.Query(ctx, listQualityInspectionsBySupplier, arg.SupplierID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QualityInspection{}
	for rows.Next() {
		var i QualityInspection
		if err := rows.Scan(
			&i.ID,
			&i.InspectionNumber,
			&i.InspectionType,
			&i.InspectionStatus,
			&i.MaterialID,
			&i.BatchNumber,
			&i.LotNumber,
			&i.Quantity,
			&i.UnitID,
			&i.PurchaseOrderID,
			&i.SalesOrderID,
			&i.StockMovementID,
			&i.SupplierID,
			&i.InspectionDate,
			&i.InspectorID,
			&i.ApprovedByID,
			&i.QuantityPassed,
			&i.QuantityFailed,
			&i.QuantityOnHold,
			&i.FinalDecision,
			&i.DecisionDate,
			&i.Notes,
			&i.Attachments,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQualityInspectionsByType = `-- name: ListQualityInspectionsByType :many
SELECT id, inspection_number, inspection_type, inspection_status, material_id, batch_number, lot_number, quantity, unit_id, purchase_order_id, sales_order_id, stock_movement_id, supplier_id, inspection_date, inspector_id, approved_by_id, quantity_passed, quantity_failed, quantity_on_hold, final_decision, decision_date, notes, attachments, created_at, updated_at FROM quality_inspections
WHERE inspection_type = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListQualityInspectionsByTypeParams struct {
	InspectionType QualityInspectionType `json:"inspection_type"`
	Limit          int32                 `json:"limit"`
	Offset         int32                 `json:"offset"`
}

func (q *Queries) ListQualityInspectionsByType(ctx context.Context, arg ListQualityInspectionsByTypeParams) ([]QualityInspection, error) {
	rows, err := q.db.Query(ctx, listQualityInspectionsByType, arg.InspectionType, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QualityInspection{}
	for rows.Next() {
		var i QualityInspection
		if err := rows.Scan(
			&i.ID,
			&i.InspectionNumber,
			&i.InspectionType,
			&i.InspectionStatus,
			&i.MaterialID,
			&i.BatchNumber,
			&i.LotNumber,
			&i.Quantity,
			&i.UnitID,
			&i.PurchaseOrderID,
			&i.SalesOrderID,
			&i.StockMovementID,
			&i.SupplierID,
			&i.InspectionDate,
			&i.InspectorID,
			&i.ApprovedByID,
			&i.QuantityPassed,
			&i.QuantityFailed,
			&i.QuantityOnHold,
			&i.FinalDecision,
			&i.DecisionDate,
			&i.Notes,
			&i.Attachments,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSupplierQualityRatings = `-- name: ListSupplierQualityRatings :many
SELECT 
    sqr.id, sqr.supplier_id, sqr.period_start, sqr.period_end, sqr.total_inspections, sqr.passed_inspections, sqr.failed_inspections, sqr.total_quantity_received, sqr.quantity_rejected, sqr.total_defects, sqr.critical_defects, sqr.major_defects, sqr.minor_defects, sqr.ncr_count, sqr.quality_score, sqr.defect_rate, sqr.rejection_rate, sqr.rating, sqr.notes, sqr.calculated_by, sqr.calculation_date, sqr.created_at, sqr.updated_at,
    s.name as supplier_name
FROM supplier_quality_ratings sqr
LEFT JOIN suppliers s ON sqr.supplier_id = s.id
ORDER BY sqr.period_end DESC, sqr.quality_score DESC
LIMIT $1 OFFSET $2
`

type ListSupplierQualityRatingsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListSupplierQualityRatingsRow struct {
	ID                    int32              `json:"id"`
	SupplierID            int32              `json:"supplier_id"`
	PeriodStart           pgtype.Date        `json:"period_start"`
	PeriodEnd             pgtype.Date        `json:"period_end"`
	TotalInspections      pgtype.Int4        `json:"total_inspections"`
	PassedInspections     pgtype.Int4        `json:"passed_inspections"`
	FailedInspections     pgtype.Int4        `json:"failed_inspections"`
	TotalQuantityReceived pgtype.Numeric     `json:"total_quantity_received"`
	QuantityRejected      pgtype.Numeric     `json:"quantity_rejected"`
	TotalDefects          pgtype.Int4        `json:"total_defects"`
	CriticalDefects       pgtype.Int4        `json:"critical_defects"`
	MajorDefects          pgtype.Int4        `json:"major_defects"`
	MinorDefects          pgtype.Int4        `json:"minor_defects"`
	NcrCount              pgtype.Int4        `json:"ncr_count"`
	QualityScore          pgtype.Numeric     `json:"quality_score"`
	DefectRate            pgtype.Numeric     `json:"defect_rate"`
	RejectionRate         pgtype.Numeric     `json:"rejection_rate"`
	Rating                pgtype.Text        `json:"rating"`
	Notes                 pgtype.Text        `json:"notes"`
	CalculatedBy          pgtype.Int4        `json:"calculated_by"`
	CalculationDate       pgtype.Timestamptz `json:"calculation_date"`
	CreatedAt             pgtype.Timestamptz `json:"created_at"`
	UpdatedAt             pgtype.Timestamptz `json:"updated_at"`
	SupplierName          pgtype.Text        `json:"supplier_name"`
}

func (q *Queries) ListSupplierQualityRatings(ctx context.Context, arg ListSupplierQualityRatingsParams) ([]ListSupplierQualityRatingsRow, error) {
	rows, err := q.db.Query(ctx, listSupplierQualityRatings, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSupplierQualityRatingsRow{}
	for rows.Next() {
		var i ListSupplierQualityRatingsRow
		if err := rows.Scan(
			&i.ID,
			&i.SupplierID,
			&i.PeriodStart,
			&i.PeriodEnd,
			&i.TotalInspections,
			&i.PassedInspections,
			&i.FailedInspections,
			&i.TotalQuantityReceived,
			&i.QuantityRejected,
			&i.TotalDefects,
			&i.CriticalDefects,
			&i.MajorDefects,
			&i.MinorDefects,
			&i.NcrCount,
			&i.QualityScore,
			&i.DefectRate,
			&i.RejectionRate,
			&i.Rating,
			&i.Notes,
			&i.CalculatedBy,
			&i.CalculationDate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SupplierName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSupplierQualityRatingsBySupplier = `-- name: ListSupplierQualityRatingsBySupplier :many
SELECT id, supplier_id, period_start, period_end, total_inspections, passed_inspections, failed_inspections, total_quantity_received, quantity_rejected, total_defects, critical_defects, major_defects, minor_defects, ncr_count, quality_score, defect_rate, rejection_rate, rating, notes, calculated_by, calculation_date, created_at, updated_at FROM supplier_quality_ratings
WHERE supplier_id = $1
ORDER BY period_end DESC
`

func (q *Queries) ListSupplierQualityRatingsBySupplier(ctx context.Context, supplierID int32) ([]SupplierQualityRating, error) {
	rows, err := q.db.Query(ctx, listSupplierQualityRatingsBySupplier, supplierID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SupplierQualityRating{}
	for rows.Next() {
		var i SupplierQualityRating
		if err := rows.Scan(
			&i.ID,
			&i.SupplierID,
			&i.PeriodStart,
			&i.PeriodEnd,
			&i.TotalInspections,
			&i.PassedInspections,
			&i.FailedInspections,
			&i.TotalQuantityReceived,
			&i.QuantityRejected,
			&i.TotalDefects,
			&i.CriticalDefects,
			&i.MajorDefects,
			&i.MinorDefects,
			&i.NcrCount,
			&i.QualityScore,
			&i.DefectRate,
			&i.RejectionRate,
			&i.Rating,
			&i.Notes,
			&i.CalculatedBy,
			&i.CalculationDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSuppliersByQualityRating = `-- name: ListSuppliersByQualityRating :many
SELECT 
    s.id,
    s.name,
    sqr.quality_score,
    sqr.rating,
    sqr.defect_rate,
    sqr.rejection_rate,
    sqr.period_end
FROM suppliers s
LEFT JOIN LATERAL (
    SELECT id, supplier_id, period_start, period_end, total_inspections, passed_inspections, failed_inspections, total_quantity_received, quantity_rejected, total_defects, critical_defects, major_defects, minor_defects, ncr_count, quality_score, defect_rate, rejection_rate, rating, notes, calculated_by, calculation_date, created_at, updated_at FROM supplier_quality_ratings
    WHERE supplier_id = s.id
    ORDER BY period_end DESC
    LIMIT 1
) sqr ON TRUE
ORDER BY sqr.quality_score DESC NULLS LAST
`

type ListSuppliersByQualityRatingRow struct {
	ID            int32          `json:"id"`
	Name          string         `json:"name"`
	QualityScore  pgtype.Numeric `json:"quality_score"`
	Rating        pgtype.Text    `json:"rating"`
	DefectRate    pgtype.Numeric `json:"defect_rate"`
	RejectionRate pgtype.Numeric `json:"rejection_rate"`
	PeriodEnd     pgtype.Date    `json:"period_end"`
}

func (q *Queries) ListSuppliersByQualityRating(ctx context.Context) ([]ListSuppliersByQualityRatingRow, error) {
	rows, err := q.db.Query(ctx, listSuppliersByQualityRating)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSuppliersByQualityRatingRow{}
	for rows.Next() {
		var i ListSuppliersByQualityRatingRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.QualityScore,
			&i.Rating,
			&i.DefectRate,
			&i.RejectionRate,
			&i.PeriodEnd,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const releaseQualityHold = `-- name: ReleaseQualityHold :one
UPDATE quality_holds
SET 
    is_released = TRUE,
    released_by = $2,
    released_date = CURRENT_TIMESTAMP,
    release_notes = $3
WHERE id = $1
RETURNING id, hold_number, material_id, warehouse_id, batch_number, lot_number, quantity, unit_id, quality_status, hold_reason, inspection_id, ncr_id, placed_by, placed_date, expected_release_date, is_released, released_by, released_date, release_notes, created_at, updated_at
`

type ReleaseQualityHoldParams struct {
	ID           int32       `json:"id"`
	ReleasedBy   pgtype.Int4 `json:"released_by"`
	ReleaseNotes pgtype.Text `json:"release_notes"`
}

func (q *Queries) ReleaseQualityHold(ctx context.Context, arg ReleaseQualityHoldParams) (QualityHold, error) {
	row := q.db.QueryRow(ctx, releaseQualityHold, arg.ID, arg.ReleasedBy, arg.ReleaseNotes)
	var i QualityHold
	err := row.Scan(
		&i.ID,
		&i.HoldNumber,
		&i.MaterialID,
		&i.WarehouseID,
		&i.BatchNumber,
		&i.LotNumber,
		&i.Quantity,
		&i.UnitID,
		&i.QualityStatus,
		&i.HoldReason,
		&i.InspectionID,
		&i.NcrID,
		&i.PlacedBy,
		&i.PlacedDate,
		&i.ExpectedReleaseDate,
		&i.IsReleased,
		&i.ReleasedBy,
		&i.ReleasedDate,
		&i.ReleaseNotes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const searchQualityInspectionCriteria = `-- name: SearchQualityInspectionCriteria :many
SELECT id, name, description, criteria_type, specification, unit_id, tolerance_min, tolerance_max, is_critical, is_active, created_at, updated_at FROM quality_inspection_criteria
WHERE name ILIKE '%' || $1 || '%'
    OR description ILIKE '%' || $1 || '%'
ORDER BY name
LIMIT $2 OFFSET $3
`

type SearchQualityInspectionCriteriaParams struct {
	Column1 pgtype.Text `json:"column_1"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

func (q *Queries) SearchQualityInspectionCriteria(ctx context.Context, arg SearchQualityInspectionCriteriaParams) ([]QualityInspectionCriterium, error) {
	rows, err := q.db.Query(ctx, searchQualityInspectionCriteria, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QualityInspectionCriterium{}
	for rows.Next() {
		var i QualityInspectionCriterium
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CriteriaType,
			&i.Specification,
			&i.UnitID,
			&i.ToleranceMin,
			&i.ToleranceMax,
			&i.IsCritical,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMaterialQualitySpec = `-- name: UpdateMaterialQualitySpec :one
UPDATE material_quality_specs
SET 
    is_required = COALESCE($2, is_required),
    custom_tolerance_min = COALESCE($3, custom_tolerance_min),
    custom_tolerance_max = COALESCE($4, custom_tolerance_max)
WHERE id = $1
RETURNING id, material_id, criteria_id, is_required, custom_tolerance_min, custom_tolerance_max, created_at, updated_at
`

type UpdateMaterialQualitySpecParams struct {
	ID                 int32          `json:"id"`
	IsRequired         pgtype.Bool    `json:"is_required"`
	CustomToleranceMin pgtype.Numeric `json:"custom_tolerance_min"`
	CustomToleranceMax pgtype.Numeric `json:"custom_tolerance_max"`
}

func (q *Queries) UpdateMaterialQualitySpec(ctx context.Context, arg UpdateMaterialQualitySpecParams) (MaterialQualitySpec, error) {
	row := q.db.QueryRow(ctx, updateMaterialQualitySpec,
		arg.ID,
		arg.IsRequired,
		arg.CustomToleranceMin,
		arg.CustomToleranceMax,
	)
	var i MaterialQualitySpec
	err := row.Scan(
		&i.ID,
		&i.MaterialID,
		&i.CriteriaID,
		&i.IsRequired,
		&i.CustomToleranceMin,
		&i.CustomToleranceMax,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateNonConformanceReport = `-- name: UpdateNonConformanceReport :one
UPDATE non_conformance_reports
SET 
    status = COALESCE($2, status),
    root_cause = COALESCE($3, root_cause),
    root_cause_analysis_by = COALESCE($4, root_cause_analysis_by),
    root_cause_date = COALESCE($5, root_cause_date),
    corrective_action = COALESCE($6, corrective_action),
    preventive_action = COALESCE($7, preventive_action),
    action_assigned_to = COALESCE($8, action_assigned_to),
    action_due_date = COALESCE($9, action_due_date),
    action_completed_date = COALESCE($10, action_completed_date),
    disposition = COALESCE($11, disposition),
    cost_impact = COALESCE($12, cost_impact),
    closed_by = COALESCE($13, closed_by),
    closed_date = COALESCE($14, closed_date),
    notes = COALESCE($15, notes),
    attachments = COALESCE($16, attachments)
WHERE id = $1
RETURNING id, ncr_number, title, description, ncr_type, severity, status, material_id, batch_number, quantity_affected, unit_id, inspection_id, supplier_id, customer_id, purchase_order_id, sales_order_id, root_cause, root_cause_analysis_by, root_cause_date, corrective_action, preventive_action, action_assigned_to, action_due_date, action_completed_date, disposition, cost_impact, reported_by, reported_date, closed_by, closed_date, attachments, notes, created_at, updated_at
`

type UpdateNonConformanceReportParams struct {
	ID                  int32              `json:"id"`
	Status              NullNcrStatus      `json:"status"`
	RootCause           pgtype.Text        `json:"root_cause"`
	RootCauseAnalysisBy pgtype.Int4        `json:"root_cause_analysis_by"`
	RootCauseDate       pgtype.Timestamptz `json:"root_cause_date"`
	CorrectiveAction    pgtype.Text        `json:"corrective_action"`
	PreventiveAction    pgtype.Text        `json:"preventive_action"`
	ActionAssignedTo    pgtype.Int4        `json:"action_assigned_to"`
	ActionDueDate       pgtype.Date        `json:"action_due_date"`
	ActionCompletedDate pgtype.Date        `json:"action_completed_date"`
	Disposition         pgtype.Text        `json:"disposition"`
	CostImpact          pgtype.Numeric     `json:"cost_impact"`
	ClosedBy            pgtype.Int4        `json:"closed_by"`
	ClosedDate          pgtype.Timestamptz `json:"closed_date"`
	Notes               pgtype.Text        `json:"notes"`
	Attachments         []byte             `json:"attachments"`
}

func (q *Queries) UpdateNonConformanceReport(ctx context.Context, arg UpdateNonConformanceReportParams) (NonConformanceReport, error) {
	row := q.db.QueryRow(ctx, updateNonConformanceReport,
		arg.ID,
		arg.Status,
		arg.RootCause,
		arg.RootCauseAnalysisBy,
		arg.RootCauseDate,
		arg.CorrectiveAction,
		arg.PreventiveAction,
		arg.ActionAssignedTo,
		arg.ActionDueDate,
		arg.ActionCompletedDate,
		arg.Disposition,
		arg.CostImpact,
		arg.ClosedBy,
		arg.ClosedDate,
		arg.Notes,
		arg.Attachments,
	)
	var i NonConformanceReport
	err := row.Scan(
		&i.ID,
		&i.NcrNumber,
		&i.Title,
		&i.Description,
		&i.NcrType,
		&i.Severity,
		&i.Status,
		&i.MaterialID,
		&i.BatchNumber,
		&i.QuantityAffected,
		&i.UnitID,
		&i.InspectionID,
		&i.SupplierID,
		&i.CustomerID,
		&i.PurchaseOrderID,
		&i.SalesOrderID,
		&i.RootCause,
		&i.RootCauseAnalysisBy,
		&i.RootCauseDate,
		&i.CorrectiveAction,
		&i.PreventiveAction,
		&i.ActionAssignedTo,
		&i.ActionDueDate,
		&i.ActionCompletedDate,
		&i.Disposition,
		&i.CostImpact,
		&i.ReportedBy,
		&i.ReportedDate,
		&i.ClosedBy,
		&i.ClosedDate,
		&i.Attachments,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateQualityHold = `-- name: UpdateQualityHold :one
UPDATE quality_holds
SET 
    quality_status = COALESCE($2, quality_status),
    hold_reason = COALESCE($3, hold_reason),
    expected_release_date = COALESCE($4, expected_release_date),
    is_released = COALESCE($5, is_released),
    released_by = COALESCE($6, released_by),
    released_date = COALESCE($7, released_date),
    release_notes = COALESCE($8, release_notes)
WHERE id = $1
RETURNING id, hold_number, material_id, warehouse_id, batch_number, lot_number, quantity, unit_id, quality_status, hold_reason, inspection_id, ncr_id, placed_by, placed_date, expected_release_date, is_released, released_by, released_date, release_notes, created_at, updated_at
`

type UpdateQualityHoldParams struct {
	ID                  int32              `json:"id"`
	QualityStatus       NullQualityStatus  `json:"quality_status"`
	HoldReason          pgtype.Text        `json:"hold_reason"`
	ExpectedReleaseDate pgtype.Date        `json:"expected_release_date"`
	IsReleased          pgtype.Bool        `json:"is_released"`
	ReleasedBy          pgtype.Int4        `json:"released_by"`
	ReleasedDate        pgtype.Timestamptz `json:"released_date"`
	ReleaseNotes        pgtype.Text        `json:"release_notes"`
}

func (q *Queries) UpdateQualityHold(ctx context.Context, arg UpdateQualityHoldParams) (QualityHold, error) {
	row := q.db.QueryRow(ctx, updateQualityHold,
		arg.ID,
		arg.QualityStatus,
		arg.HoldReason,
		arg.ExpectedReleaseDate,
		arg.IsReleased,
		arg.ReleasedBy,
		arg.ReleasedDate,
		arg.ReleaseNotes,
	)
	var i QualityHold
	err := row.Scan(
		&i.ID,
		&i.HoldNumber,
		&i.MaterialID,
		&i.WarehouseID,
		&i.BatchNumber,
		&i.LotNumber,
		&i.Quantity,
		&i.UnitID,
		&i.QualityStatus,
		&i.HoldReason,
		&i.InspectionID,
		&i.NcrID,
		&i.PlacedBy,
		&i.PlacedDate,
		&i.ExpectedReleaseDate,
		&i.IsReleased,
		&i.ReleasedBy,
		&i.ReleasedDate,
		&i.ReleaseNotes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateQualityInspection = `-- name: UpdateQualityInspection :one
UPDATE quality_inspections
SET 
    inspection_status = COALESCE($2, inspection_status),
    inspection_date = COALESCE($3, inspection_date),
    inspector_id = COALESCE($4, inspector_id),
    approved_by_id = COALESCE($5, approved_by_id),
    quantity_passed = COALESCE($6, quantity_passed),
    quantity_failed = COALESCE($7, quantity_failed),
    quantity_on_hold = COALESCE($8, quantity_on_hold),
    final_decision = COALESCE($9, final_decision),
    decision_date = COALESCE($10, decision_date),
    notes = COALESCE($11, notes),
    attachments = COALESCE($12, attachments)
WHERE id = $1
RETURNING id, inspection_number, inspection_type, inspection_status, material_id, batch_number, lot_number, quantity, unit_id, purchase_order_id, sales_order_id, stock_movement_id, supplier_id, inspection_date, inspector_id, approved_by_id, quantity_passed, quantity_failed, quantity_on_hold, final_decision, decision_date, notes, attachments, created_at, updated_at
`

type UpdateQualityInspectionParams struct {
	ID               int32                       `json:"id"`
	InspectionStatus NullQualityInspectionStatus `json:"inspection_status"`
	InspectionDate   pgtype.Timestamptz          `json:"inspection_date"`
	InspectorID      pgtype.Int4                 `json:"inspector_id"`
	ApprovedByID     pgtype.Int4                 `json:"approved_by_id"`
	QuantityPassed   pgtype.Numeric              `json:"quantity_passed"`
	QuantityFailed   pgtype.Numeric              `json:"quantity_failed"`
	QuantityOnHold   pgtype.Numeric              `json:"quantity_on_hold"`
	FinalDecision    NullQualityStatus           `json:"final_decision"`
	DecisionDate     pgtype.Timestamptz          `json:"decision_date"`
	Notes            pgtype.Text                 `json:"notes"`
	Attachments      []byte                      `json:"attachments"`
}

func (q *Queries) UpdateQualityInspection(ctx context.Context, arg UpdateQualityInspectionParams) (QualityInspection, error) {
	row := q.db.QueryRow(ctx, updateQualityInspection,
		arg.ID,
		arg.InspectionStatus,
		arg.InspectionDate,
		arg.InspectorID,
		arg.ApprovedByID,
		arg.QuantityPassed,
		arg.QuantityFailed,
		arg.QuantityOnHold,
		arg.FinalDecision,
		arg.DecisionDate,
		arg.Notes,
		arg.Attachments,
	)
	var i QualityInspection
	err := row.Scan(
		&i.ID,
		&i.InspectionNumber,
		&i.InspectionType,
		&i.InspectionStatus,
		&i.MaterialID,
		&i.BatchNumber,
		&i.LotNumber,
		&i.Quantity,
		&i.UnitID,
		&i.PurchaseOrderID,
		&i.SalesOrderID,
		&i.StockMovementID,
		&i.SupplierID,
		&i.InspectionDate,
		&i.InspectorID,
		&i.ApprovedByID,
		&i.QuantityPassed,
		&i.QuantityFailed,
		&i.QuantityOnHold,
		&i.FinalDecision,
		&i.DecisionDate,
		&i.Notes,
		&i.Attachments,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateQualityInspectionCriteria = `-- name: UpdateQualityInspectionCriteria :one
UPDATE quality_inspection_criteria
SET 
    name = COALESCE($2, name),
    description = COALESCE($3, description),
    criteria_type = COALESCE($4, criteria_type),
    specification = COALESCE($5, specification),
    unit_id = COALESCE($6, unit_id),
    tolerance_min = COALESCE($7, tolerance_min),
    tolerance_max = COALESCE($8, tolerance_max),
    is_critical = COALESCE($9, is_critical),
    is_active = COALESCE($10, is_active)
WHERE id = $1
RETURNING id, name, description, criteria_type, specification, unit_id, tolerance_min, tolerance_max, is_critical, is_active, created_at, updated_at
`

type UpdateQualityInspectionCriteriaParams struct {
	ID            int32          `json:"id"`
	Name          pgtype.Text    `json:"name"`
	Description   pgtype.Text    `json:"description"`
	CriteriaType  pgtype.Text    `json:"criteria_type"`
	Specification pgtype.Text    `json:"specification"`
	UnitID        pgtype.Int4    `json:"unit_id"`
	ToleranceMin  pgtype.Numeric `json:"tolerance_min"`
	ToleranceMax  pgtype.Numeric `json:"tolerance_max"`
	IsCritical    pgtype.Bool    `json:"is_critical"`
	IsActive      pgtype.Bool    `json:"is_active"`
}

func (q *Queries) UpdateQualityInspectionCriteria(ctx context.Context, arg UpdateQualityInspectionCriteriaParams) (QualityInspectionCriterium, error) {
	row := q.db.QueryRow(ctx, updateQualityInspectionCriteria,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.CriteriaType,
		arg.Specification,
		arg.UnitID,
		arg.ToleranceMin,
		arg.ToleranceMax,
		arg.IsCritical,
		arg.IsActive,
	)
	var i QualityInspectionCriterium
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CriteriaType,
		&i.Specification,
		&i.UnitID,
		&i.ToleranceMin,
		&i.ToleranceMax,
		&i.IsCritical,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSupplierQualityRating = `-- name: UpdateSupplierQualityRating :one
UPDATE supplier_quality_ratings
SET 
    total_inspections = COALESCE($2, total_inspections),
    passed_inspections = COALESCE($3, passed_inspections),
    failed_inspections = COALESCE($4, failed_inspections),
    total_quantity_received = COALESCE($5, total_quantity_received),
    quantity_rejected = COALESCE($6, quantity_rejected),
    total_defects = COALESCE($7, total_defects),
    critical_defects = COALESCE($8, critical_defects),
    major_defects = COALESCE($9, major_defects),
    minor_defects = COALESCE($10, minor_defects),
    ncr_count = COALESCE($11, ncr_count),
    quality_score = COALESCE($12, quality_score),
    defect_rate = COALESCE($13, defect_rate),
    rejection_rate = COALESCE($14, rejection_rate),
    rating = COALESCE($15, rating),
    notes = COALESCE($16, notes)
WHERE id = $1
RETURNING id, supplier_id, period_start, period_end, total_inspections, passed_inspections, failed_inspections, total_quantity_received, quantity_rejected, total_defects, critical_defects, major_defects, minor_defects, ncr_count, quality_score, defect_rate, rejection_rate, rating, notes, calculated_by, calculation_date, created_at, updated_at
`

type UpdateSupplierQualityRatingParams struct {
	ID                    int32          `json:"id"`
	TotalInspections      pgtype.Int4    `json:"total_inspections"`
	PassedInspections     pgtype.Int4    `json:"passed_inspections"`
	FailedInspections     pgtype.Int4    `json:"failed_inspections"`
	TotalQuantityReceived pgtype.Numeric `json:"total_quantity_received"`
	QuantityRejected      pgtype.Numeric `json:"quantity_rejected"`
	TotalDefects          pgtype.Int4    `json:"total_defects"`
	CriticalDefects       pgtype.Int4    `json:"critical_defects"`
	MajorDefects          pgtype.Int4    `json:"major_defects"`
	MinorDefects          pgtype.Int4    `json:"minor_defects"`
	NcrCount              pgtype.Int4    `json:"ncr_count"`
	QualityScore          pgtype.Numeric `json:"quality_score"`
	DefectRate            pgtype.Numeric `json:"defect_rate"`
	RejectionRate         pgtype.Numeric `json:"rejection_rate"`
	Rating                pgtype.Text    `json:"rating"`
	Notes                 pgtype.Text    `json:"notes"`
}

func (q *Queries) UpdateSupplierQualityRating(ctx context.Context, arg UpdateSupplierQualityRatingParams) (SupplierQualityRating, error) {
	row := q.db.QueryRow(ctx, updateSupplierQualityRating,
		arg.ID,
		arg.TotalInspections,
		arg.PassedInspections,
		arg.FailedInspections,
		arg.TotalQuantityReceived,
		arg.QuantityRejected,
		arg.TotalDefects,
		arg.CriticalDefects,
		arg.MajorDefects,
		arg.MinorDefects,
		arg.NcrCount,
		arg.QualityScore,
		arg.DefectRate,
		arg.RejectionRate,
		arg.Rating,
		arg.Notes,
	)
	var i SupplierQualityRating
	err := row.Scan(
		&i.ID,
		&i.SupplierID,
		&i.PeriodStart,
		&i.PeriodEnd,
		&i.TotalInspections,
		&i.PassedInspections,
		&i.FailedInspections,
		&i.TotalQuantityReceived,
		&i.QuantityRejected,
		&i.TotalDefects,
		&i.CriticalDefects,
		&i.MajorDefects,
		&i.MinorDefects,
		&i.NcrCount,
		&i.QualityScore,
		&i.DefectRate,
		&i.RejectionRate,
		&i.Rating,
		&i.Notes,
		&i.CalculatedBy,
		&i.CalculationDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
